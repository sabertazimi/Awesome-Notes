{"./":{"url":"./","title":"Introduction","keywords":"","body":" Table of Contents Computer Science Algorithms Algorithms Basic Notes Oj Basic Notes Architecture Arch Basic Notes Graph Processing Notes Compilers Compilers Basic Notes Data Base Database Basic Notes Network Network Basic Notes Operating Systems CSAPP Memory Management Basic Notes Operating Systems Basic Notes Software Testing Software Testing Basic Notes Virtualization Virt Basic Notes Latex Basic Notes Language Assembly Assembly Basic C Tools Awesome Tools Gdb Tutorial C Basic Notes Naming Conventions Standard Library Cpp Cpp Basic Notes Go Go Basic Notes Haskell Haskell Basic Notes Java Java Basic Notes Java Naming Conventions Python Python Basic Notes Verilog Verilog Basic Notes Programming Android Android Basic Notes Code Guide Bug Guide Basic Notes Clean Code Basic Notes Code Review Basic Notes Design Patterns Notes Functional Programming Functional Programming Basic Notes Game Game Design Basic Notes Linux Linux Basic Notes Server Message Queue Basic Notes Tools Build Tools Cmake Basic Notes Makefile Basic Notes Git Git Basic Notes Vim Vim Basic Notes Web Angular Angular Basic Notes Css Bootstrap Basic Notes Css Advanced Notes Css Basic Notes Sass Basic Notes Sass Offical Reference Frameworks Electron Basic Notes J Query Basic Notes Html Html Basic Notes Javascript Javascript Advanced Notes Javascript Basic Notes Typescript Basic Notes Nodejs Express Basic Notes Graphql Basic Notes Nodejs Basic Notes Reactjs Reactjs Basic Notes React Router Basic Notes Redux Basic Notes Webpack Basic Notes Security Security Basic Notes Vuejs Vue Basic Notes Library Basic NotesAwesome Notes _ _ _____ ___ ___ _ __ ___ ___ _ __ ___ | |_ ___ ___ \\ /\\ / / _ \\/ __|/ _ \\| '_ ` _ \\ / _ \\ | '_ \\ / _ \\| __/ _ \\/ __| \\ V V / __/\\__ \\ (_) | | | | | | __/ | | | | (_) | || __/\\__ \\ \\_/\\_/ \\___||___/\\___/|_| |_| |_|\\___| |_| |_|\\___/ \\__\\___||___/ Personal Learning Notes - Awesome Notes for Myself GitHub Version built on GitBook.IO v1. GitBook Version built on GitBook.IO v2. Sample C Implement Generic Variable with Pointer void *lsearch( void *key, void *base, int n, int elemSize, int (*cmpfn)(void *, void *) ) { for (int i = 0;i Git Commit Message firstline - (): (emptyline) (emptyline) Pretty Logger git log -p --stat --graph --pretty=format:\"%h - %an, %ar : %s\" --since=2.weeks path_name JavaScript Type Check function typeOf(o) { var _toString = Object.prototype.toString, _type = { 'undefined': 'undefined', 'number': 'number', 'boolean': 'boolean', 'string': 'string', '[object Function]': 'function', '[object Array]': 'array', '[object Date]': 'date', '[object RegExp]': 'regexp', '[object Error]': 'error' }; return _type[typeof o] || _type[_toString.call(o)] || (o ? 'object' : 'null'); } ES5 Module Best Practice It's time to embrace ES Next/Harmony. // 命名空间模式 MYAPP.namespace('MYAPP.utilities.array'); //形参: 导入全局变量 MYAPP.utilities.array = (function (app, global) { // start of var declare // 依赖模式 var uobj = MYAPP.utilities.object, ulang = MYAPP.utilities.lang, // 私有属性 arrStr = \"[object Array]\", toStr = Object.prototype.toString; // 私有方法 inArray = function (haystack, needle) { for (var i = 0, max = haystack.length; i License MIT License Copyright (c) sabertazimi Contact © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/algorithms/algorithmsBasicNotes.html":{"url":"computerScience/algorithms/algorithmsBasicNotes.html","title":"Algorithms Basic Notes","keywords":"","body":"Algorithm Basic Notes Algorithm Basic Notes Sorting Algorithm Summary Selection Sort Insertion Sort/Shell Sort Merge Sort Quick Sort Heap Sort(Priority Queue) Radix-Sorts 基数排序(可用于混乱 shuffle 数组) Tree Algorithm Binary Search Tree 2-3Tree Banlance Tree Red-Black BST 基本性质 基本操作 B Tree 插入/删除 Fibonacci Heap K-Dimensional Tree Search Algorithm Fisrt Search cycle detection Dynamic Programming 子问题 范例 Greedy Algorithm Map Algorithm 图的表示 稀疏矩阵 广度优先遍历 v.color v.pi v.d 利用队列实现广度优先遍历 深度优先遍历 v.color v.pi v.d/v.f 拓扑排序 Kahn 算法 DFS(深度优先) 单源最短路径 DAG Shortest Paths Bellman-Ford Algorithm Dijkstra Algorithm 结点对最短路径 Floyd-Warshall Algorithm MaxFLow Problem 最大流模型 残存网络 MaxFlow-Mincut Theorem 最大流最小割定理 Ford-Fulkerson Algorithm Tree Edit Distance Defination Sorting Algorithm Summary 强制稳定: 增加(唯一)时间戳, 修改 CompareTo 接口定义 => 当主元素相同时, 时间戳小的元素更小 Selection Sort swap: O(n) compare: O(n^2) Insertion Sort/Shell Sort swap: O(n^2/4) compare: O(n^2/4) Merge Sort 利用 Merge Sort 计算逆序对个数: left[i] > right[j] => inversions += (mid - i + 1), 即所有 i~mid 元素都与 j 元素为逆序对 // merge and count private static long merge(int[] a, int[] aux, int lo, int mid, int hi) { long inversions = 0; // copy to aux[] for (int k = lo; k mid) a[k] = aux[j++]; else if (j > hi) a[k] = aux[i++]; else if (aux[j] {@code a[j]}. */ public static long count(int[] a) { int[] b = new int[a.length]; int[] aux = new int[a.length]; for (int i = 0; i // return Kendall tau distance between two permutations public static long distance(int[] a, int[] b) { if (a.length != b.length) { throw new IllegalArgumentException(\"Array dimensions disagree\"); } int n = a.length; int[] ainv = new int[n]; for (int i = 0; i Quick Sort partition: 哨兵(最后再将其归位) + 大循环 + 2 小循环, 交换元素法 partition: 辅助数组 brr, 3 循环(3 次扫描 arr) 分别将小/等/大于 guard 的数加入 brr partition: 哨兵(最后再将其归位) + lo + hi, 外加 2 个动指针 leftlimit 与 rightlimit, 表示小于区的上界和大于区的上界 // lt eq gt three parts void quick3waySort(int *a, int lo, int hi) { if (hi 0) exch(a, i, gt--); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); } Heap Sort(Priority Queue) swap: 2NlgN + 2N (2NlgN for sink N times, 2N for construct MaxHeap) compare: NlgN + N (NlgN for sink N times, N for construct MaxHeap) // MaxPQ void swim(int k) { while (k > 1 && less(k/2, k)) { exch(k/2, k); k = k/2; } } void sink(int k) { while (2*k Radix-Sorts 基数排序(可用于混乱 shuffle 数组) 从个位到高位放入桶 从高位到个位放入桶 Sorting Algorithms Performance Tree Algorithm Binary Search Tree Hibbard Deletion 2-3Tree Banlance Tree 插入: 1+1=2node -> 3node 1+2=3node -> 4node -> 2node 将 4node 结点中间元素移至父结点, 其余 2 元素分离为子 2node 节点 Red-Black BST 基于 2-3Tree, 将 3node 用红色标记 关键: 将红色标记向上传递至根部 // is node x red; false if x is null ? private boolean isRed(Node x) { if (x == null) return false; return x.color == RED; } // make a right-leaning link lean to the left private Node rotateLeft(Node h) { // assert (h != null) && isRed(h.right); Node x = h.right; h.right = x.left; x.left = h; x.color = x.left.color; x.left.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; } // make a left-leaning link lean to the right private Node rotateRight(Node h) { // assert (h != null) && isRed(h.left); Node x = h.left; h.left = x.right; x.right = h; x.color = x.right.color; x.right.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; } // flip the colors of a node and its two children private void flipColors(Node h) { // h must have opposite color of its two children // assert (h != null) && (h.left != null) && (h.right != null); // assert (!isRed(h) && isRed(h.left) && isRed(h.right)) // || (isRed(h) && !isRed(h.left) && !isRed(h.right)); h.color = !h.color; h.left.color = !h.left.color; h.right.color = !h.right.color; } // insert the key-value pair in the subtree rooted at h private Node put(Node h, Key key, Value val) { // insert/put new node as left/right child of leaf node if (h == null) return new Node(key, val, RED, 1); int cmp = key.compareTo(h.key); if (cmp 0) h.right = put(h.right, key, val); else h.val = val; // fix-up any right-leaning links if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) && isRed(h.right)) flipColors(h); h.size = size(h.left) + size(h.right) + 1; return h; } public void put(Key key, Value val) { if (key == null) { throw new IllegalArgumentException(\"first argument to put() is null\"); } if (val == null) { delete(key); return; } root = put(root, key, val); root.color = BLACK; // assert check(); } // Assuming that h is red and both h.left and h.left.left // are black, make h.left or one of its children red. private Node moveRedLeft(Node h) { // assert (h != null); // assert isRed(h) && !isRed(h.left) && !isRed(h.left.left); flipColors(h); if (isRed(h.right.left)) { h.right = rotateRight(h.right); h = rotateLeft(h); flipColors(h); } return h; } // Assuming that h is red and both h.right and h.right.left // are black, make h.right or one of its children red. private Node moveRedRight(Node h) { // assert (h != null); // assert isRed(h) && !isRed(h.right) && !isRed(h.right.left); flipColors(h); if (isRed(h.left.left)) { h = rotateRight(h); flipColors(h); } return h; } // restore red-black tree invariant private Node balance(Node h) { // assert (h != null); if (isRed(h.right)) h = rotateLeft(h); if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) && isRed(h.right)) flipColors(h); h.size = size(h.left) + size(h.right) + 1; return h; } // delete the key-value pair with the minimum key rooted at h private Node deleteMin(Node h) { if (h.left == null) return null; if (!isRed(h.left) && !isRed(h.left.left)) h = moveRedLeft(h); h.left = deleteMin(h.left); return balance(h); } /** * Removes the smallest key and associated value from the symbol table. * @throws NoSuchElementException if the symbol table is empty */ public void deleteMin() { if (isEmpty()) throw new NoSuchElementException(\"BST underflow\"); // if both children of root are black, set root to red if (!isRed(root.left) && !isRed(root.right)) root.color = RED; root = deleteMin(root); if (!isEmpty()) root.color = BLACK; // assert check(); } // delete the key-value pair with the maximum key rooted at h private Node deleteMax(Node h) { if (isRed(h.left)) h = rotateRight(h); if (h.right == null) return null; if (!isRed(h.right) && !isRed(h.right.left)) h = moveRedRight(h); h.right = deleteMax(h.right); return balance(h); } /** * Removes the largest key and associated value from the symbol table. * @throws NoSuchElementException if the symbol table is empty */ public void deleteMax() { if (isEmpty()) throw new NoSuchElementException(\"BST underflow\"); // if both children of root are black, set root to red if (!isRed(root.left) && !isRed(root.right)) root.color = RED; root = deleteMax(root); if (!isEmpty()) root.color = BLACK; // assert check(); } // delete the key-value pair with the given key rooted at h private Node delete(Node h, Key key) { // assert get(h, key) != null; if (key.compareTo(h.key) 基本性质 非红即黑 根黑 叶黑 e.g T.null 黑哨兵 红父孩子黑 简单路径同黑 右孩子不红 e.g 父黑两孩红 -> 父红两孩黑(flip); 父黑右红 -> 父左旋变红, 右孩子变黑(left-rotate) 基本操作 插入(插入红点, 旋转+重新着色(反色)保持红黑性质) 删除(删除红点, 旋转+重新着色(反色)保持红黑性质) B Tree t: 每个内部结点至少 t 个孩子(t-1 个 key), 至多 2t 个孩子(2t-1 个 key) 插入/删除 下溯的同时,分裂满结点 Fibonacci Heap BST + 循环双向链表: 一个根树(根结点)循环双向链表 n 个孩子循环双向链表: 每个根树的每层结点形成一个循环双向链表 K-Dimensional Tree 分隔空间数据 e.g 左子树：左下方 右子树：右上方 Search Algorithm Fisrt Search DFS(深度优先)：栈实现 BFS(广度优先)：队列实现 cycle detection 许多图论算法不适用于存在环路的复杂图,故使用循环检测剔除意外情况 处理方法：可将环路元素(如强联通分支)视作单一元素，忽视其内部结构 a = b+1;b = c+1;c = a+1; //a extends b;b extends c;c extends a; Dynamic Programming 最优解结构特征: 一个选择 + 子问题的最优解 - 所有(可重复求解)子问题的最优解可独立求解(不互相影响) 递归定义最优解: 列出递归表达式 自底向上求解最优解 构造最优解(额外信息数组) 子问题 子问题可映射为有向图, 并对其进行拓扑排序: 共有 O(n) 个子问题, 每个子问题最多 O(n) 种选择, 则算法时间复杂度为 O(n^2).其对应子问题图有 n 个顶点, 每个顶点最多有 n-1 条边. 递归生成可以重复求解的子问题,而不是不断生成新的子问题 范例 切割钢条问题: max{p[i], r[n-i]} 矩阵相乘链问题 最大公共子序列问题: r[i, j] = max{r[i, j-1], r[i-1, j]} 无权最短路径: path[i, j] = min{path[i, r], [r, j]} Greedy Algorithm 最优解结构特征: 一个选择 + 子问题的最优解 - 所有(可重复求解)子问题的最优解可独立求解(不互相影响) 递归定义最优解: 列出递归表达式 自底向上求解最优解: 每次不进行多次选择, 只进行一次 贪心选择 构造最优解(额外信息数组) Map Algorithm 图的表示 邻接链表法 邻接矩阵法 稀疏矩阵 unordered_map > // => (row, (col, val)) 广度优先遍历 v.color white: 未被发现/访问 gray: 已被发现(进入队列), 邻接结点未全部发现 black: 已被发现, 邻接结点全部发现 v.pi 广度优先树父结点 v.d 距离 = v.pi.d + 1 利用队列实现广度优先遍历 深度优先遍历 利用 递归/栈 实现深度优先遍历 v.color white: 未被发现/访问 gray: 已被发现, 未二次访问 black: 已被发现, 二次访问(比其深的所有结点皆被发现) 当第一个访问 edge(u,v) 时: v.color == white: 树边 v.color == gray : 后向边(v 为 深度优先*森林- 的祖父结点) v.color == black: 前向边/横向边(v 为较深的结点/子结点) 无向图深度优先遍历不会出现 前向边/横向边 v.pi 比 v 浅的结点(比 v 更早被发现的结点) v.d/v.f v.d = ++time: 被发现的时间戳(入栈) v.f = ++time: 被二次访问的时间戳(出栈) timev.d, white; v.dtimev.f, gray: time>v.f, black 拓扑排序 目标集合: 拓扑排序后集合, 先入顶点高序, 后入顶点低序 Kahn 算法 不断将图中入度为 0 的点移入目标集合 DFS(深度优先) 当深度遍历至较深处, 并开始回溯时, 将此时访问的顶点加入目标集合(v.f 降序) 单源最短路径 void Relax(int u, int v, int w) { if v.d > u.d + w[u][v] { v.pi = u; v.d = v.pi.d + w[v.pi][v]; } } DAG Shortest Paths 先将图进行拓扑排序(深度优先遍历), 再按照拓扑排序顺序, 依次对每个结点(拓扑排序)的邻接边进行 relax a -> b -> c --> d, 且 a--b, a--c, b--d, c--d: relax(a, b), relax(a, c), relax(b, d), relax(c, d) Bellman-Ford Algorithm 对每条边进行 n 次(结点总数) relax Dijkstra Algorithm 贪心算法: 每次选取不属于 S 集合(white) 且 v.d 最小(gray)的结点, 对其所有邻接边进行 relax, 并将其加入 S 集合(black) white: 不属于 S 集合 gray: 不属于 S 集合 且 v.d 最小 black: 属于 S 集合 结点对最短路径 动态规划:l^m(i, j) = min(l^m-1(i, j), min(1 m: 中间结点个数 Floyd-Warshall Algorithm d^k(i, j) = w(i, j), k = 0 | min(d^k-1(i, j), d^k-1(i, k) + d^k-1(k, j)), k >= 1 pi^(i, j) = pi^k-1(i, j) or pi^k-1(k, j) k: 中间结点个数 Matrix floyd_warshall(Matrix W) { int n = W.rows; Matrix D^0 = W; for (int k = 1;k MaxFLow Problem 最大流模型 最大流模型必须满足以下条件: 无双向边 唯一的源点 s 和 唯一的汇点 t 对于不符合该模型的问题可进行简单转化: 双向边: 添加额外结点, 切割双向边的其中一条, 使得双向边变成 3 条单向边 a --> b, b --> a: a --> c, c --> b, b --> a 多源点/汇点: 添加一个总源点/汇点 残存网络 若原图 u --> v 总容量 > 0, 则残存网络中 边 u --> v:剩余容量, 边 v --> u: 已用容量 增广路径: 残存网络中一条可行通路 MaxFlow-Mincut Theorem 最大流最小割定理 切割的净流量: 流出-流入 切割的容量: 流出总容量(无需减流入总容量) 最小切割: 容量最小的切割 最大流最小割定理: 以下三个命题等价 f 是 G 的一个最大流 残存网络 Gf 不含增广路径 |f| = c(S, T)(切割的容量): |f| Ford-Fulkerson Algorithm 不断寻找增广路径 Tree Edit Distance Defination Tree Edit Distance: 给定 Cost(edit operation) 时的最小编辑费用 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/algorithms/ojBasicNotes.html":{"url":"computerScience/algorithms/ojBasicNotes.html","title":"Oj Basic Notes","keywords":"","body":"OJ Basic Notes OJ Basic Notes C++ Notes for OJ Format string and integer Iterator slice limits Implementation Pattern(OOP Pattern) algorithm sort map Algorithm Search Problem Search in Sorted Array Max/Min Problem Range Max/Min Query Greedy Algorithm Simulation Painting Reverting Meet/Collision Problem String Rotate String Map Theory Shortest Paths Minial Spanning Tree BFS(mark array/queue) DFS(mark array/stack/recursion) Connected Component Strongly Connected Component tUnion + tFind Dynamic Programming 典型题目 Digital Bits Dynamic Programming(数位 DP) 题目模式 解题模式 Math Matrix Fast Power Mod Power Tips Array Map Set Two Pointer Float Pointer bit 表示法 C++ Notes for OJ Format string and integer stringstream to_string stoll atoi/atol/atof Iterator slice vector b(a.begin() + 1, a.end()); vector c(a.rbegin(), a.rend()); limits #include #include #include using namespace std; int main(void) { cout ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)(); cout ::min)() ::max)() ::min)() Implementation Pattern(OOP Pattern) #define FIN freopen(\"input.txt\",\"r\",stdin) #define FOUT freopen(\"output.txt\",\"w\",stdout) #define fst first #define snd second typedef long long LL; typedef pair PII; const int INF = 0x3f3f3f3f; const int MAXN = 500 + 5; const int MAXP = 6 + 5; int T, N, M, P, res; char buf[MAXN]; int usr[MAXN], usr_cnt; struct MST { struct Edge { int u, v, w; Edge() {} Edge(int u, int v, int w):u(u), v(v), w(w) {} bool operator (const QNode & e) const { return w > e.w; } } cur; int head[MAXN], tot; int dist[MAXN]; bool vis[MAXN]; priority_queue , greater >Q; void init() { tot = 0; memset(head, -1, sizeof(head)); memset(dist, 0x3f, sizeof(dist)); memset(vis, false, sizeof(vis)); } void add_edge(int u, int v, int w) { edges[tot] = Edge(v, w, head[u]); head[u] = tot++; } int dijkstra(int src, int dst) { int u, v, w; Q.push(QNode(src, dist[src] = 0)); while (!Q.empty()) { cur = Q.top(); Q.pop(); u = cur.u; if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edges[i].next) { v = edges[i].v, w = edges[i].w; if (!vis[v] && dist[v] > dist[u] + w) { dist[v] = dist[u] + w; Q.push(QNode(v, dist[v])); } } } return dist[dst]; } } dij; int solve() { int u, v, w; if (usr_cnt == N) { mst.init(); for (int i = 1; i algorithm sort in map: auto sort struct Node { bool operator mps; sort vector bool cmp(const elem &i, const elem &j) { return i map insert/update: mp[key] = value; search: mp.count(key)/mp.find(key), 不会插入空元素 unordered_map: hash map Algorithm sort reverse accumulate prev_permutation/next_permutation Search Problem Search in Sorted Array Binary Search Divide and Conquer leetcode 74/240 Max/Min Problem 在某些问题中, 要求满足条件的 max/min, 且可以轻易地判定某个值是否满足该条件, 则可利用二分法进行值的枚举 // poj 1064 int N, K; double L[maxn]; // judgement bool C(double x) { int num = 0; for (int i = 0; i = K; } void solve(void) { double lb = 0, ub = numeric_limits::max(); for (int i = 0; i Range Max/Min Query Segment Tree (线段树) Binary Indexed Tree (树状数组) Bucket Method (Divide and Conquer) const int maxn = 1 ::max)(); } } void update(int k, int a) { k += n - 1; dat[k] = a; while (k > 0) { k = (k - 1) / 2; dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]); } } int query(int a, int b, int k, int l, int r) { // failed if (r ::max)(); } // [l, r) Greedy Algorithm 字典排序比较问题 Huffman Tree Simulation Painting 对于实际操作, 直接覆写至状态数组即可, 无需关心边界条件(效果会立即生效) e.g 交接处方块 , 2 次写 1, maps[i][j] = 1, 不用担心重复计数 Reverting using 1 bit to simulate operation when need to output, calculate bits up combined with dp problem Meet/Collision Problem 将相遇/碰撞的两物体视作插肩而过即可 String sstream::stringstream sort() transform(toupper/tolower) string::size_type string::npos(vector.end()) str.find() == string::npos/string::size_type str.substr(int pos, int len) getline(cin/sin, strbuf) string::size_type pre, post 指针: 进行逐行匹配 Rotate String #include #include string left_rotate(string str, int offset) { int size = str.length(); int n = offset % size; reverse(str.begin(), str.begin() + n); reverse(str.begin() + n, str.end()); reverse(str.begin(), str.end()); return str; } Map Theory Shortest Paths Dijkstra Floyd Minial Spanning Tree Kruskal(tFind/tUnion) BFS(mark array/queue) Shortest Paths Diameter(直径) of Tree(Two pass for BFS) DFS(mark array/stack/recursion) Longest Paths Connected Component Strongly Connected Component Tarjan Alogirthm(v.index(DFS 时此点被访问的顺序) == v.lowlink(从 v 出发经有向边可达到的所有结点中最小的 index)) tUnion + tFind quickly figure out connection of map Dynamic Programming dp 数组可以滚动使用, 从而节省空间 dp[m][n] => dp[2][n] (dp[i & 1][j]) 典型题目 关键: 最优子结构 + 状态无后效性 所有背包问题 二分问题:最优二分搜索树/文件合并 非连续特征序列: 最长子序列/最长上升序列 多重部分和问题 e.g 数组中是否存在一对数的和为 xx 计数问题/分组问题/分划问题 Digital Bits Dynamic Programming(数位 DP) 题目模式 给定区间 [a, b], 求满足特定要求的数, 要求一般与大小无关, 与数位的组成相关 规模巨大, 无法枚举 递增数: 1234, 2579; 双峰数: 19280, 26193; 含 49: 49, 149, 1492; 整除 13: 26, 39 ... 解题模式 f(a, b) = f(b, 0) - f(a - 1, 0) 暴力 + 存储 = 记忆化搜索: 暴力枚举每一位的 (0, ...,9) 利用 dp[pos][state] 与 dfs(pos, state, k, flag) 进行存储 /// \\brief 数字处理函数 /// \\param num 原始数据 /// \\param digit 保存每个数位的值 /// \\param state 初始状态 int f(int num){ int ans; int pos = 0; while(num){ digit[++pos]=num%10; num=num/10; } return dfs( pos, state , true); } /// \\brief dfs 函数, 从高位开始遍历 /// \\param f 记忆化数组 /// \\param pos 当前数位下标 /// \\param state 之前数字的状态 /// \\param flag 上限标志 int dfs(int pos, int state, bool flag) { if (pos == -1) { return state == target_state; } if (!exception && ~f[pos][state]) { return f[pos][state] } int ans = 0; // 对于每一个数位, 求出枚举界限 // 一般从 0 枚举至 9, 当到达特殊位置时, 枚举上限可能改变 int next = exception ? digit[i] : 9; for (int digit = 0; digit typedef long long ll; int a[20]; ll dp[20][state]; //不同题目状态不同 ll dfs(int pos, int state, bool lead, bool limit) { // 递归边界, 按位枚举最低位是0, pos == -1 表示枚举结束 if (pos == -1) { // 若可以保证每一位都合法, 则 return 1; 否则 return 0 return 1; } // 记忆化 if (!limit && !lead && dp[pos][state] != -1) { return dp[pos][state]; } // 根据 limit 判断枚举的上界 up int up = limit ? a[pos] : 9; // 开始计数 ll ans=0; // 枚举: 把不同情况的个数加到ans for(int i = 0;i Math Matrix Fast Power typedef vector mat; mat mul(mat& A, mat& B) { mat C(A.size(), vec(B[0].size())); for(int i = 0; i >= 1; } return E; } Mod Power typedef long long ll; ll mod_pow(ll x, ll n, ll mod) { ll res = 1; while (n > 0) { if (n & 1) res = res * x % mod; x = x * x % mod; n >>= 1; } return res; } Tips Array 可以利用数组元素的正负性表示存在性（或其他特殊意义） Map 用于 Hash 化 用于将字符串转为数字 用于计数 Set 用于去重与查重(duplicate) 用于集合运算题（交、并、差等） Two Pointer 可以在有穷时间内判断是否存在循环：一个快指针，一个慢指针，当两者相遇时，表示存在循环。 Float Pointer 利用浮动指针解决相关问题: 字符串比较 连续区间问题(尺取法) bit 表示法 多用于状态枚举(1 bit 表示 1 个状态/开关), 表示状态集合 可用于动态规划中压缩状态 0 // empty set 1 > i & 1) // include nth(i) bit S | 1 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/architecture/archBasicNotes.html":{"url":"computerScience/architecture/archBasicNotes.html","title":"Arch Basic Notes","keywords":"","body":"Architecture Basic Notes Architecture Basic Notes Superpipeline or Superscalar Instructions Dependencies and Latencies Branch Prediction VLIW (Very Long Instruction Word) Out of Order Execution (OoO or OoE) The Brainiac vs Speed-demon Debate Power Wall and ILP Wall Decoupled x86 microarchitecture SMT (Hardware Threads) More cores or Wider cores DLP (data-level parallelism) SIMD Vector Instructions Memory Memory Wall Caches Cache ocality Cache Layout Memory Latency and Bandwidth Distributed System Reference Superpipeline or Superscalar A supuerpipelined processor own a 5-20 stage pipeline, a superscalar issues 3-8 instructions in parallel (more functional units like integer/float units). Instructions Dependencies and Latencies The number of cycles between when an instruction reaches the execute stage and when its result is available for use by other instructions is called the instruction's latency. The deeper the pipeline, the more stages and thus the longer the latency. The processor will need to stall the execution of the instructions until their data is available (dependencies), inserting a bubble into the pipeline where no work gets done, making multiple issue in this case impossible. Branch Prediction Another key problem for pipelining is branches (flush out all instructions of wrong branch). Unfortunately, even the best branch prediction techniques are sometimes wrong, and with a deep pipeline many instructions might need to be cancelled. This is called the mispredict penalty. The deeper the pipeline, the further into the future you must try to predict, the more likely you'll be wrong, and the greater the mispredict penalty when you are. Predication can be used to eliminate branches such as cmovle (move data only when testing flag stays less or equal state). The Alpha architecture had a conditional move instruction from the very beginning. MIPS, SPARC, x86 added it later and the ARM architecture was the first architecture with a fully predicated instruction set (though the early ARM processors only had short pipelines and small mispredict penalties). VLIW (Very Long Instruction Word) In cases where backward compatibility is not an issue, it is possible for the instruction set itself to be designed to explicitly group instructions to be executed in parallel. A VLIW processor's instruction flow is much like a superscalar, except the decode/dispatch stage is much simpler and only occurs for each group of sub-instructions. No VLIW designs have yet been commercially successful as mainstream CPUs. Out of Order Execution (OoO or OoE) If branches and long-latency instructions are going to cause bubbles in the pipeline(s), then perhaps those empty cycles can be used to do other work. To achieve this, the instructions in the program must be reordered (instruction scheduling and register renaming). Compiler completes static instruction scheduling (rearranged instruction stream at compile time), processor completes dynamic instruction scheduling (renaming registers and reorder instruction stream at runtime). The processor must keep a mapping of the instructions in flight at any moment and the physical registers they use. The extra logic of scheduler is particularly power-hungry because those transistors are always working. The Brainiac vs Speed-demon Debate Brainiac designs are at the smart-machine end of the spectrum, with lots of OOO hardware trying to squeeze every last drop of instruction-level parallelism out of the code, even if it costs millions of logic transistors and years of design effort to do it. In contrast, speed-demon designs are simpler and smaller, relying on a smart compiler and willing to sacrifice a little bit of instruction-level parallelism for the other benefits that simplicity brings. Which would you rather have: 4 powerful brainiac cores, or 8 simpler in-order cores? When it comes to the brainiac debate, many vendors have gone down one path then changed their mind and switched to the other side. Power Wall and ILP Wall Power usage goes up even faster than clock speed does (increasing clock speed by 20% with 50% more power usage, O(power) = frequence * Voltage * Voltage). Leakage current also goes up as the voltage is increased, leakage generally goes up as the temperature increases as well. The power and heat problems become unmanageable, because it's simply not possible to provide that much power and cooling to a silicon chip. Thus, going purely for clock speed is not the best strategy. normal programs just don't have a lot of fine-grained parallelism in them, due to a combination of load latencies, cache misses, branches and dependencies between instructions. This limit of available instruction-level parallelism is called the ILP wall. Decoupled x86 microarchitecture Dynamically decode the x86 instructions into simple, RISC-like micro-instructions (μops, pronounced \"micro-ops\"), which can then be executed by a fast, RISC-style register-renaming OOO superscalar core. The pipeline depth of Core i2/i3 Sandy/Ivy Bridge was shown as 14/19 stages in the earlier section on superpipelining, it is 14 stages when the processor is running from its L0 μop cache (which is the common case), but 19 stages when running from the L1 instruction cache and having to decode x86 instructions and translate them into μops. SMT (Hardware Threads) Even the most aggressively brainiac OOO superscalar processor will still almost never exceed an average of about 2-3 instructions per cycle when running most mainstream, real-world software, due to a combination of load latencies, cache misses, branching and dependencies between instructions. Simultaneous multi-threading (SMT) is a processor design technique which exploits thread-level parallelism (other running programs, or other threads within the same program). The instructions come from multiple threads running at the same time, all on the one processor core. An SMT processor uses just one physical processor core to present two or more logical processors to the system. Seperate units include the program counter, the architecturally-visible registers, the memory mappings held in the TLB, shared units include the decoders and dispatch logic, the functional units, and the caches. SMT is essentially a way to convert TLP into ILP. However, in practice, at least for desktops, laptops, tablets, phones and small servers, it is rarely the case that several different programs are actively executing at the same time, so it usually comes down to just the one task the machine is currently being used for. Some applications, such as database systems, image and video processing, audio processing, 3D graphics rendering and scientific code, do have obvious high-level (coarse-grained) parallelism available and easy to exploit, but many of these applications which are easy to parallelize are primarily limited by memory bandwidth, not by the processor. If one thread saturates just one functional unit which the other threads need, it effectively stalls all of the other threads, even if they only need relatively little use of that unit. Competition between the threads for cache space may produce worse results than letting just one thread have all the cache space available, particularly for software where the critical working set is highly cache-size sensitive, such as hardware simulators/emulators, virtual machines and high-quality video encoding. Due to above 3 reasons, SMT performance can actually be worse than single-thread performance (traditional context switching between threads) sometimes. More cores or Wider cores Very wide superscalar designs scale very badly in terms of both chip area and clock speed, so a single 10-issue core would actually be both larger and slower than two 5-issue cores: the complex multiple-issue dispatch logic scales up as (issue width)^2 highly multi-ported register files and caches to service all those simultaneous accesses Today, a \"typical\" SMT design implies both a wide execution core and OOO execution logic, including multiple decoders, the large and complex superscalar dispatch logic and so on. For applications with lots of active but memory-latency-limited threads (database systems, 3D graphics rendering), more simple cores would be better because big/wide cores would spend most of their time waiting for memory anyway. For most applications, however, there simply are not enough threads active to make this viable, and the performance of just a single thread is much more important, so a design with fewer but bigger, wider, more brainiac cores is more appropriate. Intel's Xeon Haswell, the server version of Core i*4 Haswell, uses 5.7 billion transistors to provide 18 cores (up from 8 in Xeon Sandy Bridge), each a very aggressively brainiac 8-issue design (up from 6-issue in Sandy Bridge), each still with 2-thread SMT. IBM's POWER8 uses 4.4 billion transistors to move to a considerably more brainiac core design than POWER7, and at the same time provide 12 cores (up from 8 in POWER7), each with 8-thread SMT (up from 4 in POWER7). In the future we might see asymmetric designs, with one or two big, wide, brainiac cores plus a large number of smaller, narrower, simpler cores. IBM's Cell processor (used in the Sony PlayStation 3) was arguably the first such design, but unfortunately it suffered from severe programmability problems because the ISA incompatible between small cores and large main core and had limited by awkward access to main memory. Some modern ARM designs also use an asymmetric approach, with several large cores paired with one or a few smaller, simpler \"companion\" cores, to increase battery life. DLP (data-level parallelism) Rather than looking for ways to execute groups of instructions in parallel, the idea is to look for ways to make one instruction apply to a group of data values in parallel. SIMD Vector Instructions One of DLP methods called SIMD parallelism (single instruction, multiple data). More often, it's called vector processing. With some thought, a small set of vector instructions can enable some impressive speedups, such as packing/unpacking, byte shuffling, bit masking instructions, just like x86 Matrix Math Extensions (MMX), Streaming SIMD Extensions (SSE), and ongoing revisions of Advanced Vector Extensions (AVX). MMX provide 64-bit vectors, x86 SSE added 8 new 128-bit registers, then widened to 256 bits with AVX. Memory Memory Wall Latency is especially bad for loads from memory, which make up about a quarter of all instructions. Using a modern SDRAM with a CAS latency of 11, will typically be 24 cycles of the memory system bus, 1 to send the address to the DIMM (memory module), RAS-to-CAS delay of 11 for the row access, CAS latency of 11 for the column access, and a final 1 to send the first piece of data up to the processor (or E-cache). On a multi-processor system, even more bus cycles may be required to support cache coherency between the processors. There are the cycles within the processor itself, checking the various on-chip caches before the address even gets sent to the memory controller, accounting for 20 CPU cycles. For 2.4GHz processor and 800MHz SDRAM memory, summing up to (1+11+11+1) * 2400/800 + 20 = 92 CPU cycles, a 4.0 GHz processor would wait a staggering 140 cycles to access main memory. This problem of the large, and slowly growing, gap between the processor and main memory is called the memory wall. Caches Modern processors solve the problem of the memory wall with caches. A cache is a small but fast type of memory located on or near the processor chip. Its role is to keep faster copies of small pieces of main memory, L1 caches around 8-64K in size, L2 caches around 100K-10M in size, larger and slower L3 caches. A modern primary (L1) cache has a latency of just 2 to 4 processor cycles, with around 90% caches hit rates. The memory hierarchy of a modern desktop/laptop: Core i4 Haswell. Level Size Latency (cycles) Location L1 Cache 32KB 4 inside each core L2 Cache 256KB 12 beside each core L3 Cache 6MB ~21 shared between all cores L4 E-Cache 128MB ~58 separate eDRAM chip RAM 8+GB ~117 SDRAM DIMMs on motherboard Swap 100+GB 10000+ hard disk or SSD Cache ocality Temporal locality is exploited by merely keeping recently accessed data in the cache. To take advantage of spatial locality, data is transferred from main memory up into the cache in blocks of a few dozen bytes at a time, called a cache line. Cache Layout Using the virtual address might cause caches need to be flushed on every context switch (thrashing) (2 programs mapping a same virtual address to different physical address). Using the physical address means the V2N mapping must be performed, making every cache lookup slower. A common trick is to use virtual addresses for the cache indexing but physical addresses for the tags. The virtual-to-physical mapping (TLB lookup) can then be performed in parallel with the cache indexing so that it will be ready in time for the tag comparison. Such a scheme is called a virtually-indexed physically-tagged cache. Set-associative caches are able to avoid some unfortunate cache conflicts. Unfortunately, the more highly associative a cache is, the slower it is to access. The instruction L1 cache can afford to be highly set-associative (prefetching and buffering in pipeline), but the data L1 cache settled on 4-way set-associative as the sweet spot. The large L2/L3 cache (LLC for \"last-level cache\") is also usually highly associative, perhaps as much as 12- or 16-way. External E-cache is sometimes direct-mapped for flexibility of size and implementation. Memory Latency and Bandwidth Lower-latency designs will be better for pointer-chasing code, such as compilers and database systems. Bandwidth-oriented (adding more memory banks and making the busses wider) systems have the advantage for programs with simple, linear access patterns, such as image processing and scientific code. Latency is much harder to improve than bandwidth. Synchronously clocked DRAM (SDRAM) allowed pipelining of the memory system. This reduces effective latency because it allows a new memory access to be started before the current one has completed, while an asynchronous memory system had to wait for the transfer of half a cache line from the previous access before starting a new request. Distributed System 小型机是专门设计的硬件和专门设计的软件，只面向这种规模（例如几百颗 CPU）的计算 小型机是完全闭源的，不需要考虑扩展性，特定的几种硬件在稳定性上前进了一大步 x86 的 IO 性能被架构锁死了，各种总线、PCI、PCIe、USB、SATA、以太网，为了个人计算机的便利性，牺牲了很多的性能和可靠性 小型机使用总线通信，可以实现极高的信息传递效率，极其有效的监控以及极高的故障隔离速度 x86 服务器基于网络的分布式具有天然的缺陷: 操作系统决定了网络性能不足 网络需要使用事件驱动处理，比总线电路的延迟高几个数量级 PC 机的硬件不够可靠，故障率高 很难有效监控，隔离故障速度慢 Reference Modern Microprocessors – A 90-Minute Guide. Jason R. C. Patterson. Technical paper, Lighterra, May 2015 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/architecture/graphProcessingNotes.html":{"url":"computerScience/architecture/graphProcessingNotes.html","title":"Graph Processing Notes","keywords":"","body":"Graph Processing Notes Graph Processing Notes Graph System NUMA Architecture CPU Schedule Memory Schedule Dataset Tools Concurrency Lib Perf Tools Hardware Performance Counter Parallel Programming Other Libs DRAMSim2 GCC strict-alias warnings Time Stamp Counter RDTSC clock_gettime NUMA Tool numactl installation usage numastat Graph System 分类 In-memory Out-of-core Single machine Ligra GraphChi Polymer X-Stream Galois GridGraph Mosaic Distributed Pregel Chaos PowerGraph PowerLyra Gemini NUMA Architecture 引入了 node 和 distance: 对于 CPU 和 Memory 这两种最宝贵的硬件资源, NUMA 用近乎严格的方式划分了所属的资源组 (node), 而每个资源组内的 CPU 和 Memory 几乎相等 资源组的数量取决于物理 CPU 的个数 distance 用来定义各个node之间调用资源的开销, 为资源调度优化算法提供数据支持 每个进程(或线程)都会从父进程继承NUMA策略, 并分配有一个优先node. 如果NUMA策略允许的话，进程可以调用其他node上的资源. CPU Schedule cpunodebind: 规定进程运行在某几个 node 之上 physcpubind: 精细地规定进程运行在哪些核上 Memory Schedule localalloc: 从当前node上请求分配内存 preferred: 比较宽松地指定了一个推荐的 node 来获取内存, 如果被推荐的 node 上没有足够内存, 进程可以尝试别的 node membind: 可以指定若干个 node,进 程只能从这些指定的 node 上请求分配内存 interleave: 规定进程从指定的若干个 node 上以 RR (Round Robin) 交织地请求分配内存 NUMA 默认的内存分配策略是优先在进程所在 CPU 的本地内存中分配, 会导致 CPU 节点之间内存分配不均衡. 当某个 CPU 节点的内存不足时, 会导致 swap 产生, 而不是从远程节点分配内存, 这就是 swap insanity 现象 Dataset LiveJournal social network twitter rv us road Tools Concurrency Lib Taskflow Perf Tools Flame Graph Hardware Performance Counter Intel PCM PAPI Parallel Programming OpenMP Other Libs Lib BLAS DRAMSim2 Overview of DRAMSim2’s Memory Structure GCC strict-alias warnings for strict-aliasing warnings: use a union to represent the memory need to reinterpret use a reinterpret_cast, cast via char * at the point where reinterpret the memory - char * are defined as being able to alias anything use a type which has __attribute__((__may_alias__)) turn off the aliasing assumptions globally using -fno-strict-aliasing Time Stamp Counter definition RDTSC clock_gettime gcc *.c -o *.o ... -lrt # link with librt #include struct timespec ts; clock_gettime(CLOCK_MONOTONIC, ts); printf(\"%d %d\", ts.tv_sec, ts.tv_nsec); NUMA Tool grep -i numa /var/log/dmesg numactl installation sudo apt install -y numactl usage numactl --show numactl --hardware numactl --interlave=all numastat numastat © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/compilers/compilersBasicNotes.html":{"url":"computerScience/compilers/compilersBasicNotes.html","title":"Compilers Basic Notes","keywords":"","body":"Compiler Basic Notes Compiler Basic Notes Basic Concepts Defination of compilers Structure of compilers 文法与语言 符号与符号串 文法与语言的形式化表示 乔姆斯基文法体系 上下文无关文法 文法表示 形式化表示 简易表示 巴科斯范式(Backus-Naur Form) 正规文法 正则语言(Regular Expressions) 基本定义 形式表示 正则语法糖(Syntax Sugar) 分析树 推导类型 句型分析 meaning function(多对一) 二义性文法(一对多) 文法重写 优先级与结合性 文法规则 Lexical Analysis Tokenizer - 词法分析器 转移图算法 关键字(keyword)处理 有限状态自动机(Finite Automaton) 确定有限状态自动机(Deterministic Finite Automaton) 状态转移表实现 DFA 非确定有限状态自动机(Nondeterministic Finite Automaton) 自动词法分析器 Thompson 算法: RegExp --> NFA 子集构造算法: NFA --> DFA Hopcroft 算法 实现 DFA 有向图 转移表 Syntax Analysis(语法分析) 自顶向下分析 避免回溯 递归下降分析算法(Recursive Descent/预测分析算法) 算法实现 LL(1)分析算法 nullable sets first sets follow sets select sets 分析表 解决冲突(分析表某项有多个编号) 消除直接左递归 消除间接左递归 非 LL(1) 文法/语言 自底向上分析 LR(0) 分析算法(移进-归约(reduce)算法) 短语(Handles) 分析表构造 驱动代码 解决冲突(SLR/LR(1)/LALR) LALR(k) SLR SLR 实现 抽象语法树 语法制导翻译(Syntax-Directed Translation) 抽象语法 AST 的实现 数据结构 相关算法 构造算法 Semantic Analysis(语义分析) 类型系统(type system) Type Checking Type Environments Typing Methods 符号表(上下文相关) 类型检查 作用域检查 类型相容性 错误诊断 Immediate Representation(IR) 三地址码 控制流图 Block 数据流分析与程序重写 数据分析方法 到达定义分析 活性分析 代码优化 组织管理 Activation Record(AR) / Frame 全局变量 堆区 优化类型 局部优化 全局优化 Dead Code Elimination Constant Propagation Liveness Analysis 寄存器分配(Register Allocation/Graph Coloring) Code Generation(代码生成) 递归下降代码生成算法 基于栈计算机 基于寄存器计算机 (RISC) Garbage Collection Mark and Sweep Stop and Copy Compilers Exercise C Declaration Interpreter Cool(Classrom Object-Oriented Language) Parser Implemention Basic Concepts Defination of compilers program_code ---compiler---> executable data ---executable---> output e.g Fortran(formula translation) 1 project Structure of compilers front-end to back-end: front-end: src ---lexical analysis---> tokens ---parsing/syntax analysis---> AST(Abstract Syntax Tree) ---semantic analysis---> intermediate back-end: intermediate ---...---> ... ---...---> ... ---code generation---> dist details: lexical analysis(词法分析) parsing/syntax analysis(语法分析) semantic analysis(语义分析): type and scope optimization code generation: translate to other high level language/assembly code/machine code 文法与语言 符号与符号串 字母表/符号集: 元素的非空有穷集合 符号串: 字母表中的符号组成的任何有穷序列 固有头/尾: 非空首/尾子串 闭包: Σ* = Σ0 U Σ1 U ... U Σn ... 正闭包: Σ* = Σ1 U ... U Σn ... 文法与语言的形式化表示 文法(Grammar) G = (Vn, Vt, P, S) - 非终结符集, 终结符集, 规则/产生式集, 开始符号 语言(Language) L(G) = {x | S -> x, x } 文法 G 一切句子的集合 句型: rhs of P, 句子: 不含非终结符的右部 直接推导: v -> w, 闭包推导: v -*> w, 正闭包推导: v -+> w 乔姆斯基文法体系 ((((3)2)1)0) 0 型文法: 任意文法 1 型文法: 上下文有关文法(context sensitive) αAβ -> αηβ 2 型文法(语法工具): 上下文无关文法 A -> α 3 型文法(词法工具): 正规文法 上下文无关文法 文法表示 G = (S, N, T, P): S: 开始符 N: 非终结符集合 T: 终结符集合 P: 产生式规则集合 X -> beta1, beta2, ..., betan, X 形式化表示 简易表示 Sentence -> Noun Verb Noun Noun -> sheep | tiger | grass | water Verb -> eat | drink S: Sentence, N: Sentence/Verb/Noun, T: sheep/tiger/grass/water/eat/drink E -> num |id |E + E |E `*` E S: E, N: E, T: num/id/+/* 巴科斯范式(Backus-Naur Form) ::= : \"被定义为\" \"word\" : 字符本身 双引号外的字 : 语法部分 尖括号( ) : 必选项(非终结符) 方括号( [ ] ) : 0/1 大括号( { } ) : 0/n 竖线( | ) : \"OR\" 正规文法 正规文法可与正则语言相互转化: A -> aB|Ba A -> a 正则语言(Regular Expressions) 基本定义 对于给定的字符集 C: 空串 \"\\0\" 是正则表达式 任意 char 若 M, N 是正则表达式, 则 M|N = {M, N}, MN = {mn|m 形式表示 // 具有顺序性 e -> \"\\0\" // basic defination | c // basic defination | e | e // recursive defination | ee // recursive defination | e* // recursive defination 正则语法糖(Syntax Sugar) [a-z] : a|...|z c? : 0/1 个 c c+ : 1/n 个 c c{i, j} : i-j 个 c \"a\" : a 自身(非 kleen 闭包) . : 除 ‘\\n’ 外的任意字符 // 标识符 [a-zA-Z\\_][a-zA-Z\\_0-9]* // decimal integer (+|-)?(0|[1-9][0-9]*) // decimal float (+|-)?(0|[1-9][0-9]*|)?\\.[0-9]+ 分析树 进行文法推导时生成的树: 根 : 开始符 内部结点 : 非终结符 叶子结点 : 终结符 层 : 一步推导(优先级影响推导顺序) 叶子结点串: 最终表达式 后序遍历 : 最终结果 推导类型 最左推导(leftmost) 最右推导(rightmost)(规范推导) 句型分析 短语: 若 S -*> Aβ, A -+> α, 则称 α 是句型 αβ 相对于非终结符 A 的短语 直接短语: S -*> Aβ, A -> α 一个右句型的直接短语称为该句型的句柄(用于自下而上的归约分析) 最左归约: 归约最左的句柄, 最右归约: 归约最右的句柄 meaning function(多对一) L(syntax) = semantic: 多个语法对应一个语义(不同形式的表达式对应同一个意思) 二义性文法(一对多) 最左推导与最右推导得出的分析树不一致 若给定文法 G, 对于句子 s, 其有 2 种不同的分析树, 则称 G 是二义性文法 若一个上下文无关语言的所有文法都是二义性文法, 则称此语言是先天二义语言 文法重写 E -> E + T |T T -> T * F |F F -> num |id 消除 + 与 * 的二义性, 如 3+4*5 优先级与结合性 声明优先级与结合性可在一定程度上消除文法的二义性 文法规则 有害规则: 使文法产生二义性的规则 多余规则: 不可达/不可终止的规则 2 型文法的 ε 规则: 当语言中不含有 ε 符号串, 则一定存在终结符集不含有 ε 的等价文法(代入法消除 ε) 保证非终结符 A 的有效性: S -*> αAβ, A -+> t Lexical Analysis Tokenizer - 词法分析器 Maximal match Higher priority match 转移图算法 token nextToken(void) { char c = getChar(); switch(c) { case '': return NE; default: rollback(); return LT; } case '=': return EQ; case '>': c = getChar(); switch (c) { case '=': return GE; case ' 关键字(keyword)处理 根据 完美哈希算法(无冲突哈希函数) , 建立所有关键字对应的关键字完美哈希表 读入有效标识符(字符串型)后, 查询关键字哈希表, 检查当前标识符是否为关键字 #define KEYWORD_MAXLEN 10 hash_one(char *str, int len) { unsigned int keyValue = 0; for (int i = 0; i #define KEYWORD_HASH_SEED 131 hash_two(char *str, int len) { unsigned int keyValue = 0, hash = 0; for (int i = 0; i 有限状态自动机(Finite Automaton) 确定有限状态自动机(Deterministic Finite Automaton) Only a transition for a state with a input No epsilon moves M = (AlphaSet/InputSet, StateSet, currentState, FiniteStateSet, transferFunction) A = {a, b}, SS = {0, 1, 2}, cS = 0, FS = {2}, transferFunction = { (cS0, a) -> cS1, (cS0, b) -> cS0, (cS1, a) -> cS2, (cS1, b) -> cS1, (cS2, a) -> cS2, (cS2, b) -> cS2, } 状态转移表实现 DFA 状态\\字符 a b 0 1 0 1 2 1 2 2 2 非确定有限状态自动机(Nondeterministic Finite Automaton) transferFunction 中的次态不确定/不唯一(为一个开集合): Multiple transitions for a state with a input can epsilon moves (cS0, a) -> {cS1, cS2} 自动词法分析器 RegExp --Thompson 算法--> NFA --子集构造算法--> DFA --Hopcroft 最小化算法--> 词法分析器代码 Thompson 算法: RegExp --> NFA 直接构造基本 RegExp 递归构造复合 RegExp epsilon : i --epsilon--> f RegExp : i --NFA(RegExp)--> f 选择 : i --NFA(RegExp1)--> f, i --NFA(RegExp2)--> f 连接 : i --NFA(RegExp1)--> m --NFA(RegExp2)--> f 闭包 : i --epsilon--> m --epsilon--> f, m --RegExp--> m 子集构造算法: NFA --> DFA 由 Thompson 算法生成的 NFA, 当且仅当输入为 epsilon 时, 次态不唯一 将所有可达到次态作为一个集合 s, 视为单一次态 s delta(Sigma) + epsilon-closure(深度/广度优先遍历找寻可达到次态边界) DFA subset_construction(NFA nfa) { s0 = eps_closure(n0); StateSet += s0; enqueue(s0); while (workqueue != []) { dequeue(s); foreach (ch in InputSet) { next_state = eps_closure(delta(s, ch)); Fn[s, ch] = next_state; // DFA 中的转移函数 if (next_state not in StateSet) { StateSet += next_state; enqueue(next_state); } } } return DFA(StateSet, Fn); } Hopcroft 算法 最小化 DFA(数字逻辑中的最简状态表), 合并等价状态(等价类) split(StateSet S) { foreach (char ch) { if (ch can split S) { split S into S1, ..., Sk; } } } hopcroft(DFA) { split all nodes into InitStateSet and FiniteStateSet (Two State Sets); while (set is still changes) { split(S); } } 实现 DFA 有向图 转移表 行: 现态 列: 输入 值: 次态/ERROR/-1 驱动代码: table 用于实现 switch/case, stack 用于实现最长匹配 next_token() { state = 0; stack = []; while (state != ERROR) { c = getChar(); if (state is ACCEPT/FINITE) { clear(stack); } push(state); state = table[state][c]; } while (state is not ACCEPT/FINITE) { state = pop(); rollback(); } } Syntax Analysis(语法分析) Tokens + Grammar --Syntax Analysis--> AST(Abstract Syntax Tree) 自顶向下分析 从开始符号出发推导任意句子 t, 与给定句子 s 进行比较分析 利用分析树进行逐叶子匹配, 若匹配失败则进行回溯 bool top_down_parsing(tokens[]) { i = 0; stack = [S]; while (stack != []) { if (stack[top] is a terminal t) { t == tokens[i] ? pop(i++) : backtrack(); } else if (stack[top] is a nonterminal T) { pop(); push(T next expansion); // 自右向左压栈, e.g pop(S), push(N_right), push(V), push(N_left) } else { throw new SyntaxError(); } } return i >= tokens.length && is_empty(stack) ? true : false; } 避免回溯 利用前看符号避免回溯 Sentence -> Noun Verb Noun Noun -> sheep | tiger | grass | water Verb -> eat | drink tiger eat water: 向前看非终结符推导出的所有终结符中匹配 tiger 的终结符; 不向前看,则先推导 N, 再推导 n, 但 n 不一定匹配 tiger, 则需进行回溯; 向前看一个字符, 直接推导 N --> n, 同时直接找寻匹配 tiger 的终结符 S -> N V N N -> (sheep)tiger V -> eat N -> (sheep-tiger-grass)water 递归下降分析算法(Recursive Descent/预测分析算法) 分治算法: 每个非终结符构造一个分析函数 前看符号: 用前看符号指导产生式规则的选择(expansion) parse_S(tokens[]) { parse_N(tokens[0]); parse_V(tokens[1]); parse_N(tokens[2]); } parse_N(token) { if (token == s|t|g|w) { return true; } else { throw new SyntaxError(); } } parse_V(token) { if (token == e|d) { return true; } else { throw new SyntaxError(); } } 算法实现 tip one: use save pointer to implement roll back tip two: use logical OR expression to replace nested if-else structure bool term(TOKEN tok) { return *next++ == tok; } bool E1(void) { return T(); } bool E2(void) { return T() && term(PLUS) && E(); } bool E(void) { // roll back pointer TOKEN *save = next; return (next = save, E1()) || (next = save, E2()); } bool T1(void) { return term(INT); } bool T2(void) { return term(INT) && term(TIMES) && T(); } bool T3(void) { return term(OPEN) && E() && term(CLOSE); } bool T(void) { // roll back pointer TOKEN *save = next; return (next = save, T1()) || (next = save, T2()) || (next = save, T3()); } // X -> a // | XX // | aXXX // | aXXXXb parse_X() { token = nextToken(); switch (token) { case ...: // i: token == atom_char or parse_XX(); case ...: // j: token == atom_char, token = nextToken(), parse_XXX(); // k: token == atom_char, token = nextToken(), // parse_XXXX(), token=nextToken(), token == b case ...: default: throw new SyntaxError(); } } LL(1)分析算法 从左(L)向右读入程序(left to right scan) 最左(L)推导: 优先推导最左侧非终结符(leftmost derivation) 一个(1)前看符号(look ahead) 分治算法: 每个非终结符构造一个first set 和一个 follow set, 最后为每个规则构造一个 select set 分析表驱动(由 first sets/follow sets/select sets 推导分析表) bool ll1_parsing(tokens[]) { i = 0; stack = [S]; while (stack != []) { if (stack[top] is a terminal t) { t == tokens[i] ? pop(i++) : throw new SyntaxError(); } else if (stack[top] is a nonterminal T) { pop(); // push(T correct expansion); // 自右向左压栈, e.g pop(S), push(N_right), push(V), push(N_left) push(select_table[T][tokens[i]] 对应项(规则编号)所对应规则的右边式子); } else { throw new SyntaxError(); } } return i >= tokens.length && is_empty(stack) ? true : false; } nullable sets 存在规则: X -> epsilon 或者 : X -> Y1Y2...Yn, 且存在规则 Y1 -> epsilon, ..., Yn -> epsilon 即 : X -*> epsilon (epsilon nullable = {}; while (nullable is still changing) { foreach (production p: X -> beta) { if ((beta == epsilon) || (beta == Y1...Yn && Y1 first sets first(X) = {t | X -> talpha} U {epsilon | X->epsilon} : first(t) = {t} epsilon epsilon or X -> A1...An, epsilon first(alpha) A1..Analpha, epsilon first sets 不动点算法: foreach (nonterminal N) { first(N) = {}; } while (some sets is changing) { foreach (production p: N->beta1...betan) { foreach (betai from beta1 upto betan) { if (betai == a) { // e.g N->abX: first(N) += {a} first(N) += {a}; break; } else if (betai == M) { first(N) += first(M); if (M is not in nullable) { break; } // else continue this loop to add first(beta_next) into first(N) } } } } Nonterminal First Set S {s, t, g, w} N {s, t, g, w} V {e, d} follow sets follow(X) = {t | S -*> beta X t epsilon} : for X -> AB: first(B) if B -*> epsilon: follow(X) A -> alpha X beta: first(beta) - {epsilon} $ follow sets 不动点算法: foreach (nonterminal N) { follow(N) = {}; } while (some sets is changing) { foreach (production p: N->beta1...betan) { // temp: follow(left) select sets 当 N -> Y1...Yn 右边 Y 全为 nullable 时, select(p) += follow(N) select sets 不动点算法: foreach (production p) { select(p) = {} } calculate_select_set(production p: N->beta1...betan) { foreach (betai from beta1 upto betan) { if (betai == a) { select(p) += {a}; break; } else if (betai == M) { select(p) += first(M); if (M is not in nullable) { break; } } } // all betas are in nullable (当前规则的所有右边符号都是可空集) //　故, select(p) 必须包括 follow(M) (当推导出右边符号都为空时, first(p) 即为 follow(M)) if (i > n) { first(N) += follow(N); } } 分析表 结合 nullable sets 准确求出 first sets 再利用 first sets 准确求出 follow sets 再利用 first sets, 并结合 follow sets(全空集修正) 准确求出 分析表: 0: z -> d 1: | X Y Z 2: Y -> c 3: | 4: X -> Y 5: | a nullable = {X, Y} X Y Z first {a, c} {c} {a, c, d} follow {a, c, d} {a, c, d} {} production 0 1 2 3 4 5 select {d} {a, c, d} {c} {a, c, d} {a, c, d} {a} |Non\\Terminal|a|c|d| |Z|1|1|0, 1| |Y|3|2, 3|3| |X|4, 5|4|4| 数字为规则编号 解决冲突(分析表某项有多个编号) 通过文法重写消除左递归, 使文法适应 L(最左推导): 改写成右递归文法 规定优先级与结合性 提取左公因式(Common Prefix) E -> T+E |T E -> TX X -> +E |epsilon 消除直接左递归 S -> Salpha1 |Salpha2 ... |Salphan |beta1 |beta2 ... |betam S -> beta1S' |beta2S' ... |betanS' S'-> alpha1S' |alpha2S' ... |alphanS' |epsilon 消除间接左递归 把文法 G 的所有非终结符按任一顺序排列, e.g A1, A2, …, An 消除 Ai 规则中的直接左递归: 把形如 Ai→Ajγ 的产生式 改写成 Ai→δ1γ /δ2γ /…/δkγ(其中 Aj→δ1 /δ2 /…/δk 是关于的 Aj 全部规则) 去掉多余的规则(不可达规则) #include #include #include using namespace std; struct WF { string left; //定义产生式的左部 string right; //定义产生式的右部 }; /* * count: number of non-terminal symbols */ void Removing(WF *p,char *q,int n,int count) { int count1 = n; int flag = 0; // 判断第一个非终结符是否存在直接左递归 if(p[i].left[0]==q[0]) for (int i = 0; i E+T => E'->+TE' string temp = p[i].left; string temp1 = \"'\"; p[i].left = temp+temp1; p[i].right = str+p[i].left; } else { // E->T => E->TE' string temp=p[i].left; string temp1=\"'\"; temp=temp+temp1; p[i].right=p[i].right+temp; } } } string str=\"'\"; p[count1].left=p[0].left[0]+str; p[count1].right=\"ε\"; } // 对每一个非终结符迭代 for ( int i = 0; i >n; WF *p=new WF[50]; cout>p[i].left; cout\">p[i].right; cout\"\"\"\"\"\" 非 LL(1) 文法/语言 ambiguous grammar left recursive grammar not left factored grammar(未提取展开式的公因子) 自底向上分析 0: S -> E 1: E -> E + T 2: | T 3: T -> T * F 4: | F 5: F -> n 2 + 3 * 4 => F + 3 * 4 => T + 3 * 4 => E + 3 * 4 => E + T * 4 => E + T * F => E + T => E => S 最右推导(优先推导最右侧非终结符)逆过程 LR(0) 分析算法(移进-归约(reduce)算法) 从左向右读入程序(left to right scan), 逆向最右推导(rightmost derivation), 不用前看符号 添加伪开始符号: S' -> . S$ $表示 tokens/file 结束符 移进 : 读入记号 push(token[i]) 归约(reduce): pop(right expansion) push(left expansion) 短语(Handles) S -*> αXω -> αβω β 是 αβω 的一个短语(Handle) 分析表构造 LR(0) 分析表构造算法: (原理同于 Hopcroft 算法) E -> A, A -> B, B -> C ... : Recursively, right hand side of C production will be reduced to E finally closure(production_set p) { while (p is still changing) { foreach (p's item i: A -> b . B ...) { p += {B -> . y...} } } } goto(production_set p, token x) { temp = {} foreach (p's item i: A -> b . x...) { temp += {A -> bx . ...} } return closure(temp) } p0 = closure(S'' -> . S $) (production_with_dot_)set = {p0} Q = enqueue(p0) while (Q is not empty) { p = dequeue(Q) foreach (x 驱动代码 LR(0) 驱动算法: stack[]; push($) push(state1) while (true) { token t = nextToken() state s = stack[top] if (ACTION[s, t] == shifti) { push(t) push(statei) } else if (ACTION[s, t] == reducej) { // X is the left side of production j: X->beta // beta is the right side of production j: X->beta // pop up right side pop(beta && bundle state variables) // current state after pop up all bundle state(of beta) state s = stack[top] // push left side push(X) // transfer state after reduce push(GOTO[s, X]) } else { throw new SyntaxError(); } } 解决冲突(SLR/LR(1)/LALR) 采取与 first/follow/select sets 以及 前看符号 类似策略: production_with_dot_set 中的 item 修改为 X -> [beta1 . betan..., a] 二元组 closure(production_set p) 中闭包规则从 X -> [a . Y beta,a] 修改为 Y -> [.y, b] b LALR(k) SLR Simple LR: improves LR(k) shift/reduce heuristic New reduce rule: state contains item X -> β. next_token SLR 实现 stack pair: state i: if has item X -> α.aβ , goto[i, a] = j then action[i, a] = shift j(shift then to state j) state i: if has item X -> α. , a then action[i, a] = reduce(X -> α) state i: if has item S' -> S then action[i, $] = accept otherwise: action[i, a] = error 抽象语法树 语法制导翻译(Syntax-Directed Translation) 在进行归约(reduce)的同时, 进行语义动作: 给每条产生规则附加一个语义动作 exp : exp '+' exp { $$ = $1 + $3; } ; 在分析栈中压入 symbol, value, state (原本只压入 symbol, state) push(right side symbol); push(right side value); push(next state); 抽象语法 表达语法结构的内部表示, 作为前端(词法语法分析)和后端(代码生成)的中间件, tokens --语法分析器--> 抽象语法(树) --代码生成器--> 目标代码 抽象语法无需考虑左/右递归, 左公因子提取, 分隔符等 // 具体语法 E: E + T | T ; T: T * F | F ; F: n | (E) ; // 抽象语法 E: n | E + E | E * E AST 的实现 数据结构 E: n | E + E | E * E enum kind { E_INT, E_ADD, E_TIMES }; struct exp { enum kind kind; }; struct exp_int { enum kind kind; int value; }; struct exp_add { enum kind kind; struct exp *left; struct exp *right; }; struct exp_times { enum kind kind; struct exp *left; struct exp *right; }; struct exp_int *new_exp_int(int value) { struct exp_int *p = (struct exp_int *)malloc(sizeof(struct exp_int)); if (!p) throw new Error(); p->kind = E_INT; p->value = value; return p; } struct exp_add *new_exp_add(exp *left, exp *right) { struct exp_add *p = (struct exp_add *)malloc(sizeof(struct exp_add)); if (!p) throw new Error(); p->kind = E_ADD; p->left = left; p->right = right; return p; } struct exp_times *new_exp_times(exp *left, exp *right) { struct exp_tiems *p = (struct exp_times *)malloc(sizeof(struct exp_times)); if (!p) throw new Error(); p->kind = E_TIMES; p->left = left; p->right = right; return p; } 相关算法 int nodes_num(exp *e) { switch (e->kind) { case E_INT: return 1; case E_ADD: // fall through case E_TIMES: return 1 + nodes_num(e->left) + nodes_num(e->right); default: throw new SyntaxError(\"compile bug\"); } } int pretty_print(exp *e) { switch (e->kind) { case E_INT: printf(\"%d\", e->value); return 1; case E_ADD: printf(\"(\"); pretty_print(e->left); printf(\")\"); printf(\"+\"); printf(\"(\"); pretty_print(e->right); printf(\")\"); return 1; case E_TIMES: printf(\"(\"); pretty_print(e->left); printf(\")\"); printf(\"*\"); printf(\"(\"); pretty_print(e->right); printf(\")\"); return 1; default: throw new SyntaxError(); break; } } 构造算法 利用语法制导翻译, 在语法动作(action)/语法归约(reduce)中加入生成语法树的代码(自底(叶子)向上(根)构造函数) E: E + E { $$ = new_exp_add($1, $3); } | E * E { $$ = new_exp_times($1, $3); } | n { $$ = new_exp_int($1); } ; Semantic Analysis(语义分析) 声明检查(identifiers declaration) 定义检查: class 仅可定义一次 method 在同一 class 中仅可定义一次 类型检查(types) 作用域检查 继承关系(inheritance relationships) 上下文相关分析(检查抽象语法树上下文相关的属性) AST + semantic of programming language --semantic analysis--> intermediate e.g 变量/函数必须先声明再使用; 每个表达式必须有合适类型(左值/右值); 函数调用与函数定义保持一致(函数签名) P: D S ; D: T id ';' D | ; T: int | bool ; S: id = E | printi (E) | printb (E) ; E: n | id | true | false | E + E | E && E ; 类型系统(type system) Type Checking ├ e: T meas e 可计算为类型为 T 的值 Type Environments Object(identifier) = Type O Type environments 是一个函数, 将 object identifiers 映射成 types O ├ e: T 表示在 O 函数作用下, 可证明 e 的类型为 T // input x // output T O[T/x](x) = T O[T/x](y) = O(y) [Var] O(x) = T ---------- O ├ x: T [Let without Init] O[T0/x] ├ e1: T1 -------------------- O ├ let x: T0 in e1: T1 Typing Methods Method(ClassName, functionName) = (Type1, ..., Typen, Typen+1) Typen+1 为返回值的类型, 即方法自身的类型 [Dispatch] O,M ├ e0: T0 O,M ├ e1: T1 ... O,M ├ en: Tn M(T0, func) = (T1', ..., Tn', Tn+1') Ti 符号表(上下文相关) 用来存储程序中变量的相关信息: 类型: 字典结构 (key, type) 作用域: 进入作用域, 插入元素(插入哈希表首, 屏蔽外部同名变量); 离开作用域, 删除元素 进入作用域, 压入新符号表; 离开作用域, 弹出栈顶符号表 访问控制权 命名空间: 变量, 标签, 形参, 标号 各自拥有一类符号表 可将符号表实现为: 哈希表: 查找时间复杂度 O(1); 红黑树: 查找时间复杂度 O(lg N); #ifndef XX_SEMANTIC_TABLE_H #define XX_SEMANTIC_TABLE_H typedef enum type type_t; typedef char * key_t; // typedef int hash_t; typedef hash_t key_t; typedef struct value { type_t type; scope_t scope; } value_t; typedef ... table_t;// 符号表数据结构 table_t new_table(void); int table_insert(table_t table, key_t id, value_t info); value_t table_search(table_t table, key_t id); #endif 类型检查 table: 字典结构 (key, type) (Hash Table/Red Black Tree) type environment(Object, Methods, Class) is passed from parent to child(down the tree) types are passed from child to parent(up the tree) TypeCheck(Environment/OMC, e1+e2) = { T1 = TypeCheck(OMC, e1); T2 = TypeCheck(OMC, e2); Check T1 == T2 == Int; return Int; } TypeCheck(OMC, let x: T enum type {INT, BOOL}; table_t table;// symbol table // dec_t, stm_t, exp_t: AST 中的结点 enum type check_prog(dec_t d, stm_t s) { // 生成符号表 table = check_dec(d); // 根据符号表检查语句 return check_stm(s); } // 生成符号表 table_t check_dec(dec_t d){ foreach(T id kind) { case STM_ASSIGN: t1 = table_search(table, id); t2 = check_exp(table, s->exp); if (t1 != t2) { throw new SemanticError(\"type mismatch\"); } else { return t1; } case STM_PRINTI: t = check_exp(s->exp); if (t != INT) { throw new SemanticError(\"type mismatch\"); } else { return INT; } case STM_PRINTB: t = check_exp(s->exp); if (t != BOOL) { throw new SemanticError(\"type mismatch\"); } else { return BOOL; } } } enum type check_exp(exp_t e) { switch (e->kind) { case EXP_INT: return INT; case EXP_ID: t = table_search(table, id);// 查询符号表, 得到变量类型 if (id not exist) { throw new SemanticError(\"id not found\"); } else { return t; } case EXP_TRUE: return BOOL; case EXP_FALSE: return BOOL; case EXP_ADD: enum type t1 = check_exp_type(e->left); enum type t2 = check_exp_type(e->right); if (t1 != INT || t2 != INT) { throw new SemanticError(); break; } else { return INT; } case EXP_AND: enum type t1 = check_exp_type(e->left); enum type t2 = check_exp_type(e->right); if (t1 != BOOL || t2 != BOOL) { throw new SemanticError(); break; } else { return BOOL; } default: throw new SemanticError(); break; } } 作用域检查 table: 进入作用域, 插入元素(插入哈希表首, 屏蔽外部同名变量); 离开作用域, 删除元素 进入作用域, 压入新符号表; 离开作用域, 弹出栈顶符号表 类型相容性 名字不同但结构相同的类型是否相等 面向对象的继承类: is-a 关系 Parent parent = child; 错误诊断 准确的错误信息: 出错位置等 大量的错误信息 一定的自纠功能 Immediate Representation(IR) 树与有向无环图(DAG) 三地址码(3-address code) 控制流图(CFG) 静态单赋值形式(SSA) 连续传递风格(CPS) 三地址码 原子表达式 简单控制流 cjmp/jmp 抽象的机器代码(伪代码) 控制流图 Block block_t: { label_t; stm_list; jmp_t; } 扫描三地址码, 生成 blocks 图论算法:结点为 blocks, 边为跳转边 死基本块删除优化：删除遍历不到的语句块 数据流分析与程序重写 根据数据流分析得到的信息, 对三地址码/控制流图进行重写 后端的每一个阶段都可进行数据流分析 常量传播优化: 将赋值语句右端变量直接替换为常量, 减少访存 数据分析方法 到达定义分析 分析变量的哪些定义点可以到达变量的使用点处, 若可达定义唯一则可进行常量传播优化: in set = prior out set out set = self set + in set - kill set(重复定义点) 活性分析 寄存器分配优化 活跃区间不相交的变量可共用一个寄存器 并行优化 使用区间并行的计算可并行执行 代码优化 组织管理 Activation Record(AR) / Frame 用于管理过程活性(procedure activation)的信息: result: 置于记录的顶层, 便于访问此结果 argument return address control link: 指向调用者(上级) 全局变量 不存于 AR 中, 存于静态数据段 堆区 new/malloc 得到的变量/对象不存于 AR 中, 存于堆区 优化类型 Local optimizations Global optimizations Inter-procedural optimizations 局部优化 常量折叠优化: 所有代入常量的地方全部代入常量 1 + 2 => 3 代数化简优化: a=1*b => a=b 2*a=>a (all tips from csapp) 复制传播(copy propagation)优化: 利用前面计算出来的结果, 直接替换后面所有出现在右边的已计算左式(寄存器) 全局优化 Dead Code Elimination CFG 中(控制流分析) 死代码块删除优化 Constant Propagation CFG 中(数据流分析-可达定义分析) 常量传播(constant propagation)优化: forwards analysis C(stm, x, in) = value of x before stm ; C(stm, x, out) = value of x after stm bottom C(stm, x, in) = least_upper_bound{ C(prev_stmi, x, out) }: C(prev_stm, x, out) = top(nondeterministic) => C(stm, x, in) = top C(prev_stm1, x, out) != C(prev_stm2, x, out) => C(stm, x, in) = top C(prev_stami, x, out) = c/bottom(dead code) => C(stm, x, in) = c C(stm, x, in) = bottom => C(stm, x, out) = bottom C(x := c, x, out) = c C(x := f(), x, out) = top init: set entry to C = top, set anywhere else to C = bottom Liveness Analysis CFG 中 数据流分析-活性分析(liveness analysis), 可用于复制传播优化与寄存器分配优化: backwards analysis L(stm, x, out) = V { L(next_stm, x, in)} L(... := f(x), x, in) = true L(x := e, x, in) = false L(none x, x, in) = L(none x, x, out) init: L(...) = false 寄存器分配(Register Allocation/Graph Coloring) 当 t1 与 t2 同时具有活性时, 不可共享寄存器; 反之, t1 与 t2 不同时具有活性, 可以共享寄存器 当 t1 与 t2 同时具有活性时, 添加一条边连接 t1 与 t2, 构建 register interference graph(RIG) colors number = registers number, k-colorable problem Code Generation(代码生成) 为数据分配计算资源: 数据: 全局变量, 局部变量, 动态分配变量 资源: 寄存器(register), 数据区(.data, .bss), 代码区(.code), 栈区(runtime stack), 堆区(user heap) 当前局部变量应该放在寄存器还是内存区? 为代码选择计算指令(等价性): 代码: 表达式/语句/函数代码 指令: 算术/比较/跳转/调用/返回指令 P: D S ; D: T id ';' D | ; T: int | bool ; S: id = E | printi (E) | printb (E) ; E: n | id | true | false | E + E | E && E ; 递归下降代码生成算法 基于栈计算机 Mem + Stack + ALU JVM(Java Virtual Machine) s: push NUM | load x | store x | add | sub | times | div ; gen_prog(dec_t d, stm_t s) { gen_dec(d); gen_stm(s); } gen_dec(T id; D) { // stack_code(\".int id\") gen_type(T); emit(\" id\"); gen_dec(D); } gen_type(type_t t) { switch(t-kind) { case INT:// fall through case BOOL: emit(\".int\"); break; } } gen_stm(stm_t s) { switch (s->kind) { STM_ASSIGN: gen_exp(s->exp); emit(\"store s->id\"); break; STM_PRINTI: gen_exp(s->exp); emit(\"printi\"); break; STM_PRINTB: gen_exp(s->exp); emit(\"printb\"); break; } } gen_exp(exp_t e) { switch (e->kind) { case EXP_INT: emit(\"push e->value\");// n break; case EXP_ID: emit(\"load e->value\");// id break; case EXP_BOOL: emit(\"push e->value\");// 1/0 break; case EXP_ADD: gen_exp(e->left); gen_exp(e->right); emit(\"add\"); break; case EXP_AND: gen_exp(e->left); gen_exp(e->right); emit(\"and\"); break; } } 基于寄存器计算机 (RISC) Mem + Reg + ALU MIPS ISA // src -> dist s: movn n, r | mov r1, r2 | load [x], r | store r, [x] | add r1, r2, r3 | sub r1, r2, r3 | times r1, r2, r3 | div r1, r2, r3 void gen_prog(dec_t d, stm_t s) { gen_dec(d); gen_stm(s); } void gen_dec(T id; D) { // reg_code(\".int id\") // 为变量分配寄存器 gen_type(T); emit(\" id\"); gen_dec(D); } void gen_type(type_t t) { switch(t-kind) { case INT:// fall through case BOOL: emit(\".int\"); break; } } void gen_stm(stm_t s) { switch (s->kind) { STM_ASSIGN: r = gen_exp(s->exp); emit(\"mov r, e->id\"); break; STM_PRINTI: r = gen_exp(s->exp); emit(\"printi r\"); break; STM_PRINTB: r = gen_exp(s->exp); emit(\"printb r\"); break; } } reg_t gen_exp(exp_t e) { switch (e->kind) { case EXP_INT: r = random_reg(); emit(\"movn e->value, r\");// n return r; case EXP_ID: r = random_reg(); emit(\"mov e->value, r\");// id return r; case EXP_BOOL: r = random_reg(); emit(\"movn e->value, r\");// 1/0 return r; case EXP_ADD: r1 = gen_exp(e->left); r2 = gen_exp(e->right); r = random_reg(); emit(\"add r1, r2, r\"); return r; case EXP_AND: r1 = gen_exp(e->left); r2 = gen_exp(e->right); r = random_reg(); emit(\"and r1, r2, r\"); return r; } } Garbage Collection Mark and Sweep mark phase: traces reachable objects (mark_bit |= 1) let todo = {all roots} while todo != nil do pick v sweep phase: collects garbage objects (mark_bit == 0) p = bottom of heap while p Stop and Copy copy all reachable objects in old space to new space(reserved for GC): copied objects scaned objects: pointers have been restored Compilers Exercise C Declaration Interpreter #include #include #include #include #define MAXTOKENS 100 #define MAXTOKENLEN 64 enum type_tag { IDENTIFIER, QUALIFIER, TYPE, }; struct token { char type; char string[MAXTOKENLEN]; }; int top = -1; struct token stack[MAXTOKENS]; struct token ts; #define pop stack[top--] #define push(s) stack[++top] = s enum type_tag classify_string(void) { char *s = ts.string; if (!strcmp(s, \"const\")) { strcpy(s, \"read-only \"); return QUALIFIER; } if (!strcmp(s, \"volatile\")) return QUALIFIER; if (!strcmp(s, \"void\")) return TYPE; if (!strcmp(s, \"char\")) return TYPE; if (!strcmp(s, \"signed\")) return TYPE; if (!strcmp(s, \"unsigned\")) return TYPE; if (!strcmp(s, \"short\")) return TYPE; if (!strcmp(s, \"int\")) return TYPE; if (!strcmp(s, \"long\")) return TYPE; if (!strcmp(s, \"float\")) return TYPE; if (!strcmp(s, \"double\")) return TYPE; if (!strcmp(s, \"struct\")) return TYPE; if (!strcmp(s, \"union\")) return TYPE; if (!strcmp(s, \"enum\")) return TYPE; return IDENTIFIER; } void gettoken(void) { char *p = ts.string; /* 略过空白字符 */ while ((*p = getchar()) == ' '); if (isalnum(*p)) { /* 读入得标识符以ａ－Ｚ，０－９开头 */ while (isalnum(*++p = getchar())); ungetc(*p, stdin); *p = '\\0'; ts.type = classify_string(); return; } if (*p == '*') { strcpy(ts.string, \"pointer to\"); ts.type = '*'; return; } ts.string[1] = '\\0'; ts.type = *p; return; } void read_to_first_identifer(void) { gettoken(); // read til identifier while (ts.type != IDENTIFIER) { push(ts); gettoken(); } printf(\"%s is \", ts.string); gettoken(); } void deal_with_arrays(void) { while (ts.type == '[') { printf(\"array \"); gettoken(); /* 数字或']' */ if (isdigit(ts.string[0])) { printf(\"0..%d \", atoi(ts.string) - 1); gettoken(); } gettoken(); printf(\"of \"); } } void deal_with_pointers(void) { while (stack[top].type == '*') { printf(\"%s \", pop.string); } } void deal_with_function_args(void) { while (ts.type != ')') { gettoken(); } gettoken(); printf(\"function returning \"); } void deal_with_declarator(void) { /* 处理标识符之后可能存在的数组/函数 */ switch (ts.type) { case '[': deal_with_arrays(); break; case '(': deal_with_function_args(); break; } deal_with_pointers(); /* 处理在读入到标识符之前压入到堆栈中的符号 */ while (top >= 0) { if (stack[top].type == '(') { pop; gettoken(); //读取')'之后的符号 deal_with_declarator(); } else { printf(\"%s\", pop.string); } } } int main(void) { /* 将标记压入堆栈中, 直到遇见标识符 */ read_to_first_identifer(); deal_with_declarator(); printf(\"\\n\"); system(\"pause\"); return 0; } Cool(Classrom Object-Oriented Language) Awesome Reference Parser Implemention // 返回下一个Token(只测试该Token，不向前移动Token List的offset指针) Token Peek(void); // 消费下一个Token Token Next(void); // void Expect(expectedToken) if (Peek() != expectedToken) { Error(\"expect %s, but got %s\\n\", expectedToken, Peek()); } // void Try(expectedToken) if (Peek() == expectedToken) { Next(); // 消费之 return true; } return false; © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/dataBase/databaseBasicNotes.html":{"url":"computerScience/dataBase/databaseBasicNotes.html","title":"Database Basic Notes","keywords":"","body":"Database Basic Notes Database Basic Notes Basic Concepts Feature Common Words Data Format XML DTD(Document Type Definition) XSD(XML Schema Definition) JSON(JavaScript Object Notation) Relational Algebra Operators Higher-Level Database Design Models UML(Unified Modeling Language) Classes Associations Associations Classes Subclasses Composition and Aggregation E/R Model(Entity-Relationship Model) SQL Relational Design Decomposition functional dependencies BCNF (boyce-codd normal form) multivalued dependencies 4NF(forth normal form) Normalized Design Indexes Transactions Transaction Standard ACID Properties Isolation Level Integrity Constraints Triggers (DBMS Level Constraints) Views Modifications on Views Implements Modification with Triggers SQL Standard - Updatable Views Nosql - MongoDB Basic Notes Set Up Install Not Upgrade Start/Stop/Restart Uninstall Shell Instruction create and drop create drop query insert information database collection Basic Concepts Feature Massive Persistent Safe Multi-user Convenient Efficient Reliable Common Words create/drop(from)/insert into/delete from/update restricts sub-queries views(shorthand for queries) left/right join on ... primary/foreign key references (id, name, birth, majar, grade) is not normalized, because grade is not relevant to student id (id, name, birth) + (id, majar, grade) is normalized (name, os, lang) is not mormalized, because os isn't relevant to lang (name, os) + (name, lang) is normalized Data-intensive applications may not use DBMS/Query Language at all e.g Hadoop, all operations on data stores in files Data Format XML single root element matched tags with proper nesting unique attributes within elements DTD(Document Type Definition) similar grammar to regular expression(*?) ID/IDRef should be unique CDATA: character data (#PCDATA): parsed character data (plain text between tags) ]> Kind of sword Yilong Liu tools: xmlcopyeditor xmllint xmllint --valid --noout Bookstore.xml XSD(XML Schema Definition) xmllint -schema Bookstore.xsd -noout Bookstore.xml JSON(JavaScript Object Notation) serializing data objects in files human-readable data semi-structured data number/boolean/string/array/object(empty or key-value pair) recursive constructs Relational Algebra Operators select operator σ(sigma): σ(sID 20)Table_Name set constraints project operator π(pi) : π(sID, GPA)Table_Name select certain columns cross-product operator x: Table1 x Table2, m tuples(rows) x n tuples(rows) => m*n tuples(rows) natural join operator ∞: σ(E1.A1 = E2.A1 ^ E1.A2 = E2.A2 ...) (E1 x E2) theta join operator ∞(cond): σ(cond) (E1 x E2), call cond as ϴ difference operator -: matching schemas => change rows/tuples union/intersection operator ∪ / ∩: matching schemas => change rows/tuples rename operator ρ: change schemas(attributes name), different schemas same schemas (union/intersection/self-join) assign statement := tree notation π(sID, GPA) (σ(sID 3.7) Student) Higher-Level Database Design Models Higher-Level Database Design Models -Translator-> Relational implemented by RDBMS UML(Unified Modeling Language) Classes for data modeling: add PK(primary key) drop methods ----------- | student | |---------| |sID PK | |sName | |GPA | |---------| || ----------- Associations relationships between objects of 2 classes): one to one: 1..1 --- 1..1 many to one: * --- 1..1 one to many:1..1 --- * many to many: * --- * ----------- --------- | student | |collegs| |---------| | | |sID PK |x..y Apply m..n| | |sName |-------------------| | |GPA | | | |---------| | | || | | ----------- --------- Associations Classes classes store information of relationship edge between 2 data classes unnecessary if 0..1 or 1..1 c1 * --- 1..1 c2 information of relationship edge can stored in c1 owing to every object of c1 only associated with 1 object of c2 Subclasses children classes Composition and Aggregation E/R Model(Entity-Relationship Model) SQL select ... from ... where insert into ... ... delete from ... where ... update ... set ... = ... where ... DROP VIEW IF EXISTS Standings; DROP VIEW IF EXISTS Count; DROP VIEW IF EXISTS Wins; DROP TABLE IF EXISTS Matches; DROP TABLE IF EXISTS Players; -- Players Table CREATE TABLE Players ( id SERIAL primary key, name varchar(255) ); -- Matches Table CREATE TABLE Matches ( id SERIAL primary key, player int references Players(id), opponent int references Players(id), result int ); -- Wins View shows number of wins for each Player CREATE VIEW Wins AS SELECT Players.id, COUNT(Matches.opponent) AS n FROM Players LEFT JOIN (SELECT * FROM Matches WHERE result>0) as Matches ON Players.id = Matches.player GROUP BY Players.id; -- Count View shows number of matches for each Player CREATE VIEW Count AS SELECT Players.id, Count(Matches.opponent) AS n FROM Players LEFT JOIN Matches ON Players.id = Matches.player GROUP BY Players.id; -- Standings View shows number of wins and matches for each Player CREATE VIEW Standings AS SELECT Players.id,Players.name,Wins.n as wins,Count.n as matches FROM Players,Count,Wins WHERE Players.id = Wins.id and Wins.id = Count.id; Relational Design Decomposition start with mega-relations: including all attributes decompose into smaller relations(BCNF/4NF) functional dependencies A -> B => 1-1/n-1 mapping key sets: closure of sets contains all attributes assuming relation R(A, B, C, D, ..., G) andclosure of A, B {A, B} + A->C->D, B->E->F, F->G => {A, B}+ = {A, B, C, ..., G} then, {A, B} is a key if there no exists such closure, then treat all-attributes as a key BCNF (boyce-codd normal form) for each A -> B having A is super key && B isn't key not exists A -> B -> C here's the algorithm: /* * @brief fixed point algorithm just like most algorithms from compiler * * by decomposing to transform non-key dependent attributes to key dependent attributes */ compute FDs for R compute key for R using its FDs while (there is relation R' aren't in BCNF) { pick any R' with A -> B that violates BCNF (A is not its key) decompose R' into R1(A, B) and R2(A, rest) compute FDs for R1 and R2 compute keys for R1 and R2 using their FDs } multivalued dependencies A -> B && rest attributes => A ->> B A ->> B(1-n mapping), A ->> C(1-n mapping), no B -> C/C ->> B, B * C redundant tuples/rows A ->>B && A ->>C => A ->> B∩C A ->>B && B ->>C => A ->> C-B 4NF(forth normal form) if A ->> B then A is key && B isn't key here's the algorithm: /* * @brief fixed point algorithm just like most algorithms from compiler * * by decomposing to transform non-key dependent attributes to key dependent attributes */ compute FDs and MVDs for R compute key for R using its FDs while (there is relation R' aren't in 4NF) { pick any R' with A ->> B that violates 4NF(A is not its key) decompose R' into R1(A, B) and R2(A, rest) compute FDs and MVDs for R1 and R2 compute keys for R1 and R2 using their FDs } Normalized Design every row has the same number of columns every row has a unique key(PRIMARY KEY) everything in a row is all relevant to unique key everything in a row is all relevant to each other Indexes primary mechanism to improve performance of database persist data structures stored in database (hash tables/B trees/B+ trees) trade off: scale of database and workload(query/update rate) as input of physical design advisors CREATE INDEX IndexName on T(A) CREATE INDEX IndexName on T(A1, A2, ..., An) CREATE UNIQUE INDEX IndexName on T(A) DROP INDEX IndexName Transactions a sequence of one/more SQL operations treated as a unit target: concurrency and failures recovery Transaction Standard all or nothing(atomicity) transaction begins automatically on first SQL statement on \"commit\": old transaction ends, new one begins on session termination: current transaction ends \"autocommit\" turns each statement into transaction ACID Properties Atomicity(Logging) Consistency Isolation: guarantee serializability(Locking) Durability(Logging) Isolation Level weaker isolation level: read uncommitted increased concurrency + decreased overhead = increased performance weaker consistency guarantees some system default: repeatable read SET TRANSACTION READ ONLY; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; Integrity Constraints CREATE TABLE TableName ( ... PRIMARY KEY, ... UNIQUE, ... CHECK (Condition), ... references TableName(ForeignKey), ... references TableName(ForeignKey) ON DELETE/UPDATE RESTRICT/SET NULL/CASCADE, ... , PRIMARY KEY (Attr1, Attr2, ...), UNIQUE (Attr1, Attr2, ...), CHECK (Condition), FOREIGN KEY (Attr1, Attr2, ...) references TableName(Bttr1, Bttr2, ...) [ ON ... (default RESTRICT) ] ); CREATE ASSERTION AssertionName CHECK (Condition); Triggers (DBMS Level Constraints) CREATE TRIGGER TriggerName BEFORE|AFTER|INSTEAD OF Events(INSERT/UPDATE OF/DELETE ON TableName) [ referencing-variables ] [ FOR EACH ROW ] WHEN ( Condition ) [ BEGIN ] Action [ END ]; CREATE TRIGGER Cascade After DELETE ON S REFERENCING OLD ROW AS O FOR EACH ROW DELETE FROM R WHERE A = O.B (R.A = S.B) CREATE TRIGGER Cascade After DELETE ON S REFERENCING OLD TABLE AS OT DELETE FROM R WHERE A IN (SELECT B FROM BT) Views logical layer: hiding data from users modularity and reuse of query VIEW ViewName = VIEWQUERY (R1, R2, ..., Rn) CREATE VIEW ViewName (T1, T2, ..., Tn) AS Modifications on Views owing to views are logical layer, it's senseless to modify data on views Implements Modification with Triggers CREATE TRIGGER TriggerName INSTEAD OF DELETE/UPDATE OF/INSERT ON ViewName [ referencing-variables ] [ FOR EACH ROW ] WHEN ( Condition ) [ BEGIN ] Action [ END ]; SQL Standard - Updatable Views SELECT (no DISTINCT) on single table T no GROUP BY/HAVING or Aggregation attributes can't be NULL/default values sub-queries cant' refer to table T CREATE VEIW ... WITH CHECK OPTION; Nosql - MongoDB Basic Notes Set Up Install sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927 echo \"deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse\" \\ | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list sudo apt-get update sudo apt-get install -y mongodb-org mongodb-org-server \\ mongodb-org-shell mongodb-org-mongos mongodb-org-tools Not Upgrade echo \"mongodb-org hold\" | sudo dpkg --set-selections echo \"mongodb-org-server hold\" | sudo dpkg --set-selections echo \"mongodb-org-shell hold\" | sudo dpkg --set-selections echo \"mongodb-org-mongos hold\" | sudo dpkg --set-selections echo \"mongodb-org-tools hold\" | sudo dpkg --set-selections Start/Stop/Restart sudo service mongod start sudo service mongod stop sudo service mongod restart Uninstall sudo service mongod stop sudo apt-get purge mongodb-org* sudo rm -r /var/log/mongodb sudo rm -r /var/lib/mongodb Shell Instruction create and drop create use test show dbs drop use dbToDrop db.dropDatabase() query db.collection.find().pretty() insert db.collection.insert(ison); information database db.getName() db.stats() db.version() db.getMongo() collection db.getCollectionNames() db.printCollectionStats() © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/network/networkBasicNotes.html":{"url":"computerScience/network/networkBasicNotes.html","title":"Network Basic Notes","keywords":"","body":"Computer NetWorking Notes Computer Network and Internet What is Internet end-to-end principle: implement features in the end-system/hosts where possible congestion implemented on Transport Layer Consist Internet Service Provider -> Packet Switch/Communication Link -> Host/End System Delay nodal = proc + queue + trans + prop: 总时延 = 产生/到达时延 + 排队时延 + 传输时延 + 传播时延 Layer Application Layer Protocol: HTTP SMTP (message, stream of data) Transport Layer Protocol: TCP UDP (segment, segment of data) Network Layer Protocol: IP (因特网的粘合剂) (unreliable datagram, packet of data) Data Link Layer Protocol: Wifi PPP(点对点) 以太网 (frame) Physical Layer Protocol Layering Principle modularity well defined service: simple service model provided by lower level, providing for higher level reuse separation of concerns continuous improvement: change inner structure of layer independently Application Layer Application Layer Protocol defines: types of messages exchanged syntax of various message types(fields defination) semantics of fields rules fsor when/how to send/respond to messages HTTP HTTP -> Socket Interface -> TCP stateless protocol Non-Persistent Connections and Persistent Connections non-persistent connections: 1 http request with 1 tcp connection persistent connections: multiple http request with 1 tcp connection HTTP Message Format http request format request line -> (method field, object url field, protocol version) header lines -> Host/Connections(close -> non-persistent connection)/User-agent/Accept-language \\r\\n entity body http response format status line -> (protocol version, status code, corresponding status message) header lines -> Connections/Date/Server/Last-Modified/Content-Length(bytes)/Content-Type \\r\\n entity body Cookies first request header -> without cookie first response header -> Set-cookie: numebr to client client store identification number for specific site into cookies files second request header -> cookie: number (extract identification number for specific site from cookies files) function: create User Session Layer on top of stateless HTTP Process Port to Transport Layer bandwidth-sensitive application: UDP reliable-sensitive application: TCP email - SMTP - TCP remote terminal access - Telnet - TCP Web - HTTP/HTTPS - TCP file tranfer - FTP - TCP streaming multimedia - HTTP/HTTPS/RTP - TCP/UDP internet telephony - SIP/RTP - UDP Address (32 bits network layer )IP : find specific host/end-system (16 bits transport layer)port: find specific process Transport Layer TCP(Transmission Control Protocol) connection-oriented service in-sequence stream of bytes service reliable delivery congestion control 3-way handshake SYN -> SYN/ACK -> ACK FIN(toB) -> [Data+]ACK(toA) -> FIN(toA) -> ACK(toB) UDP(User Datagram Protocol) lightweight and connectionless datagram service unreliable delivery udp header: source port(16 bit), destination port(16 bit), checksum(16 bit), length(16 bit) ICMP (Internet Control Message Protocol) report error conditions back help diagnose problems site above IP ICMP Message Type 0 type 0 code: echo reply(by ping) 3 type 0 code: destination network unreachable 3 type 1 code: destination host unreachable 3 type 3 code: destination port unreachable 8 type 0 code: echo request(by ping) 11 type 0 code: TTL(time to live) Expired(by ping) Error Detection TCP/IP: checksums(1 bit) Ethernet(Link Layer): cylic redundancy code(2 bit/more) SSL(Secure Sockets Layer)/TLS(Transport Layer Security): message authentication code(MAC)(cryptographic data) - prevent malicious attacks Slide Window and Retransmission SWZ N and RWS 1: go back N SWZ N and RWZ N: selective repeat Network Layer IP Service Model prevent packets looping forever(TTL/time to live field in header): if TTL gets decreased to zero, then drop this datagram limit fragment packets size(Packet ID, Flags, Fragment Offset) reduce changes of wrong destination(Checksum, Destination Address) IPv4 Addresses 32 bits long: a.b.c.d Address Structure historical: class A: 0-network(7 bits)-host(24 bits) class B: 10-network(14 bits)-host(16 bits) class C: 110-network(21 bits)-host(8 bits) today: 171.64.0.0/16 means 171.64.0.0 to 171.64.255.255, A/24 describes 256 addresses, A/20 describes 4096 addresses longest prefix matching and netmask(A/16 e.g 0.0.0.0/0 => matching all addresses) ARP(Address Resolution Protocol) generates mappings between link layer and network layer addresses cached in nodes request-reply protocol: who has network address X => I have network address X request sent to link layer broadcast address, reply sent to requesting address when request to dest ARP packet header with empty DEST HARDWARE ADDRESS field and opcode 1(request) when reply to src ARP packet header with dest hardware address as SRC HARDWARE ADDRESS field, src hardware address as DEST HARDWARE ADDRESS field and opcode 2(reply) if A and B aren't in same sub-net, they delivery ARP boardcast with third public gateway Packet Format Endian network is big-endian in x86 processor, use htons()/ntohs()/htonl()/ntohl() host: network -short/long helper function to transform format #include uint16_t http_port = 80; uint16_t packet_port = ntohs(packet->port); if (packet_port == http_port) { // OK } Wireshark Set Up sudo dpkg-reconfigure wireshark-common sudo gpasswd -a $USER wireshark Other Tools ifconfig + egrep netstat + egrep tcpdump nslookup © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/operatingSystems/CSAPP.html":{"url":"computerScience/operatingSystems/CSAPP.html","title":"CSAPP","keywords":"","body":"Computer Systems: A Programmer's Perspective - System Basic Notes Computer Systems: A Programmer's Perspective - System Basic Notes 机器码与进制转换 浮点数 Stack Frame Architecture Control Signal Special Control Signal Branch/Loop/Jump Forwarding Exception Efficence Optimization Principles Tips Replacement Branch Code Motion Unrolling (Duff's Device) 异常控制流 异常 分类 异常处理程序 进程 上下文 进程控制 创建和终止进程 回收子进程 信号 处理信号 阻塞信号 非本地跳转 系统级 I/O socket I/O 限制 I/O 函数的选择 网络 并发 锁 调试/测试 日志 机器码与进制转换 浮点数 规格化浮点数: 1.xxx 2^(exp - 127) - e.g `5 = 5.0 = 1.25 2^(129 - 127)` xxx: 尾数 exp: 阶码 Stack Frame # 准备阶段 # Caller-Save: %eax %ecx %edx # Callee-Save: %ebx %esi %edi # 传参顺序: rdi, dsi, rdx, rcx, r8, r9, stack pushl %ebp movl %esp, %ebp pushl %ebx # 结束阶段 movl -4(%ebp), %ebx movl %ebp, %esp popl %ebp ret x86_64: 可使用超出 Stack Pointer 128 bytes 的内存区域, 称为 Red Zone. Architecture Control Signal State Signal Fetch icode,ifun rA,rB valC,valP Decode valA,srcA valB,srcB Execute valE Cond Memory valM read/write WriteBack E port,dstE M port,dstM PCUpdate PC Special Control Signal handle ret: IRET in {D_icode, E_icode, M_icode} load/use hazard: E_icode in {IMRMOVL, IPOPL} && E_dstM in {d_srcA, d_srcB} mispredicted branch: E_icode in {IJXX} && !e_Cnd exception: m_stat in {SADR, SINS, SHLT} || W_stat in {SADR, SINS, SHLT} Branch/Loop/Jump PrectPC | W_valM(无法预测) | M_valP/M_valA (在译码阶段合并信号量 valA 与 valP: PCUpdate 位于 Fetch,无需传递 valP, 只剩 call/jxxx 需要 valP) AT: always taken NT: never taken BTFNT: backward taken forward not taken Forwarding 流水线中最早阶段的转发源, 优先级最高 execute > memory > write int d_valA = [ D_icode in {ICALL, IJXX}: D_valP; d_srcA == e_dstE : e_valE; d_srcA == M_dstM : m_valM; d_srcA == M_dstE : M_valE; d_srcA == W_dstM : W_valM; d_srcA == W_dstE : W_valE; # register file 1 : d_rvalA; ]; Exception 流水线中最深的指令引起的异常, 优先级最高 e.g 访存阶段地址越界异常优先级高于取指阶段地址越界异常优先级 Efficence CPI = 1.0 + lp + mp + rp: lp: load penalty(load/use hazard) mp: mispredicted branch penalty rp: return penalty Optimization Principles 合适的算法和数据结构 编写编译器能够有效优化的代码 e.g 寄存器别名,存储器别名,函数的副作用 导致编译器无法(不敢)合并/删除冗余代码 提高代码的并行性 消除不必要的访存 e.g 多次访存(可用中间量优化), 多次函数调用(可用宏/内联函数优化) Tips Replacement 用多条 Shift/Add/Sub 指令, 代替 Mul/Div Branch 利用条件表达式代替条件分支语句: 降低预测错误惩罚 Code Motion 将不变测试条件/常变量的计算从循环中移出 将多次访存利用中间自动/寄存器变量改写成一次访存 Unrolling (Duff's Device) 循环展开: 增大循环的步长 - Duff's Device 以 7 为步长: 提升循环的运行效率 一次循环内: 可先将所有数据先读出来(Memory State),将进行计算(Excute State), 从而消除 Load/Use 冒险而产生的 Bubble 异常控制流 理解异常控制流,有助于理解以下概念: 陷阱(trap)/系统调用(system call) 系统级 I/O 线程/进程(concurrency) 虚拟存储器 软件异常 异常 分类 类别 原因 异步/同步 返回行为 例子 interrupt 输入/输出外部中断 async next(concurrency) 磁盘 trap 主动异常/系统调用 sync next write/intN fault 潜在可恢复的错误 sync current/abort seg/float exp abort 不可恢复的错误 sync abort(not return) 硬件错误 异常处理程序 异常处理程序主要分为 3 类: 控制权返回给 Instruction_current 控制权返回给 Instruction_next abort/exit 进程 一个独立的逻辑控制流(并行执行) 一个私有的地址空间(缓存与虚拟存储器) 上下文 代码/数据,堆/栈,通用寄存器,程序计数器,环境变量,文件描述符集合 上下文切换:用户模式与内核模式的切换 高速缓存污染(pollution): 每次切换后,总是会发生 cold cache miss 进程控制 #include #include #include #include 创建和终止进程 父进程与子进程获得 2 份独立的私有空间与 2 份独立的上下文, 不同的 PID(process id) 由于指针(如打开的文件描述符),有可能互相影响,但大体上互不影响 /* * output: parent: x=0 * output: child: x=2 * 独立上下文代表拥有独立的通用寄存器与栈,代表拥有拷贝的自动变量(局部变量),互不影响地进行修改 */ int main(void) { pid_t pid; int x = 1; pid = fork(); if (pid == 0) { // child printf(\"child: x=%d\\n\", ++x); exit(0); } // parent printf(\"parent: x=%d\\n\", --x); exit(0); } 回收子进程 #define N 2 int main(void) { int status, i; pid_t pid[N], retpid; for (i = 0; i 0) { if (WIFEXITED(statue)) { printf(\"child: %d terminated normally with exit status=%d\\n\", retpid, WEXITSTATUS(status)); } else { printf(\"child %d terminated abnormally\\n\", retpid); } } // only if there are no more children, it can exit normally if (errno != ECHILD) { unix_error(\"waitpid error\"); // exit with error log } exit(0); // exit normally } 信号 #include #include #include 一个只发出而未被处理的信号为待处理信号 一种类型至多有一个待处理信号, 多余待处理信号不会进入处理队列,只是被简单丢弃 不可以用信号对其他事件进行计数, 同一事件多次发生产生的信号有可能被简单丢弃 处理信号 void handler(int sig) { pid_t pid; while ((pid = waitpid(-1, NULL, 0)) > 0) { printf(\"Handler reaped child %d\\n\", (int)pid); } if (errno != ECHILD) { unix_error(\"waitpid error\"); } else { sleep(2); } return; } int main(void) { int i, n; char buf[MAXBUF]; pid_t pid; if (signal(SIGCHLD, handler) == SIG_ERR) { unix_error(\"signal error\"); } for (i = 0; i 阻塞信号 // how: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK, 是否阻塞set中的信号合集 int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum); int sigismember(const sigset_t *set， int signum); void handler(int sig) { pid_t pid; while ((pid = waitpid(-1, NULL, 0)) > 0) { deletejob(pid); } if (errno != ECHILD) { unix_error(\"waitpid error\"); } } // 保证父进程先执行 addjob, 再执行 deletejob int main(int argc, char **argv) { int pid; sigset_t mask; signal(SIGCHLD, handler;) initjob(); while (1) { sigemptyset(&mask); sigaddset(&mask, SIGCHLD); sigprocmask(SIG_BLOCK, &mask, NULL); // block SIGCHLD if ((pid = fork()) == 0) { // unblock SIGCHLD in child, make it can transfer signal sigprocmask(SIG_UNBLOCK, &mask, NULL); execve(\"/bin/date\", argv, NULL); } // parent process addjob(pid); // after addjob, unblock SIGCHLD, make it can handle signal sigprocmask(SIG_UNBLOCK, &mask, NULL); } } 非本地跳转 #include setjmp - catch: 返回多次 longjmp - throw: 不返回 系统级 I/O // robust I/O ssize_t rio_readn(int fd, void *usrbuf, size_t n) { size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft > 0) { if ((nread = read(fd, bufp, nleft)) 0) { if ((nwritten = read(fd, bufp, nleft)) socket I/O 限制 输出函数+输入函数: 中间必须插入 fflush, fseek, fsetpos, rewind 输入函数+输出函数: 中间必须插入 fseek, fsetpos, rewind I/O 函数的选择 sprintf+rio_writen: 格式化输出至套接口 rio_readlineb+sscanf: 格式化输入 网络 #include #include #include int main(int argc, char *argv) { char **pp; struct in_addr addr; struct hostent *hostp; if (argc != 2) { fprintf(stderr, \"usage: %s \\n\", argv[0]); exit(0); } if (inet_aton(argv[1], &addr) != 0) { hostp = gethostbyaddr((const char*)&addr, sizeof(addr), AF_INET); } else { hostp = gethostbyname(argv[1]); } printf(\"official hostname: %s\\n:\", hostp->h_name); for (pp = hostp->h_aliases; *pp != NULL; pp++) { printf(\"alias: %s\\n\", *pp); } for (pp = hostp->h_addr_list; *pp != NULL; pp++) { addr.s_addr = ((struct in_addr *)*pp)->s_addr; printf(\"address: %s\\n\", inet_ntoa(addr)); } exit(0); } 并发 锁 防止死锁: 每对互斥锁(s, t), 每个线程顺序请求锁, 逆序释放锁 调试/测试 日志 void unix_error(char *msg) { fprintf(stderr, \"%s: %s\\n\", msg, strerror(errno)); exit(0); } void posix_error(int code, char *msg) { fprinf(stderr, \"%s: %s\\n\", msg, strerror(code)); exit(0); } void dns_error(char *msg) { fprintf(stderr, \"%s: DNS error %d\\n\", msg, h_errno); exit(0); } void app_error(char *msg) { fprinf(stderr, \"%s\\n\", msg); exit(0); } © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/operatingSystems/memoryManagementBasicNotes.html":{"url":"computerScience/operatingSystems/memoryManagementBasicNotes.html","title":"Memory Management Basic Notes","keywords":"","body":"Memory Management Basic Notes Memory Management Basic Notes Tools perf trace vmstat pmap Memory Hotplug TCMalloc Oprofile Tools perf trace vmstat check usage of virtual memory and swap region vmstat 2 pmap check detailed usage of memory pmap PID Memory Hotplug TCMalloc Google TCMalloc Oprofile © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/operatingSystems/operatingSystemsBasicNotes.html":{"url":"computerScience/operatingSystems/operatingSystemsBasicNotes.html","title":"Operating Systems Basic Notes","keywords":"","body":"Operating System Basic Notes Operating System Basic Notes GCC 内联汇编 基本概念 操作系统的特性 操作系统的资源管理功能 处理机调度 存储器管理 设备管理 文件系统 操作系统的演变 批处理系统 分时系统 实时系统 操作系统虚拟机 用户接口 操作系统的组织结构 并发(Concurrent) 程序并发的特点 启动 BIOS 启动顺序 寄存器 BIOS Config Bootloader 标志(lab1/tools/sign.c) 基本功能 切换到保护模式, 启动段机制 从硬盘上加载 某种(kernel in ELF) 格式的 os kernel(在硬盘中紧邻 MBR) 至内存的固定区域 跳转到 os kernel 的入口点(entry point), 转移控制权至 os 保护模式与段机制 物理内存管理 bootloader 探测机器内存分布 bootloader 基本概念 bootloader 基本目标 基本管理方式 地址生成 地址生成时机 地址映射(软硬件结合) 地址检查(软硬件结合) 连续内存分配(malloc/free) 内存碎片 动态分配策略 碎片整理策略 ucore 实现 紧凑(compaction) 分区对换(swapping in/out) malloc 实现策略 启发式(Heuristic)编程 伙伴系统(Buddy System) 合并空闲块 非连续内存分配 段式存储管理 GDT 页式存储管理 虚拟地址 物理地址 页表 页表结构 性能问题 TLB(translation lookaside buffer) 多级页表 反置页表 段页式存储管理 内存的特权级 特权级检查 特权级切换 ring 0 to ring 3 ring 3 to ring 0 (特权级提升) TSS(Task State Segment) 虚拟内存管理 Page Fault 覆盖与交换 覆盖技术(overlay) 交换技术(swap) 虚拟页式存储管理 标志位 页面置换算法 局部置换算法 最远未用算法(Least Recently Used/LRU Algorithm) 时钟算法(Clock Algorithm) 最不常用算法(Least Frequently Used/LFU Algorithm) 全局置换算法 工作集算法 缺页率算法 实现 中断(Interrupt Service Routine/Interrupt Quest) 中断进入 保护现场 中断实现 概述 Interrupt 实现 系统调用 进程(资源分配单位) 处理机(进程)的特权级 进程状态/生命周期 进程控制块(Process Control Block) 进程通信 线程(CPU 调度单位) idleproc(0 号内核线程) 内核线程与用户进程 Process 实现 process context(执行现场) do_fork function do_execve function 处理机调度(Schedule) 调度时机 六大调度时机 调度策略/算法 算法目标 先来先服务算法(First Come First Served/FCFS) 短进程优先算法(Shortest Process Next/Shortest Remaining Time) 最高响应比优先算法(Highest Response Ratio Next) 时间片轮转算法(Round Robin) 多级队列调度算法(MQ) 多级反馈队列算法(MLFQ) 同步互斥 临界区的访问原则 基于软件方法的同步互斥 高级抽象的同步互斥 lock/semaphore monitor 死锁 mutex 实现 P/V 操作 具体实现信号量的 P 操作 具体实现信号量的 V 操作 管程 Conditional Variable 文件系统 (FileSystem) 文件组成 文件系统基本数据结构 文件卷控制块(superblock) 目录项(dentry) 文件控制块(vnode/inode) 文件描述符 打开文件表 文件分配 空闲空间管理 冗余磁盘阵列(Redundant Array of Inexpensive Disks/RAID) FS 实现 Mount index inode Device 设备管理详解 CGA/EGA + Chromatext video buffer I/O 实践 工具 Bochs Installation Config Run GNU ld 操作系统是一个大型的程序系统, 它负责(处理机管理, 存储管理, 设备管理, 文件系统): 计算机系统软、硬件资源的分配和使用 控制和协调并发活动 提供用户接口, 使用户获得良好的工作环境 GCC 内联汇编 asm ( assembler template // assembly language :=output operands // 约定输出 :input operands // 约定输入 :clobbers // 约定插入 ); constraints: m/v/o = memory r = register Q = ea/b/c/dx a = eax b = ebx c = ecx d = edx D = edi S = esi 0/n = fisrt/nth constraints 基本概念 操作系统的特性 并发性 : 能处理多个同时性活动的能力 共享性 : 多个计算任务对系统资源的共同享用 不确定性: 操作系统能处理随机发生的多个事件 - 程序运行次序的不确定性, 程序运行时间的不确定性 操作系统的资源管理功能 处理机调度 确定进程调度策略 给出进程调度算法 进行处理机的分派 存储器管理 存储分配与存储无关性 为用户提供逻辑地址, 解决主存分配问题 存储保护 实现系统程序与用户程序之间的隔离, 实现不同用户程序之间的隔离 存储扩充 虚拟内存管理: 主存+磁盘, 为每个进程管理一个虚拟内存映射链表 设备管理 设备无关性 用户向系统申请和使用的设备无关实际操作的设备, 操作系统为用户提供统一的逻辑设备(名) 设备分配(独享分配/共享分配/虚拟分配) 设备的传输控制(设备启动处理, 设备中断处理, 设备结束处理) 组织设备完成 I/O 操作, 并正确处理中断 文件系统 为用户提供一种简便、统一的存取和管理信息的方法, 解决信息的共享/数据的存取控制/数据的保密等问题: 实现用户的信息组织 提供存取方法 实现文件共享 保证文件安全 保证文件完整性 完成磁盘空间分配 操作系统的演变 单用户系统(45-55) -> 批处理系统(55-65) -> 多道系统(65-80) -> 分时系统(70-) -> 分布式系统 手工系统 -人机矛盾-> 联机批处理系统 -CPU I/O 矛盾 -> 脱机批处理系统 -响应能力-> 执行系统(中断/通道) -并行-> 多道批处理系统(粗粒度) -> 分时系统(细粒度) -> 实时系统 -> 个人/网络/分布式系统 批处理系统 作业成批送入计算机, 然后由作业调度程序自动选择作业, 在系统内(多道)运行 系统吞吐率高: 脱机/多道运行 作业周转时间长, 用户使用不方便, 缺少交互性 分时系统 采用时间片(time slice)轮转(round robin)的方法, 使计算机同时为多个终端用户服务, 保证对每个用户都有足够快的响应时间, 并提供交互会话功能 并行性 独占性 交互性 单处理器系统: 处理器与设备/处理器与通道/通道与通道/设备与设备可以同时刻并行(真正意义上的同时进行) 实时系统 实时系统对外部输入的信息, 能够在规定时间内处理完毕并作出反应(实时控制/实时信息处理) e.g 嵌入式操作系统 可靠性 安全性 及时响应 操作系统虚拟机 在裸机上配置了操作系统后便构成了操作系统虚拟机 裸机的指令系统: 机器指令; 操作系统虚拟机的指令系统: 系统调用 用户接口 操作/命令接口(操作命令): 作业控制语言/键盘命令(CLI)/图形化用户界面(GUI) 程序接口(系统功能调用): 在用户程序中可以直接使用系统功能调用(system call)请求操作系统提供的服务 操作系统的组织结构 一体化结构 模块化结构 可扩展内核(微内核)结构 层次化结构 并发(Concurrent) 程序并发的特点 程序执行的间断性 相互通信的可能性 资源分配的动态性 启动 BIOS 基本输入输出程序 系统设置信息 开机后自检程序 系统自启动程序 启动顺序 寄存器 CF: 初值 F000H EIP: 初值 FFF0H (FFF)F0000H+FFF0H = FFFFFFF0H, BIOS 的 EPROM(Erasable Programmable Read Only Memory) 处 加电后第一条指令一般是 ljmp(实模式下, 内存 !MB), 跳转地址为 CF BIOS Config BIOS 根据设置(硬盘/U 盘/网络启动), 加载存储设备的主引导扇区(Master Boot Record)(第一个扇区)的 512 字节至内存 0x7c00 处, 开始执行第一条指令(bootloader) Bootloader 实模式与保护模式带来的问题: 在实模式的寻址模式中, 令物理地址为 16 位段寄存器左移 4 位加 16 位逻辑地址的偏移所得的 20 位地址 若要访问 1MB 之后的内存, 则必须开启 A20 Line 开关(关闭 wrap around), 将 32 位地址总线打开, 并进入保护模式(Protect Mode) 在实模式中, 0~4KB 为中断向量表保留, 640KB ~ 1MB 为显存与 BIOS 保留, 实际可用的内存只有 636KB 考虑到日后内核镜像的体积有超过 1MB 的可能, 所以将其装载到物理地址 1MB(0x100000) 之后连续的一块内存中更好. 若要装载内核到物理地址 1MB 之后(实模式下无法访问), 可在实模式中暂时将其装载到一个临时位置, 待进入保护模式之后再移动至合适位置 解决方案: 将内核镜像装入内存临时地址 开启保护模式 移动内核镜像至 1MB 之后合适位置 跳转至内核入口(jmp addr 用以修改 cs:eip) 标志(lab1/tools/sign.c) 有效字节小于 510 bytes 结尾为 0x55aa 总计字节小于 512 bytes 基本功能 切换到保护模式, 启动段机制 通过 8042 键盘控制器的端口, 开启 A20, 关闭 memory wrap around, 获取足够内存空间 ; 键盘控制器的命令 ; 0xD0 Read Output Port ; 0xD1 Write Output Port ; 0xDD Enable A20 Address Line ; 0xDF Disable A20 Address Line ; 0x60 - 数据端口, 0x64 - 命令端口 call empty_8042 mov al,0xd1 out 0x64,al call empty_8042 mov al,0xdf out 0x60,al call empty_8042 empty_8042: dw 00ebh, 00ebh in al,64h test al,2 jnz empty_8042 ret 置 cr0 保护模式标志位(bit0) 为 1 加载全局描述符表 设置各个通用寄存器与段寄存器 从硬盘上加载 某种(kernel in ELF) 格式的 os kernel(在硬盘中紧邻 MBR) 至内存的固定区域 跳转到 os kernel 的入口点(entry point), 转移控制权至 os 保护模式与段机制 CS -> 全局描述符表(其起始地址与表大小位于 gdt 寄存器中)某项(每项存有 base/limit 等信息) -> 局部描述符表 -> 段选择子(段的基本信息) -> 基址+EIP -> 线性地址 ---页机制---> 物理地址 将 cr0 寄存器 bit0 置为 1, 表示进入了保护模式, 段机制开始起作用 物理内存管理 bootloader 探测机器内存分布 为内存管理模块提供基础: 在进入实模式前, 调用 int 15h(88h, e801h, e820h), 借助 BIOS 中断获取内存信息 bootloader 基本概念 bootloader 基本目标 抽象: 逻辑地址空间(线性物理地址映射) 保护: 独立地址空间(进程间互不影响) 共享: 访问相同内存(内核空间与共享库) 虚拟化: 独占内存空间假象 基本管理方式 重定位(relocation) 分段(segmentation): 代码段/数据段 分页(paging) 虚拟存储(virtual memory): 内存视作硬盘的缓存, 硬盘视作虚拟内存 地址生成 地址生成时机 编译时 链接时 加载时 执行时(相对寻址) 地址映射(软硬件结合) 逻辑地址 ---> 物理地址 硬件(CPU/MMU)完成映射地址 操作系统建立映射规则(页表) 地址检查(软硬件结合) 操作系统设置的段机制和段长度 硬件(CPU/MMU)根据段信息进行地址检查(内存访问是否异常) 连续内存分配(malloc/free) 内存碎片 外部碎片: 已分配单元间无法利用空闲单元(请求内存单元过大) 内部碎片: 已分配单元内空闲单元 动态分配策略 Fist-fit(最先匹配): 使用第一个可利用空闲块 - 容易产生外部碎片, 分配大块效率低 Best-fit(最佳匹配): 使用利用度最高的空闲块 - 外部碎片过小, 释放时需重新排列空闲块链表(升序) Worst-fit(最差匹配): 使用利用度最差的空闲块 - 分配中块效率高, 释放时需重新排列空闲块链表(降序) 碎片整理策略 ucore 实现 连续存放 n 个 page 结构, 形式表示内存页, 并在连续内存块的首页(header page)保存此连续块的连续页数目 维护一个链表, 链表每项为大块连续内存块的起始页(header page address) 和 连续页数目, 管理分散的连续内存块 紧凑(compaction) 将不同进程占用内存单元移至较为集中的地方: 只可移动 可动态重定位程序 只可移动 等待状态进程 分区对换(swapping in/out) 将等待状态进程的分区对换至外存,以增大可用内存单元 e.g Linux Swap 分区: 安装系统时一般切割大小为内存大小的 50%~100% 的外存作为 Swao 分区 malloc 实现策略 启发式(Heuristic)编程 建立已分配 void 指针表,free 函数执行时,只回收表中存在的指针;不存在则报错 对 heap 进行分区 - 小/中/大块内存请求,分别从不同区域(8/16/32 最小单位区)分配 记录当前堆块的信息，如长度，空闲状态 记录周围环境信息，如保留上/下一堆块的指针或记录上/下堆块空闲状态 伙伴系统(Buddy System) 可分配内存单元总大小为 2^n 总是将大小 小于请求大小的2 倍且为2 的幂次方 的某块内存单元分配出去(大小为 2^(i-1)) 合并空闲块 空闲块相邻 空闲块等大 低地址空闲块的 起始地址 必须为 空闲块大小 的 2 的幂次方倍(2 倍以上) 非连续内存分配 支持一个程序使用非连续的物理地址空间 支持共享代码与数据 支持动态加载与动态链接 段式存储管理 将逻辑地址划分, 低位表示段内偏移, 高位(取摸)表示段号(类比缓存中的内存地址) GDT typedef struct gdt_ptr { uint16_t gdt_limit; // gdt_length - 1 uint32_t gdt_base; } __attribute__((packed)) gdt_ptr_t; 用 16 位来表示表的长度(2 ^ 16 = 65532 bytes), 除以每一个描述符的 8 字节, 最多能创建 8192 个描述符 页式存储管理 开启页机制: init page directory(首址位于 cr3 寄存器), page table update GDT update ds,es,ss update cs with jmp instruction cr0 寄存器 bit31(most bit) 置 1 虚拟地址 TLB(translation lookaside buffer in cpu/pm) Virtual Address = 2^(bits of virtual page offset) * virtual page number + virtual page offset VPN(virtual page number point to PPN) - VPO(virtual page offset = PPO) 根据 VPN 在页表中找到对应表项(VPN 表示项号), 每项保存着 PPN TLBT(tag) - TLBI(index) - VPO 因为内存局部性原理, TLB 一般只需要很小(比如 64 项)即可达到不错的效果 物理地址 C(cache) PPO = VPO Page Frame(帧): 高位为帧号, 低位为偏移 Physical Address = 2^(bits of physical page offset) * physical page number/page frame number + physical page offset PPN(physical page number) - PPO(physical page offset = VPO) CT(tag) - CI(index) - CO(offset) 页表 页表由操作系统建立, 硬件(CPU/MMU)根据页表信息将虚拟地址映射为物理地址 页表结构 FN/PPN 标志位: resident bit(存在位)/dirty bit(修改位)/reference(clock) bit(引用位) 性能问题 两次访存: 第一次获取页表项, 第二次访问实际数据 页表占据大量内存单元 TLB(translation lookaside buffer) 缓存页表项 - key: VPN, value: PPN 　不用访问页表 多级页表 切割页表: 建立子页表 Page Directory -> Page Table -> Physical Address 将线性地址分成三部分 Directory+Table+Offset: cr3+Dir 取出 page table base, ptb+Tab 取出 physical address base, pab+offset = pa CR3 寄存器: 保存一级页表的基址 父页表表项保存子页表起始地址, 逻辑地址某部分保存偏移地址(子表项号) 存在位为 0 时, 不用保存子表, 节省内存单元 反置页表 PPN 作为页表索引, 页表项保存 VPN(或者 Hash(VPN|PID)) 将 VPN 映射为 PPN 时, 需遍历整个页表(但此页表只占用少量内存单元) 段页式存储管理 在页式存储管理基础上, 引入段式存储管理 映射为 sn: segment number, pn:page number, po: page offset 若以 4K(limit) 为 1 个页表大小, 则下级页表首址为 段/页表中某项的值 (2^12 = 4K) 以 vsn 为索引在进程段表中找到段表项, 获取段(页表)基址与段大小信息(item_value/limit): base = item_value 以 vpn 为索引在进程页表(页表基址 = base 中找到页表项, 获取 ppn ppn 内存的特权级 0: 最高特权级, 3: 最低特权级 特权级检查 CPL/RPL: 访问者特权级 DRL: 段描述符/门描述符(中断/陷阱门)中保存的特权级, 表示被访问段/中断服务/陷阱的特权级 CPL/RPL 特权级切换 ring 0 to ring 3 interrupt/trap: push SS(RPL=3) -> ESP -> EFLAGS -> CS(RPL=3) -> EIP -> Error Code iret: pop above variables, move to ring 3 ring 3 to ring 0 (特权级提升) interrupt/trap: stack switch push EFLAGS -> CS(RPL=0) -> EIP -> Error Code iret: pop above variables, move to ring 0 TSS(Task State Segment) 保存不同特权级的堆栈信息(SS/ESP) 全局描述符表中保存一个 TSS Descriptor(TSS base + TSS limit): allocate TSS memory -> init TSS -> fill TSS descriptor in GDT -> set TSS selector(task register) 虚拟内存管理 虚拟内存 = 物理内存 + 外存 Page Fault 虚拟地址越界: 访问不存在的虚拟地址 对只读地址进行写操作 访问未映射虚拟页(swap in/out) CPU 将产生异常的的线性地址(linear address) 存储在 CR2 寄存器中, 将 errorCode(bit2-访问权限异常,bit1-写异常,bit0-物理页不存在)压入中断栈 CR0: 处理器模式(实/保护/分段/分页模式); CR2: Page Fault Linear Address; CR3: Page-Directory Base Address Register 覆盖与交换 覆盖技术(overlay) 将程序中相互独立的模块分成一组, 为每组按最大模块分配内存单元 交换技术(swap) 将挂起进程的整个地址空间换出至外存(swap out), 将需用进程的整个地址空间换入至内存(swap in), 进程交替运行 虚拟页式存储管理 只将运行进程所必需页面装入内存, 其余页面至于外存 进程发生缺页异常时, 将所要求缺页装入内存: 选择目标物理页面 -> 无未占用物理页面, 则换出闲置物理页面(访问位) -> 装入物理内存,更新页表项 (换入逻辑地址与换出逻辑地址对应的页表项的驻留位/修改位/访问位/锁定位以及物理页号 ppn) 监控已经装入内存的页面, 及时将不需要页面换出至外存 标志位 驻留位: 此逻辑地址对应的页面在内存中 修改位: 此页面是否被修改过, 判定此页面换出时策略(写回外存/直接丢弃) 访问位: 此页面是否被读/写过, 判定此页面是否需要换出至外存 锁定位: 此页面不会被换出 页面置换算法 当出现缺页异常且物理内存已满时, 需要以页面置换算法为指导, 换出闲置物理页面, 换入所要求缺页, 并更新页表项: 尽可能减少物理页面的换入换出次数 只可交换映射到用户空间的物理页 当页表项中 PTE_P 为 0 时, 对应高位地址表示扇区地址(而不是物理位移) 换入时机: Page Fault 缺页; 换出时机: 积极/消极换出策略 局部置换算法 换入进程 A 的某个页面时, 只可换出进程 A 的某个页面: 为进程分配固定数目的页面 最远未用算法(Least Recently Used/LRU Algorithm) 利用链表等线性结构维护页面访问时间, 队首为最近一次访问页面(每次访问一个页面后, 把它从线性结构中间抽出至队首), 队尾为最远一次访问页面 时钟算法(Clock Algorithm) 利用循环链表维护页面(指针指向最先换入内存的页面), 页表项访问位维护访问记录(访问后将访问位置 1) 缺页时, 从指针处开始查找页面进行置换: 若访问位为 0, 则进行置换; 若访问位为 1, 则将此页面访问位置 0, 继续查找未访问页面 改进: 增加修改位 指针扫描前 指针扫描后 访问位 修改位 访问位 修改位 0 0 置换 0 1 0 0 1 0 0 0 1 1 0 1 最不常用算法(Least Frequently Used/LFU Algorithm) 利用链表等线性结构维护页面访问时间, 队首为最多访问次数页面(每次访问一个页面后, 访问次数+1, 并排序), 队尾为最少访问次数页面 全局置换算法 换入进程 A 的某个页面时, 可换出其他进程的某个页面: 为进程分配可变数目的页面 关键: 确定为不同进程分配的页面数目 抖动(thrashing): 进程过多, 导致大部分进程的常驻集 工作集算法 工作集(随时间动态变化集): 一个进程当前正在使用的逻辑页面集合, WorkingSet(currentTime, workingSetWindow(访问时间窗口)) (cT - wSW, cT + wSW) 根据工作集大小(逻辑页面集合), 为该进程分配常驻集(合适数目的物理页面集合): 若常驻集 > 工作集, 则缺页率较低 再额外维护一个类希 LRU 算法中的访存链表, 记录近期访问过的物理页面, 将其也加入常驻集 缺页率算法 当缺页频繁时, 缺页时将缺页的页面加入常驻集; 当缺页不频繁时, 缺页时将不属于工作集的页面移出常驻集 实现 为每个进程分配一个 vma 块, 模拟一个完整的物理内存 vmas 按起始地址从小至大形成一个双向链表, 且地址空间没有任何交集 #define VM_READ 0x00000001 #define VM_WRITE 0x00000002 #define VM_EXEC 0x00000004 #define VM_USER (VM_READ | VM_WRITE | VM_EXEC) typedef struct __mm { list_entry_t mmap_list; // header of vmas' list vma *mmap_cache; // current accessed vma(used for speed purpose) pde_t *pgdir; // PDT for vmas int map_count; // count of vmas void *sm_priv; // private data for swap manager } mm; typedef struct __vma { struct mm *vm_mm; // all vmas use the same PDT(page directory table) uintptr_t vm_start; // start address of vma (align to PGSIZE) uintptr_t vm_end; // end address of vma (align to PGSIZE) uint32_t vm_flags; // flags of vma list_entry_t vma_list; // doubly linked list: sort all vmas by start address } vma; 中断(Interrupt Service Routine/Interrupt Quest) NMI 中断(Non Maskable Interrupt) 与 INTR 中断(可屏蔽中断) x86PC 中断控制芯片: 8259A PIC 中断进入 保护现场 push PSW(Program State Word): (cs:eip + eflags) push PC(Program Counter) 中断向量表(将中断向量表对应的中断的 PSW(高 2 字节) 与 PC(低 2 字节) 先后替换原 PSW 与 PC) 系统堆栈 中断屏蔽码: n 位 2 进制数(n 为中断总数), 允许响应 n 号中断则该位置 1 程序状态字: 当前执行指令(eip) 当前指令执行情况 处理机所处状态 中断屏蔽码(程序在执行时应屏蔽的中断) 寻址方法/编址/保护键 响应中断的内容 中断实现 概述 硬件发生了某个事件后告诉中断控制器(PIC), 中断控制器汇报给 CPU CPU 从中断控制器处获取中断号, 根据中断号调用对应中断服务例程 处理完成后重新回到之前的执行流程 Interrupt 实现 发生中断, PIC 报告中断号给 CPU CPU 调用对应处理程序 irsr_x/irq_x irsr_x/irq_x 负责压入相关信息(中断号/错误码), 然后跳转至统一处理函数 common_stub common_stub: 压栈 -> 调用 fault_handler/req_handler -> 出栈 进入 handler 后, 再根据中断号/错误码(结构体)以及栈帧信息(结构体), 进行实际处理(真正处理逻辑) 在进入 handler 之前, 都是通过汇编代码进行最简单的处理(压入相关信息), 将实际中断处理逻辑放在 C 语言中, 再辅以内联汇编, 可大大地提升中断处理程序的编写效率以及中断处理程序的处理能力 系统调用 保护系统安全, 提升可靠性与安全性 调用: 用户态, 执行: 管态/内核态 进程(资源分配单位) 独立性: 无副作用(确定性), 可重现 并发性(宏观并行, 微观串行): 提升效率, 共享资源, 高度模块化 处理机(进程)的特权级 处理机的态/处理机的特权级: 根据对资源和机器指令的使用权限, 将处理执行时的工作状态区分为不同的状态 管理(supervisor mode)/系统态: 使用全部机器指令(包括特权指令), 可使用所有资源, 允许访问整个内存区, 运行系统程序 用户态: 禁止使用特权指令(I/O 设备指令, 直接修改特殊寄存器指令, 改变机器状态指令), 不可直接取用资源与改变机器状态, 只可访问自己的存储区域, 运行用户程序 用户态切换至管态: 错误/异常状态(除 0/缺页), 外部中断(I/O), 系统调用, 这一过程是由硬件完成的 进程状态/生命周期 创建, 就绪(ready), 运行(running), 等待(wait/sleeping), 挂起(suspend: 进程由内存换出至外存), 结束(抢占, 唤醒): 进程优先级与剩余内存单元在一定程度上会影响进程状态 进程首先在 cpu 初始化或者 sys_fork 的时候被创建,当为该进程分配了一个进程控制块之后,该进程进入 uninit 态 当进程完全完成初始化之后,该进程转为 runnable 态 当到达调度点时,由调度器 sched_class 根据运行队列 rq 的内容来判断一个进程是否应该被运行, 即把处于 runnable 态的进程转换成 running 状态,从而占用 CPU 执行 running 态的进程通过 wait 等系统调用被阻塞,进入 sleeping 态 sleeping 态的进程被 wakeup 变成 runnable 态的进程 running 态的进程主动 exit 变成 zombie 态, 然后由其父进程完成对其资源的最后释放,子进程的进程控制块成为 unused 所有从 runnable 态变成其他状态的进程都要出运行队列(dequeue), 反之，被放入某个运行队列中(enqueue) 进程控制块(Process Control Block) 通过组织管理 PCB(链表/索引表) 来组织管理进程; 在进程创建/终止的同时, 生成/回收改进程的 PCB: 进程信息: 名字/pid/uid 链表信息: 父进程指针/所属队列指针(就绪队列/IO 等待队列/挂起队列) CPU 调度/运行时信息: eflags/cr3/状态 内存资源信息: 堆指针/栈指针/虚拟内存页面指针 上下文信息(用于进程/上下文切换时保存/恢复上下文): trap frame/context(register files) 进程通信 直接通信: send(proc, msg), receive(proc, msg) shmctl() shm* 间接通信: send(msg_que, msg), receive(msg_que, msg) msgctl() msg* 线程(CPU 调度单位) 进程缺陷: 共享数据不便, 系统开销大 线程共享段表/共享库/数据/代码/环境变量/文件描述符集合/地址空间, 但拥有独立的堆/栈/通用寄存器 线程控制块(Thread Control Block) 用户线程与内核线程: 多为 1 对 1 idleproc(0 号内核线程) 工作就是不停地查询，直至有其他内核线程处于就绪状态, 令调度器执行那个内核线程 idleproc 内核线程是在操作系统没有其他内核线程可执行的情况下才会被调用 在所有进程中，只有 idleproc(内核创建的第一个内核线程) 没有父进程 内核线程与用户进程 内核线程只运行在内核态 用户进程会交替运行在用户态和内核态(系统调用/外设中断/异常中断) 所有内核线程直接使用共同的内核内存空间, 拥有相同的内核虚拟地址空间(包括物理地址空间) 每个用户进程拥有单独的用户内存空间(虚拟内存单元) Process 实现 process context(执行现场) 设置好执行现场后, 一旦调度器选择了 initproc 执行, 就需要根据 initproc->context 中保存的执行现场来恢复 initproc 的执行 通过 proc_run 和进一步的 switch_to 函数完成两个执行现场的切换，具体流程如下: 让 current 指向 next 内核线程 initproc 设置任务状态段 ts 中特权态 0 下的栈顶指针 esp0 为 next 内核线程 initproc 的内核栈的栈顶, 即 next->kstack + KSTACKSIZE 设置 CR3 寄存器的值为 next 内核线程 initproc 的页目录表起始地址 next->cr3 由 switch_to 函数完成具体的两个线程的执行现场切换, 即切换各个寄存器 do_fork function 分配并初始化进程控制块(alloc_proc 函数) 分配并初始化内核栈(setup_stack 函数) 根据 clone_flag 标志复制或共享进程内存管理结构(copy_mm 函数) 设置进程在内核(或用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数) 把设置好的进程控制块放入 hash_list 和 proc_list 两个全局进程链表中 把进程状态设置为“就绪”态 设置返回码为子进程的 id 号 fork() 的主要行为: 申请 pid 与进程结构 设置 ppid 为父进程的 pid 复制用户相关的字段, 如 p_pgrp/p_gid/p_ruid/p_euid/p_rgid/p_egid 复制调度相关的字段, 如 p_cpu/p_nice/p_pri 复制父进程的文件描述符(p_ofile), 并增加引用计数 复制父进程的信号处理例程(p_sigact) 通过 vm_clone(), 复制父进程的地址空间(p_vm) 复制父进程的寄存器状态(p_contxt) 复制父进程的中断上下文, 并设置 tf->eax 为 0, 使 fork()在子进程中返回 0。 do_execve function exec() 的主要行为: 读取文件的第一个块, 检查 Magic Number(NMAGIC) 是否正确 保存参数(argv)到临时分配的几个物理页, 其中的每个字符串单独一页 清空旧的进程地址空间(vm_clear()), 并结合可执行文件的 header, 初始化新的进程地址空间(vm_renew()) 将 argv 与 argc 压入新地址空间中的栈 释放临时存放参数的几个物理页 关闭带有 FD_CLOEXEC 标识的文件描述符 清理信号处理例程 通过_retu()返回用户态 处理机调度(Schedule) 从就绪队列中挑选下一个占用 CPU 的进程(挑选进程的内核函数) 从多个可用 CPU 中挑选使用 CPU 资源 调度时机 进程停止运行, 进入等待/挂起/终止状态 进程的中断请求完成时, 由等待状态进入就绪状态, 准备抢占 CPU 资源(准备从内核态返回用户态) 六大调度时机 proc.c::do_exit 用户线程执行结束,主动放弃 CPU 控制权 proc.c::do_wait 用户线程等待子进程结束,主动放弃 CPU 控制权 proc.c::init_main initproc 内核线程等待所有用户进程结束,如果没有结束,就主动放弃 CPU 控制权 initproc 内核线程在所有用户进程结束后,让 kswapd 内核线程执行 10 次，用于回收空闲内存资源 proc.c::cpu_idle idleproc 内核线程的工作就是等待有处于就绪态的进程或线程,如果有就调用 schedule 函数 sync.h::lock 在获取锁的过程中,如果无法得到锁,则主动放弃 CPU 控制权 trap.c::trap 如果在当前进程在用户态被打断,且当前进程控制块的成员变量 need_resched 设置为 1,则当前线程会放弃 CPU 控制权 调度策略/算法 算法目标 CPU 有效使用率 吞吐量(高带宽): 单位时间内完成进程数量 等待时间(低延迟): 进程在就绪队列等待总时间 周转时间(低延迟): 进程从初始化到结束总时间 响应时间(低延迟): 从提交请求到产生响应总时间 先来先服务算法(First Come First Served/FCFS) 依次执行就绪队列中的各进程(先进入就绪队列先执行) CPU 利用率较低 短进程优先算法(Shortest Process Next/Shortest Remaining Time) 优先执行周转耗时/剩余耗时最短的进程 若短进程过多, 则导致长进程一直无法执行 最高响应比优先算法(Highest Response Ratio Next) R = (waitTime + serviceTime) / serviceTime: 已等待时间越长, 优先级上升 修正短进程优先算法的缺点 时间片轮转算法(Round Robin) 在 FCFS 基础上, 设定一个基本时间单元, 每经过一个时间单元, 轮转至下一个先到进程(并进行循环轮转) 额外的上下文切换 时间片合适大小: 10 ms 多级队列调度算法(MQ) 将就绪队列分成多个独立子队列, 每个队列可采取不同调度算法 前台交互队列使用时间片轮转算法, 后台 IO 队列使用先来先服务算法 队列间使用时间片轮转算法 多级反馈队列算法(MLFQ) 优先级高的子队列时间片小, 优先级低的子队列时间片大 CPU 密集型进程(耗时高)优先级下降很快 IO 密集型进程(耗时低)停留在高优先级 同步互斥 互斥(mutual exclusion) 死锁(deadlock) 饥饿(starvation) 临界区的访问原则 空闲则入 忙则等待 有限等待 基于软件方法的同步互斥 int turn; // 表示谁该进入临界区 bool flag[]; // 表示进程是否准备好进入临界区 // 对于 2 个线程的情况 // Peterson Algorithm // 线程 i flag[i] = true; turn = j; // 后设置 turn 标志的进程不可进入临界区, 会在 while 循环进行等待 while (flag[j] && turn == j) ; ...// critical section flag[i] = false; // Dekkers Algorithm // 线程 i turn = 0; flag[] = {false}; do { flag[i] = true; while (flag[j] == true) { if (turn != i) { flag[i] = false; while (turn != i) ; flag[i] = true; } } // critical section turn = j; flag[i] = false; } while (true); 高级抽象的同步互斥 利用原子操作实现互斥数据结构 lock/semaphore struct lock/semaphore { bool locked/sem = n; // n: 并发数/可用资源数 wait_queue q; void acquire/prolaag() { locked/sem--; if (locked/sem monitor 与 semaphore 相反, 初始 0, wait(++ && sleep), signal(-- && wakeup) 管程内可以中断执行, 并 notify 其他等待线程 死锁 非抢占持有互斥循环等待 mutex 实现 P/V 操作 具体实现信号量的 P 操作 关中断 判断当前信号量的 value 是否大于 0 如果是>0，则表明可以获得信号量，故让 value 减一，并打开中断返回 如果不是>0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行 如果被 V 操作唤醒，则把自身关联的 wait 从等待队列中删除（此过程需要先关中断，完成后开中断） 具体实现信号量的 V 操作 关中断 如果信号量对应的 wait queue 中没有进程在等待，直接把信号量的 value 加一，然后开中断返回 如果有进程在等待且进程等待的原因是 semophore 设置的, 则调用 wakeup_wait 函数将 waitqueue 中等待的第一个 wait 删除, 且把此 wait 关联的进程唤醒, 最后开中断返回 管程 管程由四部分组成： 管程内部的共享变量(mutex): 一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质 管程内部的条件变量: 通过执行 wait_cv,会使得等待某个条件 C 为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行; 而进入管程的某进程设置条件 C 为真并执行 signal_cv 时，能够让等待某个条件 C 为真的睡眠进程被唤醒，从而继续进入管程中执行 管程内部并发执行的进程 对局部于管程内部的共享数据设置初始值的语句 成员变量信号量 next: 配合进程对条件变量 cv 的操作而设置的, 由于发出 signal_cv 的进程 A 会唤醒睡眠进程 B, 进程 B 执行会导致进程 A 睡眠，直到进程 B 离开管程，进程 A 才能继续执行，这个同步过程是通过信号量 next 完成 整形变量 next_count: 表示由于发出 singal_cv 而睡眠的进程个数 typedef struct monitor{ // the mutex lock for going into the routines in monitor, // should be initialized to 1 semaphore_t mutex; // the next semaphore is used to down the signaling proc itself, // and the other OR wakeuped semaphore_t next; int next_count; // the number of of sleeped signaling proc condvar_t *cv; // the condvars in monitor } monitor_t; Conditional Variable wait_cv： 被一个进程调用, 以等待断言 Pc 被满足后该进程可恢复执行. 进程挂在该条件变量上等待时, 不被认为是占用了管程 signal_cv：被一个进程调用, 以指出断言 Pc 现在为真, 从而可以唤醒等待断言 Pc 被满足的进程继续执行 信号量 sem: 用于让发出 wait_cv 操作的等待某个条件 C 为真的进程睡眠, 而让发出 signal_cv 操作的进程通过这个 sem 来唤醒睡眠的进程 count: 表示等在这个条件变量上的睡眠进程的个数 owner: 表示此条件变量的宿主是哪个管程 typedef struct condvar{ // the sem semaphore is used to down the waiting proc, // and the signaling proc should up the waiting semaphore_t sem; proc int count; // the number of waiters on condvar monitor_t * owner; // the owner(monitor) of this condvar } condvar_t; 文件系统 (FileSystem) 分配文件磁盘空间: 分配与管理 管理文件集合: 定位, 命名, 文件系统结构 数据可靠和安全: 持久化保存, 防止数据丢失(系统崩溃时) 基本操作单位: 数据块 文件访问模式: 顺序访问/随机访问/索引访问 文件系统种类: 磁盘/数据库/日志/网络/分布式/虚拟文件系统 文件组成 文件头: 文件属性(名称/类型/大小/权限/路径/创建者/创建时间/最近修改时间) 文件头: 文件存储位置与顺序 文件体: 实际字节序列 文件系统基本数据结构 superblock -> dentry -> vnode/inode 文件卷控制块(superblock) 每个文件系统只有一个控制块 描述该文件系统全局信息: 数据块(大小等信息), 空余块信息, 文件指针/引用计数 目录项(dentry) 目录是一类特殊的文件: 其内容为文件索引表(文件名/文件指针), 内部采取哈希表存储 目录与文件构成树状结构 每个目录项属于一个目录, 一个目录可有多个目录项 保存目录相关信息: 指向文件控制块, 父目录/子目录信息 文件控制块(vnode/inode) 每个文件有一个文件控制块 保存该文件详细信息: 访问权限, 所属者/组, 文件大小, 数据块位置(索引) 文件描述符 操作系统在打开文件表中维护的打开文件状态与信息: 文件指针: 最近一次读写位置 文件打开计数(引用计数): 引用计数为 0 时, 回收相关资源 文件磁盘位置 访问权限 打开文件表 系统打开文件表: 保存文件描述符 进程打开文件表: 指向系统打开文件表某项, 并附加额外信息 文件分配 分配方式: 连续分配, 琏式分配, 索引分配 琏式索引分配: 琏式链接多个索引块 多级索引分配: 索引分配 + 多级琏式索引块 空闲空间管理 bit 位图, 链表, 琏式索引: 保存空闲数据块位置与顺序 冗余磁盘阵列(Redundant Array of Inexpensive Disks/RAID) RAID-0: 磁盘条带化 RAID-1: 磁盘镜像(冗余拷贝), 提高可靠性 RAID-4: 带奇偶校验(校验和)的磁盘条带化, 提高可靠性 RAID-5: 带分布式奇偶校验的磁盘条带化, 减少校验和所在物理磁盘的读写压力 RAID-6: 每组条带块有两个冗余块, 可以检查到 2 个磁盘错误 FS 实现 Mount sfs_do_mount函数中: 完成了加载位于硬盘上的 SFS 文件系统的超级块 superblock 和 freemap 的工作 l 在内存中有了 SFS 文件系统的全局信息 index 对于普通文件，索引值指向的 block 中保存的是文件中的数据 对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组 inode 内存 inode 包含了 SFS 的硬盘 inode 信息, 而且还增加了其他一些信息, 这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用. 一个内存 inode 是在打开一个文件后才创建的, 如果关机则相关信息都会消失. 而硬盘 inode 的内容是保存在硬盘中的, 只是在进程需要时才被读入到内存中, 用于访问文件或目录的具体内容数据. struct inode { union { //包含不同文件系统特定inode信息的union成员变量 struct device __device_info; //设备文件系统内存inode信息 struct sfs_inode __sfs_inode_info; //SFS文件系统内存inode信息 } in_info; enum { inode_type_device_info = 0x1234, inode_type_sfs_inode_info, } in_type; //此inode所属文件系统类型 atomic_t ref_count; //此inode的引用计数 atomic_t open_count; //打开此inode对应文件的个数 struct fs *in_fs; //抽象的文件系统，包含访问文件系统的函数指针 const struct inode_ops *in_ops; //抽象的inode操作，包含访问inode的函数指针 }; struct inode_ops { unsigned long vop_magic; int (*vop_open)(struct inode *node, uint32_t open_flags); int (*vop_close)(struct inode *node); int (*vop_read)(struct inode *node, struct iobuf *iob); int (*vop_write)(struct inode *node, struct iobuf *iob); int (*vop_getdirentry)(struct inode *node, struct iobuf *iob); int (*vop_create)( struct inode *node, const char *name, bool excl, struct inode **node_store); int (*vop_lookup)(struct inode *node, char *path, struct inode **node_store); …… }; Device 利用 vfs_dev_t 数据结构， 就可以让文件系统通过一个链接 vfs_dev_t 结构的双向链表找到 device 对应的 inode 数据结构， 一个 inode 节点的成员变量 in_type 的值是 0x1234， 则此 inode 的成员变量 in_info 将成为一个 device 结构。 这样 inode 就和一个设备建立了联系，这个 inode 就是一个设备文件 设备管理详解 CPU 一般都是通过寄存器的形式来访问外部设备 外设的寄存器通常包括控制寄存器、状态寄存器与数据寄存器三类, 分别用于发送命令/读取状态/读写数据. CGA/EGA + Chromatext video buffer 在内存的低 1MB 中, 有许多地址被映射至外部设备, 其中就包含文字显示模块(显卡控制显示器): 从 0xB8000 开始, 每 2 个字节表示屏幕上显示的一个字符(80 x 25) 前一个字节为 字符 ASCII 码, 后一个字节为 字符颜色和属性的控制信息 (back_twinkle, back_r, back_g, back_b, front_light, front_r, front_g, front_b) I/O 调用 io_delay() 函数: 对于一些老式总线的外部设备, 读写 I/O 端口的速度若过快就容易出现丢失数据的现象 实践 工具 Bochs Installation wget \\ http://sourceforge.net/projects/bochs/files/bochs/2.5.1/bochs-2.5.1.tar.gz/download \\ -O bochs.tar.gz tar -xvfz bochs.tar.gz cd bochs-2.5.1 ./configure --enable-debugger --enable-debugger-gui --enable-disasm --with-x --with-term make sudo cp ./bochs /usr/bin/bochs-dbg Config # BIOS与VGA镜像 romimage: file=/usr/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latest # 内存大小 megs: 128 # 软盘镜像 floppya: 1_44=bin/kernel.images, status=inserted # 硬盘镜像 ata0-master: type=disk, path=\"bin/rootfs.images\", \\ mode=flat, cylinders=2, heads=16, spt=63 # 引导方式(软盘) boot: a # 日志输出 log: .bochsout panic: action=ask error: action=report info: action=report debug: action=ignore # 杂项 vga_update_interval: 300000 keyboard_serial_delay: 250 keyboard_paste_delay: 100000 mouse: enabled=0 private_colormap: enabled=0 fullscreen: enabled=0 screenmode: name=\"sample\" keyboard_mapping: enabled=0, map= keyboard_type: at # 符号表(调试用) debug_symbols: file=main.sym # 键盘类型 keyboard_type: at Run bochs -q -f .bochsrc b,vb,lb 分别为物理地址、虚拟地址、逻辑地址设置断点 c 持续执行，直到遇到断点或者错误 n 下一步执行 step 单步执行 r 显示当前寄存器的值 sreg 显示当前的段寄存器的值 info gdt, info idt, info tss, info tab 分别显示当前的 GDT、IDT、TSS、页表信息 print-stack 打印当前栈顶的值 help 显示帮助 GNU ld ENTRY(kmain) SECTIONS { __bios__ = 0xa0000; # 绑定BIOS保留内存的地址到__bios__ vgamem = 0xb8000; # 绑定vga缓冲区的地址到符号vgamem .text 0x100000 : { # 内核二进制镜像中的.text段(Section)，从0x100000开始 __kbegin__ = .; # 内核镜像的开始地址 __code__ = .; bin/entry.o(.text) bin/main.o(.text) *(.text); # 将bin/entry.o中的.text段安排到内核镜像的最前方 . = ALIGN(4096); # .text段按4kb对齐 } .data : { __data__ = .; *(.rodata); *(.data); . = ALIGN(4096); } .bss : { __bss__ = .; *(.bss); . = ALIGN(4096); } __kend__ = .; # 内核镜像的结束地址 } © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/softwareTesting/softwareTestingBasicNotes.html":{"url":"computerScience/softwareTesting/softwareTestingBasicNotes.html","title":"Software Testing Basic Notes","keywords":"","body":"Notes Notes 测试模型 PIE 模型 启发式测试策略模型(Heuristic Test Strategy Model)——软件功能测试(难以实现完全自动化) 用户体验测试(对软件功能测试的有益补充) 测试规模 基础概念 测试方法 图结构覆盖方法 数据流覆盖方法 逻辑覆盖方法 随机测试方法 黑盒/组合测试方法 定位 Fault 模糊测试 移动设备:(机型,屏幕,环境)碎片化 ，耗电量 Useful Demos/Tools 测试模型 PIE 模型 (Execution)Fault,(Infection)Error,(Propagation)Failure 启发式测试策略模型(Heuristic Test Strategy Model)——软件功能测试(难以实现完全自动化) 关注价值(Value)：用户得到价值 风险驱动(Risk)：降低价值/用户体验的风险项 产品元素(Product Elements) 结构(Structure):产品物理元素(如代码、硬件、配置文件) 功能(Function):产品功能 数据(Data):产品所操作的数据(如输入、输出) 接口(Interface):产品所使用/暴露出的接口 平台(Platform):产品所依赖的外部元素(如操作系统、输入/输出设备) 操作(Operation):产品被使用的方式(如键盘、鼠标、触摸等命令操作) 时间(Time):影响产品的时间因素 组合元素:测试产品功能间协作 用户体验测试(对软件功能测试的有益补充) 功能性体验 易用性体验 性能体验 可靠性体验(如软件兼容性) 测试规模 Unit/Module/Integration/System Testing 基础概念 测试路径:起始顶点至终止顶点 测试方法 图结构覆盖方法 顶点覆盖,边覆盖,边对覆盖(三顶点,两邻边) VC/EC/EPC 法 数据流覆盖方法 数据流覆盖:定义处覆盖,使用处覆盖 DU 法(Data&Use) 逻辑覆盖方法 逻辑覆盖:条件处覆盖,判定处覆盖 DC(Decision),CC(Condition)法 MC/DC 法 MCC 法(完全覆盖) 随机测试方法 ART(随机测试):每个用例间\"距离\"尽可能远 黑盒/组合测试方法 等价类划分:合法输入(软件功能),非法输入(异常处理) 等价类的边界值分析:合法 MIN,MIN+,MAX-,MAX 非法:MIN-,MAX+ 决策表+组合测试:简化决策表(考虑输入相关性) 组合用例:维度与测试准度成正比 约束用例:需避开约束输入(输入相关性,同时输入会成为无效输入) 测试用例约简+测试用例优先级:额外贪心算法进行化简+排序测试用例求得近似解 定位 Fault 代码可疑度= (失败测试用例经过数/失败测试用例总数)/ (成功测试用例经过数/成功测试用例总数+失败测试用例经过数/失败测试用例总数) 即在执行过目标代码的测试用例中失败测试用例占比 模糊测试 Fuzzing - 是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法 移动设备:(机型,屏幕,环境)碎片化 ，耗电量 Useful Demos/Tools JUnit SeleniumIDE PICT GuiTar Randoop 压力测试(Apache Jmeter) 移动测试(Monkey:Random Testing) © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/virtualization/virtBasicNotes.html":{"url":"computerScience/virtualization/virtBasicNotes.html","title":"Virt Basic Notes","keywords":"","body":"Virtualization Basic Notes Virtualization Basic Notes How to read paper LXC Linux Namespaces chroot Control Groups (cgroups) In-memory Computing Thesis Notes 单节点内存计算 内存存储系统 内存数据处理系统 内存压缩技术 提升 I/O 访问效率 分布式内存计算 分布式内存存储系统 内存缓存系统 分布式内存数据处理系统 混合内存计算 Hadoop Thesis Notes Google File System 基本设计 元数据 Chunk 尺寸 一致性模型 Chunk 副本修改一致性 系统交互 租约机制 数据流 原子追加操作 快照 Master 节点 名称空间锁 Chunk 副本平衡 垃圾回收 容错性 MapReduce Google Bigtable 数据模型 行 列族 时间戳 依赖 SSTable Chubby 组件 Master 服务器 Tablet 服务器 实现 定位 服务 Unikernel Unikernels Security Debug Limits Ecosystem ClickOS Rumprun OSv Mini-OS Xen Unik libOS OPAM MirageOS (Exokernel -> Library Operating System -> Unikernel) Installation Development Use of OCaml Concurrency Thread Flow Device Drivers I/O Stack Xen Soft Device Device Access in Xen Memory Management Direct Segment Large Pages Shortcoming Big-memory workload analysis Hardware Support Software Support Virtual Machines with direct-segment Results Redundant Memory Mappings (RMM) Old Methods multipage mapping transparent huge pages direct segment New Methods RMM Benefits Range Translation Range Table Contiguous Memory Allocation How to read paper abstract, introduction, related works, conclusion reference paper refers it (by Google Scholar) LXC Linux Namespaces LXC 所实现的隔离性主要是来自内核的命名空间 PID Namespace: 隔离进程 Network Namespace: 隔离网络 IPC Namespace: 隔离消息 Mount Namespace: 隔离文件系统 UTS Namespace: 隔离 hostname Users Namespace package main import ( \"log\" \"os\" \"os/exec\" \"syscall\" ) func main() { switch os.Args[1] { case \"run\": run() case \"child\": child() default: log.Fatal(\"Invalid command\") } } func run() { cmd := exec.Command(\"/proc/self/exe\", append([]string{\"child\"}, os.Args[2:]...)...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr = &syscall.SysProcAttr { Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER, Credential: &syscall.Credential{Uid: 0, Gid: 0}, UidMappings: []syscall.SysProcIDMap{ {ContainerID: 0, HostID: os.Getuid(), Size: 1}, }, GidMappings: []syscall.SysProcIDMap{ {ContainerID: 0, HostID: os.Getgid(), Size: 1}, }, } must(cmd.Run()) } func child() { log.Printf(\"running %v as PID %d\\n\", os.Args[2:], os.Getpid()) // cg() cmd := exec.Command(os.Args[2], os.Args[3:]...) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr must(syscall.Sethostname([]byte(\"mocker\"))) must(syscall.Chroot(\"/home/sabertazimi/rootfs\")) must(syscall.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) must(cmd.Run()) must(syscall.Unmount(\"proc\", 0)) } func must(err error) { if err != nil { log.Fatal(err) } } chroot must(syscall.Chroot(\"/home/sabertazimi/rootfs\")) must(syscall.Chdir(\"/\")) must(syscall.Mount(\"proc\", \"proc\", \"proc\", 0, \"\")) Control Groups (cgroups) resources limitation: CPU, Memory, Disk I/O, Process numbers, Network, Device func cg() { cgroups := \"/sys/fs/cgroup/\" pids := filepath.Join(cgroups, \"pids\") os.Mkdir(filepath.Join(pids, \"sabertazimi\"), 0755) must(ioutil.WriteFile(filepath.Join(pids, \"sabertazimi/pids.max\"), []byte(\"20\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"sabertazimi/notify_on_release\"), []byte(\"1\"), 0700)) must(ioutil.WriteFile(filepath.Join(pids, \"sabertazimi/cgroup.procs\"), []byte(strconv.Itoa(os.Getpid())), 0700)) } 大数据处理典型问题: 数据一致性问题 数据容错与恢复问题 节点通信问题 能耗问题 In-memory Computing Thesis Notes 内存计算特点: 硬件: 大内存 软件: 良好编程模型和编程接口 面向数据密集型应用: 数据规模大, 实时性要求高 大多支持并行处理数据 内存计算分类: 单节点 分布式集群 新型混合内存 (Hybrid Memory) 单节点内存计算 节点拥有 1/n 个处理器(单/多核) + 共享内存 (Shared Memory) 内存存储系统 内存数据处理系统 内存压缩技术 提升 I/O 访问效率 分布式内存计算 容错与恢复 同步与一致性 内存分配与管理 网络瓶颈 分布式内存存储系统 内存压缩技术 内存缓存系统 内存替换策略: LRU, LFU 预取技术 分布式内存数据处理系统 Spark 混合内存计算 铁电存储器: ferroelectric random accessmemory, 简称 FeRAM 相变存储器: phase change memory, 简称 PCM 电阻存储器: resistive randomaccess memory, 简称 RRAM Hadoop Thesis Notes Google File System 基本设计 迅速地侦测、冗余并恢复失效的组件 存储一定数量的大文件 大规模的流式读取 小规模的随机读取 大规模的、顺序的、数据追加方式的写操作 小规模的随机位置写入操作 高性能的稳定网络带宽远比低延迟重要 客户端和 Master 节点的通信只获取元数据，所有的数据操作都是由客户端直接和 Chunk 服务器进行交互的 无论是客户端还是 Chunk 服务器都不需要缓存文件数据 出于可靠性的考虑, 每个块都会复制到多个块服务器上.缺省情况下, 我们使用 3 个存储复制节点. 元数据 Master 节点主要存储三种类型元数据 (保存在内存中, 轮询 Chunk 服务器/周期心跳信息来更新元数据): 文件和 Chunk 的命名空间 文件和 Chunk 的对应关系 每个 Chunk 副本的存放地点 元数据操作日志: 先写日志再响应请求 Checkpoint 文件 Chunk 尺寸 较大的 Chunk 尺寸: 降低元数据读取工作和缓存工作成本 多次操作集中在少数 Chunk 上 一致性模型 Chunk 副本修改一致性 对 Chunk 的所有副本的修改操作顺序一致 根据版本号判断 Chunk 是否失效 (未成功进行某次修改), 使用垃圾收集系统回收失效 Chunk 当某个 Chunk 副本失效, 称为不可用; 当所有 Chunk 副本失效, 称为损坏 系统交互 原则: 减小 Master 负担 租约机制 Master 为某个 Chunk 建立租约, 称为主 Chunk: 修改顺序由主 Chunk 进行管理, 从而减小 Master 管理负担: Client 与 Master 通信, 获取主 Chunk 信息 Client 将数据传至所有 Chunk 副本 Client 将操作发送至主 Chunk 主 Chunk 为所有操作分配连续的序列号, 所有副本按照序列号顺序执行操作, 并在完成后回复主 Chunk 主 Chunk 回复 Client 实际上, 客户端通常会在一次请求中查询多个 Chunk 信息, Master 节点的回应也可能包含了紧跟着这些被请求的 Chunk 后面的 Chunk 的信息. 在实际应用中, 这些额外的信息在没有任何代价的情况下, 避免了客户端和 Master 节点未来可能会发生的几次通讯. 数据流 链式顺序最近推送原则: 推送至距离最近 (IP 地址) 的一个下游 原子追加操作 GFS 并不保证 Chunk 的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次 快照 copy-on-write 技术实现快照 当 Master 节点收到一个快照请求，它首先取消作快照的文件的所有 Chunk 的租约。这个措施保证了后续对这些 Chunk 的写操作都必须与 Master 交互以找到租约持有者 Master 节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的 Chunk 地址。 确保数据在本地复制而不是通过网络复制 Master 节点 Master 节点管理所有的文件系统元数据 元数据包括: 名字空间 访问控制信息 文件和 Chunk 的映射信息 当前 Chunk 的位置信息 Master 节点基本工作: 执行所有的名称空间操作 管理着整个系统里所有 Chunk 的副本: 决定 Chunk 的存储位置, l创建新 Chunk 和它的副本, 协调各种各样的系统活动以保证 Chunk 被完全复制, 在所有的 Chunk 服务器之间的进行负载均衡, 回收不再使用的存储空间 名称空间锁 每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁. 目录名的读取锁足以的防止目录被删除、改名以及被快照. 文件名的写入锁序列化文件创建操作, 确保不会多次创建同名的文件. Chunk 副本平衡 平衡硬盘使用率 限制同一台 Chunk 服务器上的正在进行的克隆操作的数量 在机架间分布副本 垃圾回收 回收过期(版本号不一致)和损坏的 Chunk. GFS 空间回收采用惰性的策略: 只在文件和 Chunk 级的常规垃圾收集时进行真正的删除操作. 垃圾回收把存储空间的回收操作合并到 Master 节点规律性的后台活动中(例行扫描和与 Chunk 服务器握手). 容错性 快速自启动 Chunk 副本 Master 服务器副本 Chunk Checksum 检验数据完整性 MapReduce 分割输入数据 (数据分布) 集群调度 (负载均衡) 错误处理 (容错) 集群通信 用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从 16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量 的程序副本。 这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配 任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配 给一个空闲的 worker。 被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key/value pair，然后把 key/value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key/value pair，并缓存在内存中。 缓存中的 key/value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的 key/value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给 Reduce worker。 当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在 主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序 后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上， 因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。 Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这 个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追 加到所属分区的输出文件。 当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对 MapReduce 调用才返回。 Google Bigtable Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序, Map: (row: string, column: string, time: int64) -> string. 数据模型 行 对同一个行关键字的读或者写操作都是原子的 Bigtable 通过行关键字的字典顺序来组织数据 表中的每个行都可以动态分区, 每个分区叫做一个 \"Tablet\" Tablet 是数据分布和负载均衡调整的最小单位 列族 列关键字组成的集合叫做 \"列族\", 列族是访问控制的基本单位 存放在同一列族下的所有数据通常都属于同一个类型 访问控制、磁盘和内存的使用统计都是在列族层面进行的 时间戳 在 Bigtable 中, 表的每一个数据项都可以包含同一份数据的不同版本 不同版本的数据通过时间戳来索引 依赖 SSTable BigTable 内部存储数据的文件是 Google SSTable 格式的, SSTable 是一个持久化的、排序的、不可更改的 Map 结构 SSTable 使用块索引（通常存储在 SSTable 的最后）来定位数据块 在打开 SSTable 的时候，索引被加载到内存 每次查找都可以通过一次磁盘搜索完成: 首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相应的数据块 Chubby Bigtable 使用 Chubby 完成以下的几个任务： 确保在任何给定的时间内最多只有一个活动的 Master 副本 存储 BigTable 数据的自引导指令的位置 查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后 存储 BigTable 的模式信息(每张表的列族信息) 存储访问控制列表 组件 Bigtable 包括了三个主要的组件: 链接到客户程序中的库、一个 Master 服务器和多个 Tablet 服务器 Master 服务器 Master 服务器主要负责以下工作： 为 Tablet 服务器分配 Tablets 检测新加入的或者过期失效的 Table 服务器 对 Tablet 服务器进行负载均衡 对保存在 GFS 上的文件进行垃圾收集 处理对模式的相关修改操作, 例如建立表和列族 Tablet 服务器 每个 Tablet 服务器都管理一个 Tablet 的集合（通常每个服务器有大约数十个至上千个 Tablet） 每个 Tablet 服务器负责处理它所加载的 Tablet 的读写操作 在 Tablets 过大时，对其进行分割 实现 定位 使用三层 B+ 树结构存储 Tablets 的位置信息 (位于哪个 Tablet 服务器上) MetaTablet 中 的 row key 是通过 table id 和 end row 来计算出的: 因为 row 是有序的, 所以在读取 row/column 型的数据时可以利用到有序性. 服务 当写入表时, 先写日志, 再写入内存中的 memtable, 当其大小达到阈值后, 写入 GFS 中 (以 SSTable 存储) 利用 Log-Structured Merge Tree 来表示 memtable 和 SSTable 之间的关系 (内存数据滚动合并至磁盘) 对于一致性的处理，将 SSTable 不可改变化，然后对 memtable 使用 copy-on-write 技术实现读写并行 Unikernel 小、简单、安全、高效 Fast, Small, Secure Workloads Containers are Smaller and Faster, but Security is Still an Issue SELinux: 在一个开启了 SELinux 的内核中, 可能存在 10 万条以上的安全策略, 有时无法正常启动服务 (缺少权限) Unikernels Unikernels do at compile time what standard programs do at runtime: Most unikernels use a specialized compiling system that compiles in the low-level functions the developer has selected The code for these low-level functions is compiled directly into the application executable through a library operating system library operating system: a special collection of libraries that provides needed operating system functions in a compilable format Security There is no command shell to leverage There are no utilities to co-opt There are no unused device drivers or unused libraries to attack There are no password files or authorization information present There are no connections to machines and databases not needed by the application Debug Since there is no operating system environment on a unikernel production VM, there are no tools, no debuggers, no shell access with which someone can probe a failure on a deployed program. Instead, all that can be done is to engineer the executable to log events and data so that the failure might be reconstructed on a development system, which still has access to all the debugging tools needed. People in our industry have successfully debugged failures of complex software for years without direct access to production systems, and I see no reason why they will fail to do so now. Limits Single Process (but Multiple Threads) Single User Limited Debugging Impoverished Library Ecosystem Ecosystem ClickOS network function virtualization (NFV) devices Rumprun compile most of the programs found on a Linux or Unix-like operating system as unikernels OSv It is unique among existing unikernels in that it provides a general-purpose unikernel base that can accept just about any program that can run in a single process (multiple threads are allowed, but multiple processes are not). As a result, OSv is a \"fat\" unikernel: the results are measured in megabytes, rather than kilobytes. Mini-OS Mini-OS is a tiny OS kernel distributed with the Xen Project Hypervisor sources: used as operating system for stub domains that are used for Dom0 Disaggregation. used as a basis for development of Unikernels, having been instrumental in the formation of multiple examples including ClickOS and Rump kernels. Xen Its paravirtualization capabilities allow unikernels to have a very small and efficient footprint interfacing with devices. This is one reason why the Xen Project has been at the forefront of unikernel development. Xen team has been consciously reworking the hypervisor’s capabilities so it can handle a future state where 2,000 or 3,000 simultaneous unikernel VMs may need to coexist on a single hardware host server. Currently, the hypervisor can handle about 1,000 unikernels simultaneously before scaling becomes nonlinear. The development work continues to improve unikernel support in each release. Unik UniK is an open source tool written in Go for compiling applications into unikernels and deploying those unikernels. UniK utilizes a simple Docker-like command-line interface, making developing on unikernels as easy as developing on containers. libOS implement drivers for the virtual hardware devices provided by the hypervisor create the protocol libraries to replace the services of a traditional OS the kernel is event-driven via an I/O loop that polls Xen devices OPAM modern modular, functional and type-safe programming language opam install opam update -u opam switch opam remote opam depext MirageOS (Exokernel -> Library Operating System -> Unikernel) Unikernels: specialised, sealed, singlepurpose libOS VMs that run directly on the hypervisor A libOS is structured very differently from a conventional OS: all services, from the scheduler to the device drivers to the network stack, are implemented as libraries linked directly with the application. Coupled with the choice of a modern statically type-safe language for implementation, this affords configuration, performance and security benefits to unikernels. the current release contains clean-slate libraries for TLS, TCP/IP, DNS, Xen network and storage device drivers, HTTP and other common Internet protocols. Installation opam init opam remote ocaml -version opam switch 4.04.2 eval `opam config env` opam list opam install mirage mirage --help mirage configure --xen make depend make sudo xl create -c console.xl strip console.xen bzip2 -9 console.xen Development opam source repo.name --dev-repo --pin Use of OCaml OCaml is a pragmatic system that strikes a balance between imperative languages, e.g., C, and pure functional languages, e.g., Haskell. It features type inference, algebraic data types, and higher-order functions, but also permits references and mutable data structures while guaranteeing that all such side-effects are always typesafe and will never cause memory corruption. (ICFP'10) a full-fledged systems programming language with a flexible programming model that supports functional, imperative and object-oriented programming OCaml has a simple yet high performance runtime making it an ideal platform for experimenting with the unikernel abstraction that interfaces the runtime with Xen. static typing eliminates type information at compile-time while retaining all the benefits of type-safety (remove dynamic typing overheads and introduce more safety at compile time). (SOSP'03/11) the open-source Xen Cloud Platform and critical system components are implemented in OCaml, making integration straightforward. Concurrency lightweight control-flow threads for managing I/O and timeouts optimised inter-VM communication for parallel computation Each Mirage instance runs as on a single CPU core. Communication is optimised dynamically: if the VMs are running on the same physical machine, Mirage uses shared memory channels instead of the network stack. Thread Flow The application’s main thread is launched immediately after boot and the VM shuts down when it returns. Mirage provides an evaluator that uses domainpoll to listen for events and wake up lightweight threads. The VM is thus either executing OCaml code or blocked, with no internal preemption or asynchronous interrupts. The main thread repeatedly executes until it completes or throws an exception, and the domain subsequently shuts down with the VM exit code matching the thread return value. Device Drivers Data arrives to both the network and storage stacks as a stream of discrete packets. Mirage bridges the gap between packets and streams by using channel iteratees that map functions over infinite streams of packets to produce a typed stream. I/O Stack Mirage implements a Xen blkfront VFS which interacts directly with a block device without an intervening filesystem. Xen Soft Device Device-level interfaces in operating systems present a very useful cut-point for researchers to experiment with new ideas. By virtualizing these interfaces, developers can create soft devices, which are used in the same way as normal hardware devices, but provide extra functionality in software. Rather than attempting to present a fully virtualized hardware interface to each OS in a Xen environment, guest OSes are modified to use a simple, narrow and idealized view of hardware. Soft devices take advantage of these narrow interface to capture and transform block requests, network packets, and USB messages. Device Access in Xen Physical driver runs in an isolated VM, connected over a shared memory device channel to a guest VM accessing the device. Operating systems wishing to access the device will use a front-end driver, and interact with the back-end driver over a device channel, which is a shared-memory communications primitive (原语). Memory Management Direct Segment In light of the high cost of page-based virtual memory and its significant mismatch to “big-memory” application needs, we propose mapping part of a process’s linear virtual address with a direct segment rather than pages. Mapping part of a process’s linear virtual address space with a direct segment, while page mapping the rest of the virtual address space: retains a standard linear virtual address space is not overlaid on top of paging coexists with paging of other virtual addresses a one-time fixed-cost solution for any size memory Large Pages Shortcoming Being a cache, TLBs are reliant on memory-access locality to be effective and it can be a mismatch for future big-memory workloads with poor locality efficient TLB support for multiple page sizes is difficult large page sizes are often few and far apart (not enough for big-memory workload) Big-memory workload analysis While address translation can be accelerated by TLB hits, misses are costly, taking up to 100s of cycles A sparse memory access pattern can result in more misses with fewer TLB entries For the majority of their address space, big-memory workloads do not require: swapping fragmentation mitigation fine-grained per-page protection Big-memory workloads pay a cost of pagebased virtual memory: substantial performance lost to TLB misses Big-memory workloads are long-running programs, receive little benefit from virtual memory optimizations whose primary goal is to allow quick program startup, such as demand paging Big-memory workloads cosume almost all memory resources, are sized to match memory capacity Big-memory workloads isolate from other services, have one (or a few) primary process(es) Hardware Support direct segments add three registers per core as follows: BASE holds the start address of the contiguous virtual address range mapped through direct segment LIMIT holds the end address of the virtual address range mapped through direct segment OFFSET holds the start address of direct segment’s backing contiguous physical memory minus the value in BASE. Direct segments are aligned to the base page size, so page offset bits are omitted from these registers (e.g., 12 bits for 4KB pages) Without real direct-segment hardware, we emulate directsegment functionalities using 4KB pages More specifically, we modify Linux’s page fault handler so that on a page fault within the primary region it calculates the corresponding physical address from the faulting virtual page number. If VAfault is the 4KB page-aligned virtual address of a faulting page, then our modified page-fault handler first checks if BASE ≤ VAfault Software Support The prototype implementation is simplified by assuming that only one process uses a direct segment at any time (called the primary process) A primary region is a contiguous range of virtual addresses in a process’s address space with uniform read-write access permission fine-grain protection, sparse allocation, swapping, and demand paging are not guaranteed for memory allocated within the primary region managing physical memory: create contiguous physical memory dynamically through periodic memory compaction managing direct-segment registers: When the OS dispatches a thread; it loads the BASE, LIMIT, and OFFSET values from the PCB Growing and shrinking direct segment (by updating direct-segment registers and page table entries) Virtual Machines with direct-segment In a virtualized environment the memory accesses goes through two levels of address translations: guest virtual address (gVA) to guest physical address (gPA) guest physical address (gPA) to system physical address (sPA) Results In x86-64, page table entries (PTEs) have a set of reserved bits (41-51 in our test platform) that cause a trap when loaded into the TLB Redundant Memory Mappings (RMM) 在大内存系统中, 传统的段页式虚存管理技术存在性能问题 (TLBs 的有限性能): 由于 TLBs 不再能覆盖工作集 (working sets: 指活动频繁的页表集), 导致 TLB 缺失 (TLB misses) 急剧上升 在传统内存层次中, 利用 TLBs 完成地址转换后 (虚拟地址 -> 物理地址), 需要从 L1 Cache 开始进行缓存标签匹配, 查看所需内存数据是否已在缓存上. 因此，随意地增大 TLB 的大小以降低 TLB 缺失的方法会影响到所有内存操作的性能 (遍历 TLB 表耗时增大) The amount of memory accessible from the TLB or The working set of each process is stored in the TLB: TLB Reach = (TLB Size) X (Page Size) Old Methods clustered TLBs/multipage mappings: mapping multiple pages per page table entry transparent huge pages/superpaging: 使得每个页表项覆盖更大的内存; 但受限于架构, 页面大小最大为 1GB direct segment: 将一个进程所需的虚拟内存直接映射到一个大段中; 但不利用操作系统的动态内存分配 multipage mapping pack multiple page table entries(PTEs) into a single TLB entry they pack only a small multiple of translations per entry, which limits their potential to reduce page-walks for large working sets transparent huge pages memory should be size-aligned and contiguous many commodity processors provide limited numbers of large page TLB entries direct segment applications explicitly allocate a direct segment during startup OS can reserve a single large contiguous range of physical memory for a segment New Methods two key challenges: The address space of a process can be decomposed into many chunks of variable length segments, which can be allocated dynamically address translation must be off the critical path: to support complicated many segment searches, address translation may take much longer compared to traditional fixed-sized page-based TLB lookups. changes: hardware: range TLB, CR-RT (Control Register - Range Translation) software: process creation, memory allocation, range table management RMM Benefits transparent to applications maps multiple ranges with no size-alignment restrictions each range contains an unrestricted amount of memory RMM has the potential to map more than 99% of memory for all workloads with 50 or fewer range translations the range TLB achieves extremely high hit rates, eliminating the vast majority of costly page-walks compared to virtual memory systems that use paging alone. RMM performance depends on the range TLB achieving a high hit ratio with few entries Range Translation Range translations are only base-page-aligned and redundant to paging: the page table still maps the entire virtual address space hardware: range TLBs software: range tables OS: change lazy demand page allocation to eager paging, eager paging allocation Eager paging instantiates pages in physical memory at allocation request time, rather than at first-access time as with demand paging. Range Table when miss: 及时填补 PTE 以使访存操作正常执行, 将 Range TLB 更新移出访存关键路径 (后台更新) PTE 加入 range bit: 表示当前页是某个 Range 的一部分, 及时更新 Range TLB 和 Range Table 利用 CR-RT 寄存器进行 Range Table 查找: OS handler 可以进行 Range Table 查找, 以简化硬件设计 修改 INVLPG 指令： 使其同时无效化 Range TLB Contiguous Memory Allocation one motivation for demand paging was to limit unnecessary swapping in multiprogrammed workloads, which modern large memories make less common. RMM trades increased memory for better performance, a common tradeoff when memory is cheap and plentiful. © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"computerScience/latexBasicNotes.html":{"url":"computerScience/latexBasicNotes.html","title":"Latex Basic Notes","keywords":"","body":"Latex Basic Notes Latex Basic Notes Workflow Installation Build Script Basis Layout Page Size Font Size Math Symbol template Tools PDF to Tex tlmgr Workflow Installation Windows Installation Tutorial Linux Installation Tutorial sudo apt-get install libdigest-perl-md5-perl perl-tk wget http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/texlive2018.iso sudo mount -o loop textlive2018.iso /mnt/iso cd /mnt/iso sudo ./install-tl -gui perltk sudo umount /mnt/iso export MANPATH=${MANPATH}:/usr/local/texlive/2018/texmf-dist/doc/man export INFOPATH=${INFOPATH}:/usr/local/texlive/2018/texmf-dist/doc/info export PATH=${PATH}:/usr/local/texlive/2018/bin/x86_64-linux wget https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/install-tl-unx.tar.gz tar -xzf install-tl-unx.tar.gz cd install-tl-201* sudo apt-get install perl-tk perl-doc sudo ./install-tl -gui -repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/ sudo cp /usr/local/texlive/2018/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-texlive.conf sudo fc-cache -fv sudo tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/ sudo tlmgr update --list sudo tlmgr update --self --all Build Script filename=main pdf: pdflatex -synctex=1 -shell-escape -interaction=nonstopmode ${filename}.tex bibtex ${filename} pdflatex -synctex=1 -shell-escape -interaction=nonstopmode ${filename}.tex pdflatex -synctex=1 -shell-escape -interaction=nonstopmode ${filename}.tex clean: rm -f ${filename}.{ps,pdf,log,aux,out,dvi,bbl,blg,synctex.gz,toc,bcf,run.xml,tex.bbl,tex.blg} rm -f ${filename}-blx.bib Basis Simple Introduction Writing Scientific Documents Using LATEX Haiyang Liu's Tutorial Paper Tips and Tricks Layout \\footnote{} \\emph{} \\raggedright \\centering \\raggedleft Page Size \\usepackage[left=1cm,right=1cm,top=2cm,bottom=3cm]{geometry} Font Size \\zihao{0} % 初号 \\zihao{-6} % 小六 Math Typeset Equations Symbol The Comprehensive LATEX Symbol List $\\gamma \\delta \\sigma \\phi \\psi \\rho \\mu \\pi$ $\\sim \\in$ $\\geq \\leq$ $\\infty$ $\\rightarrow$ $\\surd \\sqrt{2} \\frac{x}{y}$ template \\usepackage{mathbbold} \\usepackage{CJK,CJKnumb} \\usepackage{indentfirst} %首行缩进宏包 \\usepackage{latexsym,bm} % 处理数学公式中和黑斜体的宏包 \\usepackage{amsmath,amssymb} % AMSLaTeX宏包 用来排出更加漂亮的公式 \\usepackage{graphicx} \\usepackage{cases} \\usepackage{pifont} \\usepackage{txfonts} %%%%%%%%%%% CJK下设置中文字体 %%%%%%%%%%%%% \\newcommand{\\song}{\\CJKfamily{song}} % 宋体 (Windows自带simsun.ttf) \\newcommand{\\fs}{\\CJKfamily{fs}} % 仿宋体 (Windows自带simfs.ttf) \\newcommand{\\kai}{\\CJKfamily{kai}} % 楷体 (Windows自带simkai.ttf) \\newcommand{\\hei}{\\CJKfamily{hei}} % 黑体 (Windows自带simhei.ttf) \\newcommand{\\li}{\\CJKfamily{li}} % 隶书 (Windows自带simli.ttf) %%%%%%%%%%% 设置字体大小 %%%%%%%%%%%%% \\newcommand{\\chuhao}{\\fontsize{42pt}{\\baselineskip}\\selectfont} \\newcommand{\\xiaochuhao}{\\fontsize{36pt}{\\baselineskip}\\selectfont} \\newcommand{\\yihao}{\\fontsize{28pt}{\\baselineskip}\\selectfont} \\newcommand{\\erhao}{\\fontsize{21pt}{\\baselineskip}\\selectfont} \\newcommand{\\xiaoerhao}{\\fontsize{18pt}{\\baselineskip}\\selectfont} \\newcommand{\\sanhao}{\\fontsize{15.75pt}{\\baselineskip}\\selectfont} \\newcommand{\\sihao}{\\fontsize{14pt}{\\baselineskip}\\selectfont} \\newcommand{\\xiaosihao}{\\fontsize{12pt}{\\baselineskip}\\selectfont} \\newcommand{\\wuhao}{\\fontsize{10.5pt}{\\baselineskip}\\selectfont} \\newcommand{\\xiaowuhao}{\\fontsize{9pt}{\\baselineskip}\\selectfont} \\newcommand{\\liuhao}{\\fontsize{7.875pt}{\\baselineskip}\\selectfont} \\newcommand{\\qihao}{\\fontsize{5.25pt}{\\baselineskip}\\selectfont} %%%%%%%% 设置版心 %%%%%%%%%%%%% \\setlength{\\textwidth}{14cm} \\setlength{\\textheight}{20cm} \\setlength{\\hoffset}{0cm} \\setlength{\\voffset}{0cm} \\setlength{\\parindent}{2em} % 首行两个汉字的缩进量 \\setlength{\\parskip}{3pt plus1pt minus1pt} % 段落之间的竖直距离 \\renewcommand{\\baselinestretch}{1.2} % 定义行距 \\setlength{\\abovedisplayskip}{2pt plus1pt minus1pt} %公式前的距离 \\setlength{\\belowdisplayskip}{6pt plus1pt minus1pt} %公式后面的距离 \\setlength{\\arraycolsep}{2pt} %在一个array中列之间的空白长度, 因为原来的太宽了 \\allowdisplaybreaks[4] % \\eqnarray如果很长，影响分栏、换行和分页 %（整块挪动，造成页面空白），可以设置成为自动调整模式 \\CJKtilde %用于解决英文字母和汉字的间距问题。例如：变量~$x$~的值。 \\renewcommand{\\CJKglue}{\\hskip 0pt plus 0.08\\baselineskip} %它于必要时在汉字之间插入一个附加的空隙，以解决行的超长问题。 %\\numberwithin{equation}{section} %================= 一些自定义命令 =============% \\newcommand{\\R}{\\ensuremath{\\mathbb{R}}} \\newcommand{\\p}{\\partial} \\newcommand{\\g}{\\gamma} %=================== End ======================% \\usepackage{fancyhdr} \\pagestyle{fancy} \\renewcommand{\\headrulewidth}{0.6pt} %\\addtolength{\\parinddent}{2em plus 1em minus 1em] %===============标题名称中文化 ===================% \\renewcommand\\abstractname{\\hei 摘\\ 要} \\renewcommand\\refname{\\hei 参考文献} \\renewcommand\\figurename{\\hei 图} \\renewcommand\\tablename{\\hei 表} \\newtheorem{dingyi}{\\hei 定义~}[section] \\newtheorem{dingli}{\\hei 定理~}[section] \\newtheorem{yinli}[dingli]{\\hei 引理~} \\newtheorem{tuilun}[dingli]{\\hei 推论~} \\newtheorem{mingti}[dingli]{\\hei 命题~} %% 注：在印刷出版上，中文字号制与点数制的对照关系如下： %% 1770年法国人狄道（F.A.Didot）制定点数制，规定1法寸为72点，即：1点=0.3759毫米。 %% 狄道点数制在法国、德国、奥地利、比利时、丹麦、匈牙利等国比较流行。 %% 1886年全美活字铸造协会以派卡（pica）为基准制定派卡点数制，规定1pica=12point（点），即： %% 1点=0.013837英寸=0.35146毫米 %% 20世纪初派卡点数制传入我国，并得到逐步推广。在实用中对常用点数以号数命名而产生了号数制， %% 二者换算如下（以pt代表“点”）： %% 初号……42pt 小初号……36pt 一号……28pt 二号……21pt 小二号……18pt 三号……15.75pt %% 四号……14pt 小四号……12pt 五号……10.5pt 小五号……9pt 六号 …… 7.875pt 七号 …… 5.25pt %%%%% xeCJK下设置中文字体 %%%%%%%%%%% \\setCJKfamilyfont{song}{SimSun} %宋体 song \\newcommand{\\song}{\\CJKfamily{song}} \\setCJKfamilyfont{xs}{NSimSun} %新宋体 xs \\newcommand{\\xs}{\\CJKfamily{xs}} \\setCJKfamilyfont{fs}{FangSong_GB2312} %仿宋2312 fs \\newcommand{\\fs}{\\CJKfamily{fs}} \\setCJKfamilyfont{kai}{KaiTi_GB2312} %楷体2312 kai \\newcommand{\\kai}{\\CJKfamily{kai}} \\setCJKfamilyfont{yh}{Microsoft YaHei} %微软雅黑 yh \\newcommand{\\yh}{\\CJKfamily{yh}} \\setCJKfamilyfont{hei}{SimHei} %黑体 hei \\newcommand{\\hei}{\\CJKfamily{hei}} \\setCJKfamilyfont{msunicode}{Arial Unicode MS} %Arial Unicode MS: msunicode \\newcommand{\\msunicode}{\\CJKfamily{msunicode}} \\setCJKfamilyfont{li}{LiSu} %隶书 li \\newcommand{\\li}{\\CJKfamily{li}} \\setCJKfamilyfont{yy}{YouYuan} %幼圆 yy \\newcommand{\\yy}{\\CJKfamily{yy}} \\setCJKfamilyfont{xm}{MingLiU} %细明体 xm \\newcommand{\\xm}{\\CJKfamily{xm}} \\setCJKfamilyfont{xxm}{PMingLiU} %新细明体 xxm \\newcommand{\\xxm}{\\CJKfamily{xxm}} \\setCJKfamilyfont{hwsong}{STSong} %华文宋体 hwsong \\newcommand{\\hwsong}{\\CJKfamily{hwsong}} \\setCJKfamilyfont{hwzs}{STZhongsong} %华文中宋 hwzs \\newcommand{\\hwzs}{\\CJKfamily{hwzs}} \\setCJKfamilyfont{hwfs}{STFangsong} %华文仿宋 hwfs \\newcommand{\\hwfs}{\\CJKfamily{hwfs}} \\setCJKfamilyfont{hwxh}{STXihei} %华文细黑 hwxh \\newcommand{\\hwxh}{\\CJKfamily{hwxh}} \\setCJKfamilyfont{hwl}{STLiti} %华文隶书 hwl \\newcommand{\\hwl}{\\CJKfamily{hwl}j \\setCJKfamilyfont{hwxw}{STXinwei} %华文新魏 hwxw \\newcommand{\\hwxw}{\\CJKfamily{hwxw}} \\setCJKfamilyfont{hwk}{STKaiti} %华文楷体 hwk \\newcommand{\\hwk}{\\CJKfamily{hwk}} \\setCJKfamilyfont{hwxk}{STXingkai} %华文行楷 hwxk \\newcommand{\\hwxk}{\\CJKfamily{hwxk}} \\setCJKfamilyfont{hwcy}{STCaiyun} %华文彩云 hwcy \\newcommand{\\hwcy}{\\CJKfamily{hwcy}} \\setCJKfamilyfont{hwhp}{STHupo} %华文琥珀 hwhp \\newcommand{\\hwhp}{\\CJKfamily{hwhp}} \\setCJKfamilyfont{fzsong}{Simsun (Founder Extended)} %方正宋体超大字符集 fzsong \\newcommand{\\fzsong}{\\CJKfamily{fzsong}} \\setCJKfamilyfont{fzyao}{FZYaoTi} %方正姚体 fzy \\newcommand{\\fzyao}{\\CJKfamily{fzyao}} \\setCJKfamilyfont{fzshu}{FZShuTi} %方正舒体 fzshu \\newcommand{\\fzshu}{\\CJKfamily{fzshu}} \\setCJKfamilyfont{asong}{Adobe Song Std} %Adobe 宋体 asong \\newcommand{\\asong}{\\CJKfamily{asong}} \\setCJKfamilyfont{ahei}{Adobe Heiti Std} %Adobe 黑体 ahei \\newcommand{\\ahei}{\\CJKfamily{ahei}} \\setCJKfamilyfont{akai}{Adobe Kaiti Std} %Adobe 楷体 akai \\newcommand{\\akai}{\\CJKfamily{akai}} Tools PDF to Tex sudo apt install abiword abiword --to=tex a.pdf tlmgr sudo apt-get install xzdec cd ~ mkdir texmf tlmgr init-usertree tlmgr install tlmgr update --self --all tlmgr update --list © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/assembly/AssemblyBasic.html":{"url":"language/assembly/AssemblyBasic.html","title":"Assembly Basic","keywords":"","body":"Assembly Basic Notes Assembly Basic Notes GCC/GDB/Kit GCC GDB MASM/LINK/TD MASM LINK TD Basic Alt 代码区 数据区 NMAKE Objdump 位运算 Address mov address 常用命令 读取指令 mov 读取 算术命令 转移命令 Control Flow if loop do/while while/do for switch(Jump Table) Stack Frame Data Structure Arrays Load-ALU-Store 模式 - 读入寄存器，算术逻辑单元运算，回写至内存 GCC/GDB/Kit GCC gcc -01/-02/-03 source.c —— 编译优化等级 gcc -S source.c —— 编译成汇编代码(文本文件) gcc -o source.c —— 编译成 Object 代码(二进制文件) GDB si 单指令执行 x/i $pc 执行 si 命令时打印汇编代码 disas 显示汇编代码 bt 查看函数堆栈 step1 下一条汇编指令 info register x /numsizeformat $pc/rsp/rbp MASM/LINK/TD MASM masm /Zi/Zd src dist masm /I(path) // 引用 标准库/宏 masm /I..\\include LINK link /DEBUG src TD tab 切换分区 alt 功能键 ctrl 子功能键 Basic F2: break F7: step into F8: step over Alt Alt+F5 : 临时跳转至 dos 界面 Alt+Enter: 全屏 Alt+X : 退出 代码区 Assemble: 临时修改汇编指令 Caller : 从子程序处跳回至 Caller 处 Follow : 查看 CALL/JMP/INT 跳转至的子程序处 Origin : 跳转至 cs:ip 指向指令处 数据区 Change: 临时修改数据 Display: 选择显示格式 e.g Byte/Word/Long/Comp/Float/Real/Double/Extended Goto: 跳转至指定地址区 NMAKE $: 源文件名 $?: 所有源文件名 $@: 全路径的目标文件 $*: 除去扩展名的全路径的目标文件 EXE = $(NAME).exe OBJS = $(NAME).obj SRCS = $(NAME).asm SIMPLE_MODE = ; LINK_FLAG = /subsystem:windows ML_FLAG = /c/coff/Zi MASM_FLAG = /Zi/Zd $(EXE): $(OBJS) link $(LINK_FLAG) $(OBJS) $(SIMPLE_MODE) $(OBJS): $(SRCS) masm $(MASM_FLAG) $(SRCS) $(SIMPLE_MODE) clean: del *.obj del *.tr test: td $(EXE) Objdump AT&T反汇编工具 位运算 ^：无进位 p && *p++ : NULL 检查 编码：2^n e.g 一副牌的编码 2 位牌色位+4 位数字位 Address mov movX src dest #X:b/w/l/q （1/2/4/8 字节） address D(Rb, Ri, S) —— MEM[ Reg[Rb] + S * Reg[Ri] + D] leal 命令 leal D(Rb, Ri, S) dest - 将地址模式表达式的址存入 dest. 作用为快速给指针赋值p = &x[i] 即Mem[Reg[x] + i * size]->(x, size, I), 快速计算二次多项式 x + i * k. 常用命令 读取指令 mov 读取 内存数据重复读入寄存器 - 使得汇编代码与上下文无关,减少 BUG 产生可能性 R1 = MEM[SP + 8] …… R1 = MEM[SP + 8] …… R1 = MEM[SP + 8] …… 算术命令 转移命令 Flags CF：Carry Flag(unsigned) 进位标志——当有进位时设为 1 OF：OverFolw Flag(signed) 溢出标志——当补码溢出时设为 1 SF：Sign Flag(signed) 符号标志——当 t ZF：Zero Flag 零标志——当 t==0 时设为 1 cmpX 命令 cmpl Src2, Src1 根据 Src1 – Src2(subl Src2, Src1)的结果设置标志寄存器的值 testX 命令 testl Src2, Src1 根据 Src1 & Src2(andl Src2, Src1)的结果设置标志寄存器的值 e.g testl %eax, %eax 实现符号函数 setX 命令 根据标志寄存器运算值，将值存入 dest setX dest Control Flow if cmovC src, dest(C 表示 Conditional——e/ne 等) 当条件成立时，src->dest src 与 dest 可分别用于存放两种情况的值 loop do/while while/do for switch(Jump Table) break; → leave ret fallThrough(without break) mixing(连冒号) missing case Stack Frame # 准备阶段 # Caller-Save: %eax %ecx %edx # Callee-Save: %ebx %esi %edi # 传参顺序: rdi, dsi, rdx, rcx, r8, r9, stack pushl %ebp movl %esp, %ebp pushl %ebx # 结束阶段 movl -4(%ebp), %ebx movl %ebp, %esp popl %ebp ret Data Structure Arrays int get_sea_digit(int index, int dig) { return sea[index][dig]; } # 访问二维数组元素 # %ecx = dig # %eax = index leal 0(,%ecx,4), %edx # 4 * dig leal (%eax,%eax,4), %eax # 5 * index movl sea(%edx,%eax,4), %eax # * (sea + 4 * dig + 20 * index) © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/c/tools/awesomeTools.html":{"url":"language/c/tools/awesomeTools.html","title":"Awesome Tools","keywords":"","body":"Awesome Tools Awesome Tools UsefulTools GCC UsefulTools 用于创建代码文档资料的 NDoc 用于生成解决方案的 NAnt 用于生成代码的 CodeSmith 用于监视代码的 FxCop 用于编译少量代码的 Snippet Compiler 两种不同的转换器工具：ASP.NET 版本转换器和 Visual Studio .NET 项目转换器 用于生成正则表达式的 Regulator 用于分析程序集的 .NET Reflector 用于单元测试的 NUnit GCC -E: cpp(c preprocessor) 预处理 => .i -S: cll 编译 => .s -c: as(assemble) 汇编 => .o -time Time the execution of each subprocess -std= Assume that the input sources are for -B Add to the compiler's search paths -v Display the programs invoked by the compiler -o Place the output into -shared Create a shared library -Wall -v --help © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/c/tools/gdbTutorial.html":{"url":"language/c/tools/gdbTutorial.html","title":"Gdb Tutorial","keywords":"","body":"GDB Tutorial GDB Tutorial Basic Command set shell Assemble Core Dump Disasm Stack Frame Basic Command r(run) l(list) b(break) b linenum b filename:linenum display/format address e.g display/i $pc t 按二进制格式显示变量 d 按十进制格式显示变量 o 按八进制格式显示变量 u 按十六进制格式显示无符号整型 x 按十六进制格式显示变量 a 按十六进制格式显示变量 f 按浮点数格式显示变量 c 按字符格式显示变量 s 按字符串格式显示变量 disas 显示汇编代码 x /num-size-format $pc/rsp/rbp e.g size:w(2 字节) format:x/d/s(十六进制/十进制/字符串) 2wx examine - 查看内存 n、f、u 是可选的参数 n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果地十是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes. u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节. 当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来. 表示一个内存地址. 命令：x/3uh 0x54320 表示，从内存地址 0x54320 读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示按十六进制显示。 s step into step1 下一条汇编指令 n next line p print q quit up last stack bt(backtrace) function stack 显示堆栈回溯信息 info breakpoints/register set set disassembly set variable shell shell command Assemble Core Dump ulimit -c unlimited gdb -c core_file_path target_exe_path Disasm CS Segment (gdb) disass (gdb) x/i (gdb) x/5i $pc (gdb) ni/si Registers (gdb) i r (gdb) i r a (gdb) i r ds DS Segment SS Segment Stack Frame (gdb) bt (gdb) frame n (gdb) info locals © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/c/cBasicNotes.html":{"url":"language/c/cBasicNotes.html","title":"C Basic Notes","keywords":"","body":"C Basic Notes C Basic Notes 编程习惯 Macro(宏) 括号 特殊用法 头文件 缺少标准库头文件 缺少函数原型 覆盖标准库函数原型 缺少宏定义 防止重复包括头文件 头文件不申请内存单元 检查 边界检查 指针检查 类型转换 机器码转换 Awesome Pointer(Tips and Best Practice) Error Prone Pointers(易错点) Debugging Malloc 处理 void 指针 利用 void 指针实现泛型(generic) 通用型 swap 函数 通用型 lsearch 函数 实现 int 实例 string 实例 泛型数据结构 通用型栈 Tools Useful Functions memset free Strings strdup strchr/strstr strtok strcasecmp 不区分大小写 getopt I/O sscanf Exceptions Process fork/execve Other Threads pthread.h Semaphore 联合体 编程习惯 Macro(宏) 括号 尽量添加足够的括号,减少宏定义的二义性 特殊用法 #: 字符串化 ##: 强制连接符 do { ... } while (0): 防止语法错误 头文件 缺少标准库头文件 缺少函数原型 链接成功 - 链接器自动装载库函数，不影响程序执行 只警告，不报错 覆盖标准库函数原型 定义过多参数原型，调用时传入过多参数，函数正确执行(无视多余参数) 定义缺少参数原型，调用时传入不完整参数，函数错误执行，误把 0xc(%ebp)，0x10(%ebp)，…等更多内存单元当作函数参数 缺少宏定义 链接失败 - 宏定义会被识别为函数，但链接器查找不到相应库函数 防止重复包括头文件 #ifndef _FILENAME_H_ #define _FILENAME_H_ ... ... ... #endif 头文件不申请内存单元 除了全局共享静态变量外, 头文件中的定义不允许申请实际的内存单元 检查 边界检查 空/满栈检查 参数合法性检查 e.g elemSize > 0 检查 指针检查 alloctor 失败，需添加 NULL 检查: assert exit 类型转换 机器码转换 有符号类型转换: 进行符号扩展 无符号类型转换: 进行零扩展 Awesome Pointer(Tips and Best Practice) Error Prone Pointers(易错点) int i = 37; float f = *(float *)&i; float f = 7.0; short s = *(short *)&f; 悬挂指针 未初始化 改写未知区域 下标越界 内存上溢 e.g gets(string); 指针相关运算符优先级与结合性 返回局部变量的地址 重复释放内存空间 内存泄漏 e.g 未释放空间/未释放部分深度空间(多维数组) 不能引用 void 指针指向的内存单元 Debugging Malloc 处理 void 指针 Tips: 中途运用强制类型转换,使得 void 指针可以执行指针加减运算 void *target = (char *)void_pointer + ...; 利用 void 指针实现泛型(generic) 通用型 swap 函数 void swap(void *vp1, void *vp2, int size) { char buffer[size]; memcpy(buffer, vp1, size); memcpy(vp1, vp2, size); memcpy(vp2, buffer, size); } 通用型 lsearch 函数 实现 void *lsearch(void *key, void *base, int n, int elemSize, int (*cmpfn)(void *, void *)) { for (int i = 0;i int 实例 int IntCmp(void *elem1, void *elem2) { int *ip1 = (int *)elem1; int *ip2 = (int *)elem2; return *ip1 - *ip2; } int array[] = {4, 2, 3, 7, 11, 6}, size = 6, target = 7; // 应进行强制类型转换 int * found = (int *)lsearch(&target, array, 6, sizeof(int), IntCmp); if (found == NULL) { printf(\"Not Found\"); } else { printf(\"Found\"); } string 实例 int StrCmp(void *vp1, void *vp2) { // 必须进行强制类型转换 char *s1 = *(char **)vp1; char *s2 = *(char **)vp2; return strcmp(s1, s2); } char *notes[] = {\"Ab\", \"F#\", \"B\", \"Gb\", \"D\"}, *target = \"Eb\"; char ** found = lsearch(&target, notes, 5, sizeof(char *), StrCmp); 泛型数据结构 通用型栈 typedef struct { void *elems; int elemSize; int logLen; int allocLen; } stack; void StackNew(stack *s, int elemSize); void StackDispose(stack *s); void StackPush(stack *s, void *elemAddr); void StackPop(stack *s, void *elemAddr); void StackNew(stack *s, int elemSize) { // 参数合法性检查 if (s->elemSize elemSize = elemSize; s->logLen = 0; s->allocLen = 4; s->elems = (int *)malloc(s->allocLen * elemSize); // NULL检查 if (s->elems == NULL) { perror(\"No Mem\"); exit(0); } } void StackPush(stack *s, void *elemAddr) { // 满栈检查 if (s->logLen == s->allocLen) { s->allocLen *= 2; s->elems = (int *)malloc(s->elems, s->allocLen * s->elemSize); } void *target = (char *)s->elems + s->logLen * s->elemSize; memcpy(target, elemAddr, s->elemSize); s->logLen++; } void StackPop(stack *s, void *elemAddr) { // 空栈检查 if (s->logLen == 0) { perror(\"Empty Stack\"); return; } s->logLen--; void *source = (char *)s->elems + s->logLen * s->elemSize; memcpy(elemAddr, source, s->elemSize); } Tools Valgrind - GitHub Repo Useful Functions memset free free 函数会回退 4/8 字节，取出 heap 块的长度/信息,根据此信息进行 heap 块的释放. Strings strdup string duplicate - char *strdup(string) 封装 allocator 细节 strchr/strstr 返回字符/串在字符串中出现的位置(地址) strtok strcasecmp 不区分大小写 getopt 解析命令行参数, 轻松地提取以 - 或 / 开头的参数 I/O 　 sscanf 可以用作简易匹配读取函数 // 提取除 http:// 外的字符串 sscanf(buf, \"http://%s\", url_part); Exceptions perror(string) - 用来将上一个函数发生错误的原因输出到标准设备(stderr) Process fork/execve fork(): 创建当前进程的拷贝 execve(): 用另一程序的代码代替当前进程的代码 int execve(char *filename, char *argv[], char *envp[]) void fork_exec(char *path, char *argv[]) { pid_t pid = fork(); if (0 != pid) { printf(\"Parent: created a child %d\\n\", pid); } else { printf(\"Child: exec-ing new program now\\n\"); execv(path, argv); } printf(\"This line printed by parent only!\\n\"); } Other getpid() wait(int *child_status)/waitpid(pid) exit() Threads pthread.h typedef unsigned long int pthread_t; /** * create thread * @param {指向线程标识符的指针} pthread_t *__thread * @param {设置线程属性} __const pthread_attr_t *__attr * @param {线程运行函数的起始地址} void *(*__start_routine) (void *) * @param {运行函数的参数} void *__arg */ extern int pthread_create __P (( pthread_t *__thread, __const pthread_attr_t *__attr, void *(*__start_routine) (void *)， void *__arg) ); 　　 /** * 等待线程 * @param {被等待的线程标识符} pthread_t __th * @param {一个用户定义的指针，它可以用来存储被等待线程的返回值} void **__thread_return */ extern int pthread_join __P ((pthread_t __th, void **__thread_return)); /** * 退出线程 * @param {函数的返回代码} (void *__retval)) __attribute__ ((__noreturn__) */ extern void pthread_exit __P ((void *__retval)) __attribute__ ((__noreturn__)); // 一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，其余调用pthread_join的线程则返回错误代码ESRCH // 以下为互斥锁相关函数 pthread_mutex_init pthread_mutexattr_init /** * 设置属性pshared * PTHREAD_PROCESS_PRIVATE * PTHREAD_PROCESS_SHARED */ pthread_mutexattr_setpshared /** * 设置互斥锁类型 * PTHREAD_MUTEX_NORMAL * PTHREAD_MUTEX_ERRORCHECK * PTHREAD_MUTEX_RECURSIVE * PTHREAD_MUTEX_DEFAULT */ pthread_mutexattr_settype pthread_mutex_lock pthread_mutex_unlock pthread_delay_np InitThreadPackage; ThreadNew; ThreadSleep; RunAllThreads; SemaphoreNew(int > 0); SemaphoreWait(lock); SemaphoreSignal(lock); Semaphore 哲学家就餐问题 将 Semaphore 变量的值在允许范围内(不至于使得线程锁失效)使得其取最大值，减少线程阻塞 EmptyBuf 8, FullBuf 0 双向通信，互相唤醒 - Writer:sw(empty),ss(full); Reader:sw(full),ss(empty); void SellTickets(int agent, int *ticketsNum, Semaphore lock) { while (true) { // 当 lock == 0 时,当前进程阻塞, 等待 lock > 0 // 当 lock > 0 时, 当前进程继续进行, 并且 lock-- SemaphoreWait(lock); if (*ticketsNum == 0) break; // 票已售磬 (*ticketsNum)--; // 售出一张票 printf(\"Sell One Ticket.\\n\"); // lock++ 使得 lock > 0 // 若有其他进程调用了SemaphoreWait, 且因之前 lock == 0 而被阻塞, 则此时其他进程可继续进行 SemaphoreSignal(lock); } // break to here // 作用同循环内的 Signal 函数 SemaphoreSignal(lock); } 联合体 机器码 e.g 理解 IEEE 754 标准 区分大/小端模式 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/c/namingConventions.html":{"url":"language/c/namingConventions.html","title":"Naming Conventions","keywords":"","body":"Naming Conventions Naming Conventions 常用缩写词 Header File 常用缩写词 原词 缩写 addition add answer ans array arr average avg buffer buf 或 buff capture cap 或 capt check chk count cnt column col control ctrl decode dec define def delete del destination dst 或 dest display disp division div encode enc environment env error err float flt frequency freq header hdr index idx image img increment inc initalize init iteration itr length len memory mem middle mid make mk message msg multiplication mul number num operand opnd optimization opt operator optr packet pkt positon pos previous pre 或 prev payload type pointer ptr/pt return code record rcd/rc receive recv result res return ret source src stack stk string str subtraction sub table tab temporary tmp 或 temp total tot time stamp value val Header File 防止其他文件重复#include 本文件 #ifndef MONGOOSE_HEADER_INCLUDED #define MONGOOSE_HEADER_INCLUDED /*................................. * do something here *................................. */ #endif /* MONGOOSE_HEADER_INCLUDED */ © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/c/standardLibrary.html":{"url":"language/c/standardLibrary.html","title":"Standard Library","keywords":"","body":"C Standard Library C Standard Library / 关闭断言 #define NDEBUG #include 开启断言 #undef NDEBUG #include 可检测字符 getc、fgetc、getchar 函数可返回值(EOF 值/unsigned char 类型) 不可检测字符 非 EOF 值/非 unsigned char 类型(会引发严重错误) errno 的值在程序启动时为零，但是不会被任何库函数设为零 errno = 0; y = sqrt(x); if (errno != 0) { printf(\"invalid x : %e\\n\", x); } #ifndef _I386_ERRNO_H #define _I386_ERRNO_H #define EPERM 1 /* Operation not permitted */ #define ENOENT 2 /* No such file or directory */ #define ESRCH 3 /* No such process */ #define EINTR 4 /* Interrupted system call */ #define EIO 5 /* I/O error */ #define ENXIO 6 /* No such device or address */ #define E2BIG 7 /* Arg list too long */ #define ENOEXEC 8 /* Exec format error */ #define EBADF 9 /* Bad file number */ #define ECHILD 10 /* No child processes */ #define EAGAIN 11 /* Try again */ #define ENOMEM 12 /* Out of memory */ #define EACCES 13 /* Permission denied */ #define EFAULT 14 /* Bad address */ #define ENOTBLK 15 /* Block device required */ #define EBUSY 16 /* Device or resource busy */ #define EEXIST 17 /* File exists */ #define EXDEV 18 /* Cross-device link */ #define ENODEV 19 /* No such device */ #define ENOTDIR 20 /* Not a directory */ #define EISDIR 21 /* Is a directory */ #define EINVAL 22 /* Invalid argument */ #define ENFILE 23 /* File table overflow */ #define EMFILE 24 /* Too many open files */ #define ENOTTY 25 /* Not a typewriter */ #define ETXTBSY 26 /* Text file busy */ #define EFBIG 27 /* File too large */ #define ENOSPC 28 /* No space left on device */ #define ESPIPE 29 /* Illegal seek */ #define EROFS 30 /* Read-only file system */ #define EMLINK 31 /* Too many links */ #define EPIPE 32 /* Broken pipe */ #define EDOM 33 /* Math argument out of domain of func */ #define ERANGE 34 /* Math result not representable */ #define EDEADLK 35 /* Resource deadlock would occur */ #define ENAMETOOLONG 36 /* File name too long */ #define ENOLCK 37 /* No record locks available */ #define ENOSYS 38 /* Function not implemented */ #define ENOTEMPTY 39 /* Directory not empty */ #define ELOOP 40 /* Too many symbolic links encountered */ #define EWOULDBLOCK EAGAIN /* Operation would block */ #define ENOMSG 42 /* No message of desired type */ #define EIDRM 43 /* Identifier removed */ #define ECHRNG 44 /* Channel number out of range */ #define EL2NSYNC 45 /* Level 2 not synchronized */ #define EL3HLT 46 /* Level 3 halted */ #define EL3RST 47 /* Level 3 reset */ #define ELNRNG 48 /* Link number out of range */ #define EUNATCH 49 /* Protocol driver not attached */ #define ENOCSI 50 /* No CSI structure available */ #define EL2HLT 51 /* Level 2 halted */ #define EBADE 52 /* Invalid exchange */ #define EBADR 53 /* Invalid request descriptor */ #define EXFULL 54 /* Exchange full */ #define ENOANO 55 /* No anode */ #define EBADRQC 56 /* Invalid request code */ #define EBADSLT 57 /* Invalid slot */ #define EDEADLOCK EDEADLK #define EBFONT 59 /* Bad font file format */ #define ENOSTR 60 /* Device not a stream */ #define ENODATA 61 /* No data available */ #define ETIME 62 /* Timer expired */ #define ENOSR 63 /* Out of streams resources */ #define ENONET 64 /* Machine is not on the network */ #define ENOPKG 65 /* Package not installed */ #define EREMOTE 66 /* Object is remote */ #define ENOLINK 67 /* Link has been severed */ #define EADV 68 /* Advertise error */ #define ESRMNT 69 /* Srmount error */ #define ECOMM 70 /* Communication error on send */ #define EPROTO 71 /* Protocol error */ #define EMULTIHOP 72 /* Multihop attempted */ #define EDOTDOT 73 /* RFS specific error */ #define EBADMSG 74 /* Not a data message */ #define EOVERFLOW 75 /* Value too large for defined data type */ #define ENOTUNIQ 76 /* Name not unique on network */ #define EBADFD 77 /* File descriptor in bad state */ #define EREMCHG 78 /* Remote address changed */ #define ELIBACC 79 /* Can not access a needed shared library */ #define ELIBBAD 80 /* Accessing a corrupted shared library */ #define ELIBSCN 81 /* .lib section in a.out corrupted */ #define ELIBMAX 82 /* Attempting to link in too many shared libraries */ #define ELIBEXEC 83 /* Cannot exec a shared library directly */ #define EILSEQ 84 /* Illegal byte sequence */ #define ERESTART 85 /* Interrupted system call should be restarted */ #define ESTRPIPE 86 /* Streams pipe error */ #define EUSERS 87 /* Too many users */ #define ENOTSOCK 88 /* Socket operation on non-socket */ #define EDESTADDRREQ 89 /* Destination address required */ #define EMSGSIZE 90 /* Message too long */ #define EPROTOTYPE 91 /* Protocol wrong type for socket */ #define ENOPROTOOPT 92 /* Protocol not available */ #define EPROTONOSUPPORT 93 /* Protocol not supported */ #define ESOCKTNOSUPPORT 94 /* Socket type not supported */ #define EOPNOTSUPP 95 /* Operation not supported on transport endpoint */ #define EPFNOSUPPORT 96 /* Protocol family not supported */ #define EAFNOSUPPORT 97 /* Address family not supported by protocol */ #define EADDRINUSE 98 /* Address already in use */ #define EADDRNOTAVAIL 99 /* Cannot assign requested address */ #define ENETDOWN 100 /* Network is down */ #define ENETUNREACH 101 /* Network is unreachable */ #define ENETRESET 102 /* Network dropped connection because of reset */ #define ECONNABORTED 103 /* Software caused connection abort */ #define ECONNRESET 104 /* Connection reset by peer */ #define ENOBUFS 105 /* No buffer space available */ #define EISCONN 106 /* Transport endpoint is already connected */ #define ENOTCONN 107 /* Transport endpoint is not connected */ #define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */ #define ETOOMANYREFS 109 /* Too many references: cannot splice */ #define ETIMEDOUT 110 /* Connection timed out */ #define ECONNREFUSED 111 /* Connection refused */ #define EHOSTDOWN 112 /* Host is down */ #define EHOSTUNREACH 113 /* No route to host */ #define EALREADY 114 /* Operation already in progress */ #define EINPROGRESS 115 /* Operation now in progress */ #define ESTALE 116 /* Stale NFS file handle */ #define EUCLEAN 117 /* Structure needs cleaning */ #define ENOTNAM 118 /* Not a XENIX named type file */ #define ENAVAIL 119 /* No XENIX semaphores available */ #define EISNAM 120 /* Is a named type file */ #define EREMOTEIO 121 /* Remote I/O error */ #define EDQUOT 122 /* Quota exceeded */ #define ENOMEDIUM 123 /* No medium found */ #define EMEDIUMTYPE 124 /* Wrong medium type */ #endif / 宏定义：CHAR/UCHAR/SCHAR/SHRT/USHRT/INT/UINT/LONG/ULONG/FLT/DBL/LDBL有关的MIN/MAX/EPSILON 实现时间/单位/货币等一系列的国际化 常用函数 _CRTIMP char * __cdecl setlocale(int, const char *); _CRTIMP struct lconv * __cdecl localeconv(void); int 值 #define LC_ALL 0 #define LC_COLLATE 1 #define LC_CTYPE 2 #define LC_MONETARY 3 #define LC_NUMERIC 4 #define LC_TIME 5 数学函数库(包括后缀 f(float)/l(long double)) 常用函数 int setjmp(jmp_buf env); void longjmp(jmp_buf env, int val); 使用：用于 if/else、loop、switch 语句 直接调用 setjmp 函数时，返回值为 0; 调用 longjmp 函数时，若 val 值不为 0,则跳转至上次 setjmp 返回值为 0 处，继续向后执行语句 功能 实现非本地(局部)跳转(跨越多层函数调用栈进行跳转) 实现类 Java 异常机制(异常抛出及捕获) 信号处理程序中所有数据应为 volatile 类型 _CRTIMP int __cdecl raise(int); _CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int); 用于编写可变参数函数 void printargs(int arg1, ...) /* 输出所有int类型的参数，直到-1结束 */ { va_list ap; int i; va_start(ap, arg1); for (i = arg1; i != -1; i = va_arg(ap, int)) printf(\"%d \", i); va_end(ap); putchar('\\n'); } 宏 NULL Null 指针常量 offsetof(type, member-desginator) 获得字段在结构体中的偏移量 类型 ptrdiff_t 带符号的整数类型, 用来表示指针相减的结果类型 wchar_t 宽字符类型 size_t 无符号整数类型, 用来表示 sizeof 操作符的结果类型 men 系函数：操作任意字符序列 strn 系函数：操作非空字符序列 str 系函数：操作字符串序列('\\0') © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/cpp/cppBasicNotes.html":{"url":"language/cpp/cppBasicNotes.html","title":"Cpp Basic Notes","keywords":"","body":"C++ Basic Notes C++ Basic Notes Basic Workflow 初始化与回收 变量 指针 reference (引用类型) 性质 作为函数参数 特性 volatile 类型 运算符 左/右值运算符(运算结果为左/右值) sizeof Expression (表达式) 左/右值表达式 联合(union) 位段 函数 参数的默认值(defalut) 内联函数(inline) 类 访问控制权限 构造函数 调用形式 构造函数体 默认无参构造函数 构造顺序 深拷贝构造函数 move constructor 析构函数 构造与析构(重点)(P148) 派生树 new 与 delete/delete [] stack 与 heap 指针成员 this 指针 成员指针 与 指针成员 成员指针 - 指向成员的指针 定义含指针成员的类 函数成员 const/volatile 关键字 mutable 关键字 静态成员 静态数据成员 static member 特性 定义 静态函数成员 引用形式 static function member 特性 静态成员指针 static 关键字 友元 成员友元函数 单继承 派生控制权限 父类与子类(public 派生控制权) 虚函数 virtual function 特性 功能 纯虚函数 与 抽象类 易错点 作用域(Scope) 面向过程的作用域 面向对象的作用域 命名空间(namespace) 运算符重载 重载原则 自增/减运算符 成员运算符 赋值运算符 强制类型转换(P172) 模板 模板调用形式 异常 异常对象的析构 多态 STL Input Output iomanip STL API Container unordered_map container Container Choosing empty/size assign/insert/erase erase/remove reserve/swap Heap Algorithm Sorting Algorithms Partitioning Algorithms Permutation Algorithms Numeric Algorithms Query Algorithms Equal STL Algo Search Algortihms Find STL Algo Set Algortihms Mover Algorithms Value Algorithms Functional Algorithms Awesome Tips / Best Practice 静态成员 BP 友元函数 单继承 BP 构造与析构 虚函数 BP Error BP Inherits Output Basic Workflow 初始化与回收 Treat global program as a object: 开工函数与收工函数 Normal Object: 构造函数与析构函数 变量 const 变量 代替 #define 宏定义 指针 只读指针可赋值为 普通对象地址 普通指针不可赋值为 只读对象地址 int *p = const int; // x int *p = int; // o const int *p = const int; // o const int *p = int; // o reference (引用类型) 性质 引用类型(&)实质上是一种语法糖,编译器将引用变量最终全部编译为指针变量 作为函数参数 向函数传递引用类型实参时,若: 实参与形参类型不一致(必须完全一致) 实参为(右)值表达式 则会生成一个内部匿名变量,用于函数调用. 此时,对参数进行的操作将无法改变实参原有值,使得 call by reference 失效. 特性 普通全局引用变量必须在定义时初始化初始化(左值表达式) int &x = 1; // warning: 引用匿名变量 int &k = j++; // warning: 引用匿名变量 引用变量不分配存储单元: 不能引用 引用变量, 不能作为指针所指对象, 不能作为数组元素 int & &x; // error int & *p; // error int & s[4]; // error 引用变量的值按字节(指针/地址)编码: 不能引用位段(无法按字节编码) int &w = a.j; // error 引用变量不能引用引用变量, 只能引用另一个引用变量所引用的变量/地址 int x = 10; int &j = x; int &&m = j; // error int &m = j; // pass: m = j => x 引用变量可以引用 register 变量, 编译器会将其自动转为 auto 变量(为其分配地址) register int i = 0, register int &j = i; 引用变量在一定程度上具有指针性质 int x = 1; const int &p = x; // pass x = 7; // pass p = 7; // error volatile 类型 volatile 表示可被其他线程/进程改变的变量 volatile 变量常作为全局变量, 用于同步各进程 const 表示不可被本线程/进程修改的变量 volatile int x; x = 3; if (4 == x) { cout 运算符 左/右值运算符(运算结果为左/右值) 左值运算符: 前置++/--, =/+=/*=/&=/op= 右值运算符: 强制类型转换(不可对其运算结果进行取地址), +/*/binary sizeof sizeof 数值 sizeof(数值) sizeof(类型) sizeof(printf(\"abcd\")); // 无输出 Expression (表达式) 左/右值表达式 左值表达式一定可作(右)值表达式, (右)值表达式不可作左值表达式: 左值表达式 : 变量, 赋值表达式, 前缀自操作表达式, 返回值为引用类型的函数调用 bar; y = 6; i -= 10; ++i; int &f(void); f() = j; (右)值表达式: 常量, 强制类型转换表达式, 后缀自操作表达式, 算数表达式 20; (type)x; i++; y + 2; 联合(union) 匿名联合具有以下性质: 没有对象的全局匿名联合必须 static 只可定义 public 成员 数据成员与联合本身作用域相同 数据成员共享存储空间 位段 class/struct/union 都可定义位段成员, 但类型必须为 char/short/int/enum, 不可为 long/float/array/class 函数 参数的默认值(defalut) 不能在 函数原型声明 与 函数定义 中 同时 定义参数的默认值,会产生默认值冲突 所有缺省参数必须位于参数列表右边 不能用前一个参数初始化后一个参数 当同时有 int g(void) int g(int x = 1) 时, 不能调用 g() (具有二义性) int bar(int x , int y = 5, int z = m(u,v)); int foo(int x, int y = x++); // error 内联函数(inline) 以下情况会造成内联失败: 内联函数中使用 分支/循环/开关/函数调用 内联函数定义出现在调用后面(先调用后定义) 其他函数访问了内联函数入口地址 内联函数定义为(纯)虚函数 内联最终结果: 内联成功后, 原函数会被编译器清除 不管内联是否成功, 内联函数作用域局限于当前源文件 全局 extern main 函数不能定义为内联函数(否则会使得主函数作用域变小, 操作系统无法访问主函数) 在类体内实现的任何函数自动变为内联函数 类 访问控制权限 public > protected > private + friend > private 构造函数 调用形式 构造函数不可被显式调用(类前缀), 必须隐式调用(省略类前缀) 构造函数体 构造函数体前: 初始化只读成员、引用成员、对象成员、其他数据成员, 初始化顺序以定义顺序为准, 无关构造函数体前出现顺序 构造函数体内: 再次赋值其他数据成员(不可再次只读成员、引用成员、对象成员) 默认无参构造函数 当定义了含参构造函数后, 编译器将不会再为对象自动添加无参构造函数 默认无参构造函数不会初始化只读/引用成员, 且只会调用对象成员的无参构造函数(若对象成员没有无参构造函数,则编译器报错) 对于局部对象, 将随机初始化普通数据成员; 对于全局对象, 将普通数据成员初始化为 0. 由于默认无参构造函数的存在, 当对象只含有普通数据成员(无只读/引用/指针成员, 且对象成员有无参构造函数), 可以不显式定义构造函数 class Foo { const int b; int c, &d, e, f; String g, h; public: // 初始化顺序: b, c, d, e, f, g, h Foo(int bar): d(c), c(bar), g(bar), b(bar), e(bar) { c += bar; f = bar; } }; B z(7, 8); => B z(7, 8); /// B z(8); /// 构造顺序 同一派生树上所有虚基类(自左向右, 自下向上)(递归) (继承顺序)直接基类(递归) (定义顺序)所有成员 构造函数体 深拷贝构造函数 形式为 Foo:Foo(Foo &obj) 的构造函数,可使得对象作为实参传递时自动进行深拷贝复制 ARRAY::ARRAY(ARRAY &r) { p = new int[size = r.size]; for (int i = 0;i move constructor class A { A(const A&& a) { // move constructor // set a == nullptr } } 析构函数 析构函数即可显式调用,又可隐式调用 析构函数与全局 main 函数 没有重载函数 作用域结束时会自动调用析构函数 调用 exit/abort 时, 需手动调用析构函数释放资源 String x(\"global\"); int main(void) { short error = 0; String y(\"local\"); // set error flag switch (error) { case 0: return; case 1: y.~String(); exit(1); default: x.~String(); y.~String(); abort(); } return 0; } 设置 析构标志 防止重复析构同一对象 String::~String() { // check flag if (s == NULL) { return; } cout 构造与析构(重点)(P148) 按定义顺序自左下至右上地构造所有虚基类 按定义顺序构造直接基类 按定义顺序构造数据成员(对象/const/引用/普通成员) 执行类构造函数体 递归执行以上过程 派生树 一个对象/对象成员一颗单独的派生树 单独的派生树中, 合并同名虚基类, 不合并同名基类, 并 { name(type), ...} 标示数据成员 new 与 delete/delete [] stack 与 heap string str(\"sabertazimi\") 创建在栈上, 自动析构 new/malloc 返回堆指针, delete/free 的对象是堆指针/(&引用变量), 完全由程序员管理创建与回收 int x = 5; int *p = &x; int &q = x; delete p; // address of x delete &q; // address of x 指针成员 普通指针/不含指针成员的对象变量分配/回收内存可混用 malloc/new/free/delete/delete [] 创建/回收含有指针成员的类时,只能用 new/delete/delete [](分配对象内存+调用构造/析构函数), 不能用 malloc/free(只作用于对象本身,不调用构造/析构函数,即不为指针成员分配/回收内存), 否则会造成指针成员未分配内存/内存泄露 new 对象数组实质: malloc 对象 + 调用对象无参构造函数 this 指针 普通函数成员比静态函数成员多一个隐含参数 this 指针, 其会随着函数类型的不同而改变类型 this 指针指向对象起始地址处(对象首成员地址) 一般函数: class_type *const this; const 函数: const class_type *const this;, 可以修改 this 所指对象的非只读静态数据成员 volatile 函数: volatile class_type *const this; 当 this 指针类型不同时, 亦会产生重载函数 成员指针 与 指针成员 成员指针 - 指向成员的指针 成员指针不是地址, 而是偏移量 考虑到越界问题,成员指针不可移动 成员指针不可进行类型转换, 不可将其转换为其他类型, 也不可将其他类型转换为它 作用: 成员别名 (a.*pf)() => a.size() 优先级: . > * > .*(结合性: 自左向右) int A::*pi = &A::i; /// 定义含指针成员的类 深拷贝构造函数: T(const T &) 深拷贝赋值运算函数: virtual T& operator=(const T &) 虚析构函数: virtual ~T() 定义T &p = *new T()后, 使用delete &p释放内存 定义T *p = new T()后, 使用delete p释放内存 函数成员 const/volatile 关键字 修饰函数成员隐含参数 * this 对象指针,表示不可修改/挥发对象 被修饰函数成员不能修改对象自身(即对象的普通数据成员), 可以修改对象的非只读静态数据成员 构造函数/析构函数不可被 const/volatile 修饰: 在构造/析构函数中, 对象必须可以被修改(No const), 且处于稳定状态(No volatile) mutable 关键字 mutable 不可修饰引用成员 mutable 成员不可用 const/volatile/static 修饰 const 函数中可以修改 mutable 成员 静态成员 静态数据成员 static member 特性 静态数据成员脱离对象实例存在 Person::totalNum 静态数据成员存储单元不属于任何对象实例 定义 不能在构造函数/析构函数中创建/释放静态数据成员的存储单元 在类体内声明静态数据成员, 在类体外定义并初始化静态数据成员 List * List::head = NULL;(包括私有静态数据成员) 局部类/union 类不可定义静态数据成员, 局部类/union 类可以定义静态函数成员 静态函数成员 静态函数成员不含隐含参数(this 对象指针) 构造/析构/virtual/const/volatile 函数(均有 this 对象指针)不能定义为静态函数成员 体内实现为 inline 函数, 体外实现不能有 static 关键字 引用形式 抽象类型 List::sort() 对象实例 list.sort() static function member 特性 只能直接修改当前对象静态数据成员 可以通过静态函数成员的函数参数, 传入对象实例指针, 从而间接修改非静态数据成员 静态成员指针 除了具有访问权限外, 静态成员指针就是普通指针(可以进行指针加减运算) int *d = &CROWD::number; int (*f)() = &CROWD::getnumber; static 关键字 位于 class 体内: 表示该成员/方法共享存储单元(不限定作用域) 位于 class 体外: 表示该变量/函数具有静态存储周期(限定作用域为当前文件) 友元 在重载函数中, (函数签名不一致的) 未声明的函数只能访问类的共有成员 friend 声明不能与存储类型关键字共用(static/virtual) 定义友元函数(使用 friend 修饰函数声明)时: 友元函数不是此处的函数成员, 可随意指定 返回类型与访问控制权限 成员友元函数 可在 3 处实现函数体: 函数定义处(本类): 内联函数成员 友元声明处(它类): 内联友元函数(作用域局限于当前程序文件) 类体外(不使用 friend 关键字) 单继承 派生控制权限 降低/维持权限 class 缺省为 private 派生控制, struct 缺省为 public 派生控制 只可恢复至基类原权限, 不可随意修改基类成员权限 父类与子类(public 派生控制权) 子类对象地址可以赋值给父类指针, 子类指针可以直接赋值给父类指针 父类对象地址不可以赋值给子类指针, 父类指针即使强制类型转换后也不可以赋值给子类指针 虚函数 virtual function 特性 无限传递性: 派生类中原型相同的函数自动成为虚函数 具有隐式参数(this 对象指针): 不能为静态函数成员(静态函数无 this 参数)/非函数成员(本类友元函数), 可以为它类成员友元函数 构造函数不能为虚函数, 析构函数可以为虚函数 virtual 与 friend/static 关键字不可共用 union 既不能定义基类也不能定义派生类, 故不能在 union 中定义虚函数 功能 实现运行时多态. 最好将普通函数成员全部定义为 虚函数 纯虚函数 与 抽象类 纯虚函数具有虚函数的所有特性 具有纯虚函数的类自动成为抽象类 struct A { virtual void f1() = 0; virtual void f2() = 0; }; 易错点 virtual 关键字只能在 struct/class 体内使用, 在体外实现相应函数成员时, 应去掉 virtual 关键字 当在函数成员中调用虚函数时, 会根据 this 所指真实对象动态调用虚函数(如在基类函数成员中调用虚函数, 可能实际调用的是子类的虚函数) 使用基类指针/基类引用指向派生类时, 只可按基类访问控制权限调用基类拥有的方法 不可以new 抽象类(堆实例)/构造抽象类的栈实例, 函数参数/返回值不可直接定义为抽象类(调用时无法构造栈实例), 但可以定义为抽象类的引用/指针 Parent *p = new Child(5); p->~Child(); // Error: method not defined p->~Parent(); // Success: invoke Child::~Child() 作用域(Scope) 标识符的作用域越小,访问的优先级别越高 单目运算符 :: 可访问全局符号 e.g ::process++ // 自加全局变量 process 面向过程的作用域 作用于表达式内 作用于函数内 作用于程序文件内 作用于整个程序 面向对象的作用域 作用于函数成员内 作用于类/派生类内 作用于基类内 作用于虚基类内 命名空间(namespace) 指定一个完全的命名空间时, 不会将任何标识符加入当前作用域. 可重新定义同名局部符号 namespace A { int a = 0; namespace B { int a = 0; } namespace C { } namespace D { } using namespace B; using namespace C; } using namespace A; int a = 5; /// 指定一个命名空间的具体成员时, 会将成员符号加入当前作用域 namespace A { float a = 0, b = 0; float d(float y) { return y; } } namespace B { void g(void) { cout>; } } int main(void) { using A::a; using A::d; using B::g; long a = 1; /// 可以为嵌套命名空间定义别名 namespace A { namespace B { namespace C { int k = 4; } } } namespace ABCD = A::B::C; using ABCD::k; /// 运算符重载 运算符 重载方式 sizeof . .* :: ?: 不可重载 = -> () [] (必须有 this 指针)普通函数成员 new delete (不可有 this 指针)静态函数成员 普通函数 其他运算符 普通函数成员 普通函数 重载原则 若运算符为左值运算符, 则重载返回类型为非 const 引用类型 若运算符为非左值运算符, 则重载返回类型为普通类型(栈内存)或 const 类型 重载为普通函数成员, this 占据第一个参数位置 重载不改变运算符的优先级与结合性 自增/减运算符 A &A::operator++(); /// 成员运算符 只能重载为普通函数成员, 只有一个参数(+ this), 返回类型必须为指针/引用类型 struct A { int a; }; class B { A x; public: A *operator->() { return &x; } }; int main(void) { B b; int i = b->a; // i = b.x.a i = (*b.operator->()).a; // i = b.x.a i = b.operator->()->a; // i = b.x.a } 赋值运算符 所有对象都有默认的 = 重载: 浅拷贝赋值运算 强制类型转换(P172) 当定义只有一个参数的构造函数时, 进行运算时会自动发生类型转换(利用右值调用此构造函数, 生成中间变量赋给左值) Complex m; m + 2 => m + 2.0 => m + Complex(2.0); 模板 模板调用形式 函数标签相同的覆盖函数 通过函数模板自动生成可匹配参数的实例函数 通过强制类型转换,调用已经手动生成的可匹配参数的实例函数 调用失败 异常 异常对象的析构 catch (const A *a) 形式 多态 编译时多态(重载): 静态绑定(同名不同参的)重载函数 - 一个方法, 多种参数 (f(void) => f@, f(int) => f@i, f(int, int) => f@ii) 运行时多态(多态): 动态绑定(upcasting)虚函数 - 一个接口, 多个方法(父子表现不同, 兄弟表现不同) Parent c = new Child(); c.speak(\"Hello World!\") // => \"Child: Hello World!\" STL 工作方式: copy in, copy out Input Output iomanip STL API output format #include #include int main() { std::cout Container 序列容器: vector string deque list 关联容器: set multiset map multimap 连续内存容器: vector string deque 链表容器: list slit hash unordered_map container count/find [] if (m_breakpoints.count(possible_breakpoint_location)) { auto& bp = m_breakpoints[possible_breakpoint_location]; } auto alias = m_aliases.find(input); return (alias != m_aliases.end() && alias->second == command); Container Choosing Vector vs Array: use Array when size is fixed and need elaborate container-like behavior Vector vs Deque: use Deque when container is large Vector vs List (no random access): use List when many middle insertion/deletion/splicing Vector vs Set/Map: use Set/Map when container is large empty/size list.empty() 优于 list.size() == 0 assign/insert/erase void container::insert(InputIterator begin, InputIterator end); void container::insert(iterator position, InputIterator begin, InputIterator end); iterator container::erase(iterator begin, iterator end); // 序列容器 void container::erase(iterator begin, iterator end); // 关联容器 void container::assign(InputIterator begin, InputIterator end); v1.assign(v2.begin() + v2.size() / 2, v2.end()); v1.insert(v1.end(), v2.begin() + v2.size() / 2, v2.end()) // 将 v2 一半元素插入 v1 尾部 erase/remove 对于连续内存容器 vector/string/deque: c.erase(remove(c.begin(), c.end(), 1963), c.end()) bool badValue(int); c.erase(remove_if(c.begin(), c.end(), badValue), c.end()); 对于 list: c.remove(1963) bool badValue(int); c.remove_if(badValue); // higher order function 对于关联容器: c.erase(1963); reserve/swap v.reserve(1000); // 强制分配 1000 个元素内存单元, 防止反复回收/释放, 提高执行效率 string(s).swap(s); // 回收多余内存单元(shrink to fit), 提高内存利用率 Heap Algorithm std::make_heap(begin(numbers), end(numbers)); std::push_heap(begin(numbers), end(numbers)); std::pop_heap(begin(numbers), end(numbers)); std::is_heap std::is_heap_until Sorting Algorithms sort stable_sort std::is_sorted std::is_sorted_until partial_sort nth_element: 0 - nth-1 sorted ( nth) unsorted sort_heap inplace_merge Partitioning Algorithms partition_point partition stable_partition std::is_partitioned std::is_partitioned_until Permutation Algorithms rotate shuffle prev_permutation next_permutation Numeric Algorithms count count_if accumulate (transform_)reduce partial_sum (transform_)inclusive_scan (transform_)exclusive_scan inner_product adjacent_difference sample Query Algorithms all_of any_of none_of equal lexicographical_compare mismatch Equal STL Algo template bool equal( InputIt1 first1, InputIt1 last1, InputIt2 first2 ) { for (; first1 != last1; ++first1, ++first2) { if (!(*first1 == *first2)) { return false; } } return true; } bool is_prefix(const std::string& s, const std::string& of) { if (s.size() > of.size()) return false; return std::equal(s.begin(), s.end(), of.begin()); } bool is_suffix(const std::string& s, const std::string& of) { if (s.size() > of.size()) return false; auto diff = of.size() - s.size(); return std::equal(s.begin(), s.end(), of.begin() + diff); } bool is_palindrome(const std::string& s) { return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin()); } Search Algortihms search find find_if find_if_not find_first_of find_end adjacent_find equal_range lower_bound upper_bound min_element max_element minmax_element Find STL Algo template InputIterator find (InputIterator first, InputIterator last, const T& val) { while (first!=last) { if (*first==val) return first; ++first; } return last; } auto it = std::find_if(begin(g_register_descriptors), end(g_register_descriptors), [r](auto&& rd) { return rd.r == r; }); Set Algortihms set_difference set_intersection set_union set_symmetric_difference includes merge Mover Algorithms copy copy_backward copy_if remove_copy unique_copy reverse_copy rotate_copy replace_copy replace_copy_if partition_copy partial_sort_copy move move_backward swap_ranges Value Algorithms fill generate replace replace_if iota Functional Algorithms transform for_each Awesome Tips / Best Practice 普通函数成员 与 析构函数 全部定义为虚函数 不改变对象实例的函数 全部定义为 const 函数 被改变参数/返回值 全部定义为 引用类型 深拷贝(赋值)函数参数/返回值 全部定义为 引用类型 函数(传值)参数全部定义为 const & 类型: 既减少值的多余复制, 又保证原值不会被误修改 静态成员 BP 静态函数成员只能直接修改当前对象静态数据成员, 可以通过传参修改参数的普通数据成员 静态函数成员体内实现为 inline 函数, 体外实现不能有 static 关键字 不能在构造函数/析构函数中 创建/释放 静态数据成员的存储单元 在类体内声明静态数据成员, 在类体外定义并初始化静态数据成员 List * List::head = NULL;(包括私有静态数据成员) 局部类/union 类不可定义静态数据成员, 局部类/union 类可以定义静态函数成员 友元函数 定义友元函数(使用 friend 修饰函数声明)时: 友元函数不是此处的函数成员, 可随意指定 返回类型与访问控制权限 单继承 BP 只可恢复至基类原权限, 不可随意修改基类成员权限 子类对象地址可以赋值给父类指针, 子类指针可以直接赋值给父类指针 父类对象地址不可以赋值给子类指针, 父类指针即使强制类型转换后也不可以赋值给子类指针 构造与析构 构造函数体前: 初始化只读成员、引用成员、对象成员、其他数据成员, 初始化顺序以定义顺序为准, 无关构造函数体前出现顺序 构造函数体内: 再次赋值其他数据成员(不可再次只读成员、引用成员、对象成员) 当定义了含参构造函数后, 编译器将不会再为对象自动添加无参构造函数 默认无参构造函数不会初始化只读/引用成员, 且只会调用对象成员的无参构造函数(若对象成员没有无参构造函数,则编译器报错) 虚函数 BP virtual 关键字只能在 struct/class 体内使用, 在体外实现相应函数成员时, 应去掉 virtual 关键字 当在函数成员中调用虚函数时, 会根据 this 所指真实对象动态调用虚函数(如在父类函数成员中调用虚函数, 可能实际调用的是子类的虚函数) 使用基类指针/基类引用指向派生类时, 只可按基类访问控制权限调用基类拥有的方法 不可以new 抽象类(堆实例)/构造抽象类的栈实例, 函数参数/返回值不可直接定义为抽象类(调用时无法构造栈实例), 但可以定义为抽象类的引用/指针 Error BP class 体内声明为 friend/static/virtual 方法, class 体外实现时不加 friend/static/virtual 关键字 const/static 使用错误 static int x; A(x++, y++);　// 若 A 中改变x, 会使得 x++ 无效化 不可以new 抽象类(堆实例)/构造抽象类的栈实例, 函数参数/返回值不可直接定义为抽象类(调用时无法构造栈实例), 但可以定义为抽象类的引用/指针 返回类型不匹配错误 初始化构造函数不存在(基类定义有参构造函数, 派生类必须显示调用父类构造函数)错误 引用/const/对象成员初始化错误 访问控制权限错误(e.g 在全局声明一个只有私有构造函数的类实例) 派生控制权限错误(只可恢复原先权限, 不可任意修改父类成员权限) 运算符重载分类错误(不可重载, 只可重载为...) 成员指针与普通指针(静态成员指针)的混用错误 单参数构造函数与强制类型转换重载函数在表达式中的隐式调用错误 指针不可指向引用等引用类型的特性错误 引用变量不分配存储单元: 不能引用 引用变量, 不能作为指针所指对象, 不能作为数组元素 引用变量的值按字节(指针/地址)编码: 不能引用位段(无法按字节编码) 引用变量不能引用引用变量, 只能引用另一个引用变量所引用的变量/地址 引用变量可以引用 register 变量, 编译器会将其自动转为 auto 变量(为其分配地址) Inherits Output 每一行输出都为新的派生树(拥有独立的虚基类) 每个对象成员都为新的派生树(拥有独立的虚基类) © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/go/goBasicNotes.html":{"url":"language/go/goBasicNotes.html","title":"Go Basic Notes","keywords":"","body":"Go Basic Notes Go Basic Notes CLI Installation Basic Command Build Test Clean Modules Packages package and import Variable Type Declaration Type conversions struct array slice map Flow Control if for switch defer 执行时机 实质 应用场景 Function Parameters and Return Value Methods Pointer/Value Receiver Interface 值 Type assetions Concurrent goroutine channels select Worker Pools CLI Installation sudo apt install golang echo \"export GOPATH=$HOME/gopath\" echo \"export PATH=$PATH:$GOPATH/bin\" go env Basic Command go version go run main.go go fmt /path/to/test go 的大部分工具的作用基本单位为 package(directories) Build # generate library go build path/to/libpack go install path/to/libpack # generate binary go install path/to/mainpack Test # path/to/pack/demo.go # path/to/pack/demo_test.go go test path/to/pack Clean go clean -i path/to/pack Modules remote packages $GOPATH/bin/hello go get github.com/golang/example/hello Packages package and import for path/to/pack: package pack import ( \"path/to/pack\" ) 只有首字母大写的函数才可被成功导出, 首字母小写的函数为文件私有函数 Variable Type Declaration Go 将类型置于变量名后的理由: reads clearly, from left to right := 不可用在函数外 // 简写类型/赋值 var i,j int = 1, 2 // 省略类型 var c, python, java = true, false, \"no!\" // 省略 var 关键字 javascript, ruby, cpp:= true, false, \"no!\" // 声明块 import ( \"math/cmplx\" ) var ( ToBe bool = false MaxInt uint64 = 1 Type conversions var x int = 3 var y uint = uint(x) z := uint(x) struct type Vertex struct { X int Y int } var ( v1 = Vertex{1, 2} v2 = Vertex{X: 1} // Y: 0 v3 = Vertex{} // X: 0, Y: 0 vp = &Vertex{1, 2} // *Vertex ) array 数组的长度是其类型的一部分 var a [2]string a[0] = \"Hello\" a[1] = \"Golang\" fmt.Println(a[0], a[1]) fmt.Println(a) slice s[lo:lo] == nil p := []int{2, 3, 5, 7, 11, 13} fmt.Println(\"p[1:4] ==\", p[1:4]) fmt.Println(\"p[:3] ==\", p[:3]) // p[0:3] => 0, 1, 2 fmt.Println(\"p[4:]\" ==, p[4:]) // p[4:len(p)-1] => 4, ..., len(p)-2 make 函数创建 slice a := make([]int, 5) // len(a) = 5 b := make([]int, 0, 5) // len(b) = 0, cap(b) = 5 b = b[:cap(5)] // len(b) = 5, cap(b) = 5 len && cap // just shorten/extend, not drop elements // change len(p), keep cap(p) p = p [:0] p = p[:4] // drop its elements // change len(p) and cap(p) p = p[2:] append append(s, 2, 3, 4) range(iterator): 返回 2 个值(index int, element copy(s[index]) T), 在每一次迭代 index+=1 pow := []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i := range pow { fmt.Printf(\"index == %d\\n\", i) } for _, v := range pow { fmt.Printf(\"value == %d\\n\", v) } for i, v := range pow { fmt.Printf(\"2**%d = %d\\n\", i, v) } } map type Vertex struct { Lat, Long float64 } var m map[string]Vertex = make(map[string]Vertex) m[\"Bell Labs\"] = Vertex{ 40.68433, -74.39967 } ml := map[string]Vertex{ \"Bell Labs\": Vertex{ 40.68433, -74.39967, }, \"Google\": {37.42202, -122.08408}, } delete(m, \"Bell Labs\") element, ok_flag := m[\"Google\"] Flow Control if if x = %g\\n\", v, lim) } for for sum switch switch 中的 case 自动 break(除非使用 fallthrough 语句) switch time.Saturday { case today+0: fmt.Println(\"Today.\") case today+1: fmt.Println(\"Tomorrow.\") case today+2: fmt.Println(\"In two days.\") default: fmt.Println(\"Too far away.\") } // scope of os: only in switch statement switch os := runtime.GOOS; os { case \"darwin\": fmt.Println(\"OS X.\") case \"linux\": fmt.Println(\"Linux.\") default: fmt.Printf(\"%s\", os) } // alias for if-else long chain switch { // switch true case t.Hour() defer defer 语句会将函数执行延迟至上层函数返回处(函数参数会立刻生成): 执行时机 函数设置返回值后, 即将返回调用函数前(若 defer 函数修改返回变量, 则会造成返回值与预期不一致) func main() { defer fmt.Println(\"!\") defer fmt.Println(\"world\") fmt.Println(\"hello\") } => func main() { fmt.Println(\"hello\") fmt.Println(\"world\") fmt.Println(\"!\") } 实质 return_value = xxx -> invoke defer functions(stack) -> return void func f() (result int) { defer func() { result++ }() return 0 } => func f() (result int) { result = 0 func() { result++ }() return } 应用场景 资源回收 mu.Lock() defer mu.Unlock() panic 异常的捕获 func f() { defer func() { if r:= recover(); r!= nil { fmt.Println(\"Recovered in f\", r) } }() fmt.Println(\"Calling g.\") g() fmt.Println(\"Returned normally from g.\") } func g() { panic(\"ERROR\") } 保证语句(在发生异常的情况下)始终会被执行 有意修改返回值 Function Parameters and Return Value 简写参数类型 多值返回函数 命名返回值(注释文档) func swap(x, y string) (string, string) { return y, x } func swap_(x, y string) (x_, y_ string) { x_, y_ = y, x return } func main() { a, b := swap(\"hello\", \"golang\") a_, b_ := swap_(\"hello\", \"golang\") fmt.Println(a, b) fmt.Println(a_, b_) } Methods Go 中没有 class, 但可以在 struct/同一个包内的 type 上(receiver)定义方法 type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &Vertex{3, 4} fmt.Println(v.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f Pointer/Value Receiver pointer receiver: 可以改变原值(call by reference) value receive: 不可以改变原值(call by value) 调用 methods 时, 可以不考虑 v 是 value/pointer, go 会自动处理 func (v *Vertex) changeV() { v.X += 1 v.Y += 1 } v.changeV() => (&v).changeV() func (v Vertex) Abs() { return abs(v) } (&v).Abs() => v.Abs() Best Practice: 在同一个类型上定义的所有方法最好统一 receiver 类型(全部 value receivers 或 全部 pointer receivers) Interface 值 (value, type) var i I var t *T i = t // => (nil, *T) var i I // => (nil, nil) Type assetions 单返回值: 断言失败时产生 panic 双返回值: 断言失败时不产生 panic // create empty interface, (\"hello\", string) var i interface{} = \"hello\" s := i.(string) s, ok := i.(string) // => true f, ok := i.(float64)// => false(no panic) f := i.(float64) // => false with panic type switches switch v := i.(type) { case int; fmt.Println(\"Int.\") case string: fmt.Println(\"String.\") default: fmt.Printf(\"Other type.\") } Concurrent goroutine go f(x, y, z) // => excute in a new goroutine with share memory channels typed conduit(类型管道) block excution var c chan int = make(chan int) c func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c select select(当所有情况都不满足时)可被阻塞 for { select { case c Worker Pools package main import \"fmt\" import \"time\" func worker(id int, jobs © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/haskell/haskellBasicNotes.html":{"url":"language/haskell/haskellBasicNotes.html","title":"Haskell Basic Notes","keywords":"","body":"Haskell Basic Notes Haskell Basic Notes Platform ghci ghc Unique Mark Expression Type 基本类型 Int Integer Float Double Bool Char [Char]/String Ordering Word Rational List Operator Function Range List Comprehension(数学定义) Tuple(原组) 内部差异性 外部差异性 Tuple Function 二元组 三元组 泛型 函数类型 基本语法 名字/函数定义 模式匹配(Pattern Matching) Best Practice 常用模式 as 模式 List 模式 Tuple guard 模式 与 where 绑定 let 绑定 case 表达式 Typeclass =>符号 Basic Typeclass Eq Ord Show Read Enum Bounded Num Integral Floating Functor Control.Applicative Maybe Collection [] IO ZipList 多个 functors 高度封装函数: liftA2 Control.Monad Maybe Monad 实现 do 表示法 List Monad MonadPlus Monad Algorithms 马走日 Foldable Data.Monoid 自定义 Typeclass data type 函数特性 记录语法(Record Syntax) 类型参数(Type Parameters) Maybe value constructor Deriving(派生) type 定义 高级数据结构 栈 链表 二叉树 函数 递归函数 List 函数 高阶函数 Curry 化 map 函数 filter 函数 fold 函数与 scan 函数 lambda 表达式 $函数 .函数与 Function composition(函数组合) 常用函数 无参函数 前缀函数 中缀函数 数学函数 System.Random 数字函数 模块 import 建立模块 单一模块 子模块 常用基础模块 Data.List 修正 Prelude 模块 Data.Char Data.Map Data.Set 输入与输出 IO action return Command Line BtyeString 常用输入输出函数 输出 putChar/putStr/putStrLn print File/System.IO writeFile appendFile 输入 getChar :: IO Char getContents File handle withFile readFile Action when sequence mapM mapM_ Control.Monad.forM Control.Monad.forever hSetBuffering hFlush Other lines interact System.Directory - removeFile/renameFile 异常 catch Advanced Monad Writer Monad Control.Monad.Writer Reader Monad State Monad Control.Monad.State Control.Monad.State (MonadState) 实例 Error Monad Useful Monad Functions liftM join filterM foldM (组合函数) Self-Defined Monad 注释 符号 Platform apt-get install haskell-Platform apt-get install ghc-mod atom plugins : language-haskell autocomplete-haskell ide-haskell haskell-ghc-mod ghci :l - load file :r - reload file :cd :edit - $EDITOR :m - module :q - quit :? :k - kind :t - type function :info - data/Typeclass ghc runghc *.hs/*.lhs Unique Mark :+ 复数符 - 2 :+ 3 -> 2+3i _ 泛匹配符: 表示不关心此部分具体内容 属于符号,用于 ListRange 中. => 类型约束分隔符 -> Expression if 语句也是表达式 doubleSmallNumber' x = (if x > 100 then x else x*2) + 1 Type 基本类型 ghci> :t 'a' 'a' :: Char ghci> :t True True :: Bool ghci> :t \"HELLO!\" \"HELLO!\" :: [Char] ghci> :t (True, 'a') (True, 'a') :: (Bool, Char) Int 有限整数 Integer 无限整数(效率低) Float 单精度浮点数 Double 双精度浮点数 Bool True/False Char [Char]/String Ordering LT,GT,EQ Word Data.Word - unsigned int Rational 有理数类型,用于高精度数学运算 List Operator ++ : !! >/ Function head List 首元素 last List 尾元素 init List 除去尾元素的部分 tail List 除去首元素的部分 length List 长度 Tips: fromIntegral (length [1,2,3,4]) + 3.2 null List BestPractice: 检查一个 List 是否为空 ghci> null [1,2,3] False ghci> null [] True reverse List 反转 take num List 返回 List 前 num 个元素组成的 List ghci> take 3 [5,4,3,2,1] [5,4,3] ghci> take 5 [1,2] [1,2] ghci> take 0 [6,6,6] [] drop num List 删除 List 前 num 个元素 ghci> drop 3 [8,4,2,1,5,6] [1,5,6] ghci> drop 0 [1,2,3,4] [1,2,3,4] ghci> drop 100 [1,2,3,4] [] maximum List 返回最大元素 minimun List 返回最小元素 sum List 返回 List 元素和 product List 返回 List 元素积 elem elem List 判断元素存在性 ghci> 4 `elem` [3,4,5,6] True ghci> 10 `elem` [3,4,5,6] False cycle List 返回循环无限数组(Haskell 惰性特性) repeat Elem 返回循环无限数组(Haskell 惰性特性) replicate num Elem 返回循环无限数组 take 10 (cycle [1,2,3]) -> [1,2,3,1,2,3,1,2,3,1] take 10 (repeat 5) -> [5,5,5,5,5,5,5,5,5,5] replicate 3 10 -> [10,10,10] takeWhile :: (a -> Bool) -> [a] -> [a] 遇到不符合限制条件的元素便停止遍历 List ghci> sum (takeWhile ( Range 三要素: , 与 .. 上限 下限 步长(仅可标明一次) 上下限: [1..20] 步长为2: [2,4..20] 步长为13无限List: [13,26..] take 24 [13,26..] List Comprehension(数学定义) 由类似集合定义的离散数学定义,来定义复杂的 List: [expression | filter] [expression | x Range: ,分隔多个 Range(一般为 List) Predicate: ,分隔多个断言;每个断言均为 Boolean 表达式 ghci> [x*2 | x = 12] [12,14,16,18,20] ghci> [ x | x boomBangs [7..13] [\"BOOM!\",\"BOOM!\",\"BANG!\",\"BANG!\"] 多个 Range ghci> [ x*y | x 嵌套 Comprehension ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]] ghci> [ [ x | x Tuple(原组) 内部差异性 同一 Tuple 里可存放不同 Type 的项 外部差异性 数目不同或某项不同的 Tuple 属于不同 Type 不可置于同一 List 中 不同长度的 Tuple 不可比较(比较符只可用于相同 Type) Tuple Function 二元组 fst/snd tuple 返回首项/尾项 zip List1 List2 对应项配对,组成二元组 List ghci> zip [5,3,2,6,2,7,2,5,4,6,6] [\"im\",\"a\",\"turtle\"] [(5,\"im\"),(3,\"a\"),(2,\"turtle\")] ghci> zip [1..] [\"apple\", \"orange\", \"cherry\", \"mango\"] [(1,\"apple\"),(2,\"orange\"),(3,\"cherry\"),(4,\"mango\")] 三元组 first :: (a, b, c) -> a first (x, _, _) = x second :: (a, b, c) -> b second (_, y, _) = y third :: (a, b, c) -> c third (_, _, z) = z 泛型 运用 Type 变量(只可为单字符),实现泛型参数与多态函数 借助 Typeclass 可轻松实现多态函数 ghci> :t head head :: [a] -> a -- a 和 b 可为同类型 -- 第一个参数与返回值必须同类型 ghci> :t fst fst :: (a, b) -> a -- 所有参数必须同类型,且必须为Num成员 ghci> :t (*) (*) :: (Num a) => a -> a -> a 函数类型 单个参数 removeNonUppercase :: [Char] -> [Char] removeNonUppercase st = [ c | c 多个参数 addThree :: Int -> Int -> Int -> Int addThree x y z = x + y + z 基本语法 名字/函数定义 模式匹配(Pattern Matching) 当函数拥有多个函数体(模式)时,会从上至下进行匹配各模式,一旦匹配则只应用这一函数体. Best Practice 代替 if-else/switch 语句 递归算法(将递归基础作为首模式,递归函数体作为尾模式) List Range 中亦可使用模式匹配 addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a) addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) 常用模式 as 模式 all@(pattern) - all 为指向 pattern 整体的引用 all@(x:y:xs) -- 其中all与(x:y:xs)等价 capital :: String -> String capital \"\" = \"Empty string, whoops!\" capital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x] List 模式 x:xs x:y:z:xs head' :: [a] -> a head' [] = error \"Can't call head on an empty list, dummy!\" head' (x:_) = x length' :: (Num b) => [a] -> b length' [] = 0 length' (_:xs) = 1 + length' xs sum' :: (Num a) => [a] -> a sum' [] = 0 sum' (x:xs) = x + sum' xs Tuple (x, y) (x, y, z) guard 模式 与 where 绑定 子模式匹配: 运用布尔表达式实现判断,应用对应函数体 关键符号: | 与 where | 分隔函数体 where 可见性: 定义只对本模式可见的(私有)名字与(私有)函数 where 定义在最外层,使得各模式共享(私有)名字与(私有)函数 名字定义时可使用模式匹配 where (head:_) = firstname bmiTell :: (RealFloat a) => a -> a -> String bmiTell weight height | bmi let 绑定 类似 where,绑定对象为表达式/函数 let bindings in expressions let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 可见性:in 作用域,只对本 guard 可见 可使用模式匹配 可用于 List Range 中 case 表达式 模式匹配是 case 表达式的特殊情况(语法糖:简化写法) 在函数中,模式匹配只能用于参数定义中,而 case 表达式可用于其他地方(let/where 绑定 普通表达式 guard 语句) case expression of pattern -> result pattern -> result pattern -> result ... describeList :: [a] -> String describeList xs = \"The list is \" ++ case xs of [] -> \"empty.\" [x] -> \"a singleton list.\" xs -> \"a longer list.\" Typeclass ghci> :t (==) (==) :: (Eq a) => a -> a -> Bool ghci> :t fromIntegral fromIntegral :: (Integral a, Num b) => a -> b =>符号 =>左部: 类约束(Class Constraint) =>右部: 函数类型(参数/返回值类型),其中参数类型同属 Class Basic Typeclass ghci> :info typeClassName Eq 功能: 成员类型可判断相等性 成员: 大部分基本类型(不包含函数类型) 方法: == 与 /= 函数 class Eq a where (==) :: a -> a -> Bool (/=) :: a -> a -> Bool x == y = not (x /= y) x /= y = not (x == y) Ord Ord 成员必为 Eq 成员: class (Eq a) => Ord a where 功能: 成员类型可排序 成员: 大部分基本类型(不包含函数类型) 方法: = 函数 compare 函数 (Ord a) => a -> a -> Ordering Show 功能: 成员类型可用字符串表示 成员: 大部分基本类型(不包含函数类型) 方法: show 函数 (Show a) => a -> String Tips: 结合 Read, 可用于字符串与数值之间的转化 Read 功能: 可以将字串转为 Read 某成员类型 成员: 大部分基本类型(不包含函数类型) 方法: read 函数 (Read a) => String -> a Tips: 结合 Show, 可用于字符串与数值之间的转化 Enum 功能: 连续性(可枚举), 其成员类型可用于Range中 成员: () Bool Char Ordering Int Integer Float Double [Thursday .. Sunday] ghci> succ Monday Tuesday ghci> pred Saturday Friday Bounded 功能: 成员类型具有上下限 方法: minBound/maxBound 函数 (Bounded a) => a 无参多态常量/定义 ghci> minBound :: Day Monday ghci> maxBound :: Day Sunday Num 功能: 成员类型具有数字特征 成员: 实数 整数 - Int Integer Float Double 方法: + - * abs 函数 实例: 所有数字都是多态常量/定义(可视为函数) ghci> :t 20 20 :: (Num t) => t Integral 功能: 成员类型具有数字特征 成员: 整型 - Int Integer Floating 功能: 成员类型具有数字特征 成员: 浮点型 - Float Double typeclass method feature Functor f a + (a -> b) -> f b Applicative f a + f (a -> b) -> f b Monad m a + (a -> m b) -> m b Functor 成员: Maybe a, [], Either a, IO 成员 kind 必须为 * -> * f 一元类型构造符(type constructor) 必须遵守准则: fmap id = id fmap (f . g) F = fmap f (fmap g F) ghci> :info Functor class Functor (f :: * -> *) where fmap :: (a -> b) -> f a -> f b ($) :: a -> f b -> f a instance Functor [] where fmap = map instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x instance Functor IO where fmap f action = do result Control.Applicative 成员: f :: * -> * 一元类型构造符(type constructor) : 参数为 2 个 functor 实例,其中一个包含一个函数 () :: (Functor f) => (a -> b) -> f a -> f b f x = fmap f x 作用: 可以用单一一个函数操作多个 functors class (Functor f) => Applicative f where pure :: a -> f a () :: f (a -> b) -> f a -> f b Maybe instance Applicative Maybe where pure = Just Nothing _ = Nothing (Just f) something = fmap f something Collection [] instance Applicative [] where pure x = [x] fs xs = [f x | f IO instance Applicative IO where pure = return a b = do f ZipList instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs ZipList xs = ZipList (zipWith (\\f x -> f x) fs xs) 多个 functors ghci> pure (+) Just 3 Just 5 Just 8 ghci> pure (+) Just 3 Nothing Nothing ghci> pure (+) Nothing Just 5 Nothing ghci> (*) [2,5,10] [8,10,11] [16,20,22,40,50,55,80,100,110] myAction :: IO String myAction = (++) getLine getLine ghci> getZipList $ max ZipList [1,2,3,4,5,3] ZipList [5,3,1,2] [5,3,3,4] 高度封装函数: liftA2 对两个 applicatives 运用二元函数 liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c liftA2 f a b = f a b ghci> liftA2 (:) (Just 3) (Just [4]) Just [3,4] ghci> (:) Just 3 Just [4] Just [3,4] Control.Monad 成员: 类型构造符(type constructor) class Monad m where return :: a -> m a {- bind -}(>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b x >> y = x >>= \\_ -> y fail :: String -> m a fail msg = error msg 特性: 允许返回值之间具有弹性交互 {- 当出现异常后,之后所有的值都变为Nothing -} ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2 Just (2,4) ghci> return (0,0) >>= landLeft 1 >>= landRight 4 \\ >>= landLeft (-1) >>= landRight (-2) Nothing Monad Laws: return 满足 Left identity: retrun x >>= f 等于 f x return 满足 right identity: m >>= return 等于 m Associativity: 结合律 (m >>= f) >>= g 等于 m >>= (\\x -> f x >>= g) ghci> return 3 >>= (\\x -> Just (x+100000)) Just 100003 ghci> (\\x -> Just (x+100000)) 3 Just 100003 ghci> Just \"move on up\" >>= (\\x -> return x) Just \"move on up\" ghci> [1,2,3,4] >>= (\\x -> return x) [1,2,3,4] ghci> putStrLn \"Wah!\" >>= (\\x -> return x) Wah! {-Tips: 利用结合律合并两个 Monadic Function-} ( (b -> m c) -> (a -> m b) -> (a -> m c) f g x >>= f) ghci> let f x = [x,-x] ghci> let g x = [x*3,x*2] ghci> let h = f h 3 [9,-9,6,-6] Maybe Monad 具有失败可能性的 context 封装,灵活处理异常(返回值为 Nothing) 实现 applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b applyMaybe Nothing f = Nothing applyMaybe (Just x) f = f x instance Monad Maybe where return x = Just x Nothing >>= f = Nothing Just x >>= f = f x fail _ = Nothing do 表示法 在 do expression 中，每一行都是一个 monadic value 检查返回值，使用 foo :: Maybe String foo = do x >= (\\x -> Just \"!\" >>= (\\y -> Just (show x ++ y))) routine :: Maybe Pole routine = do start List Monad non-detetminism(不确定性) ghci> (*) [1,2,3] [10,100,1000] [10,100,1000,20,200,2000,30,300,3000] 实现 instance Monad [] where return x = [x] xs >>= f = concat (map f xs) fail _ = [] 返回值交互: 下例中 n 与 return (n, ch) 进行交互 list comprehension 与 do 表示法 均是 >>= 的语法糖 list comprehension: do 表示法: ghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] {- do 表示法 -} listOfTuples :: [(Int,Char)] listOfTuples = do n [ (n,ch) | n MonadPlus 使 Monad 具有 Monoid 的性质(二元封闭运算) instance MonadPlus [] where mzero = [] mplus = (++) Monad Algorithms 马走日 计算出可移动位置 moveKnight :: KnightPos -> [KnightPos] moveKnight (c,r) = do (c',r') 利用 >>= 向后传递多个可交互的位置 in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight in3 :: KnightPos -> [KnightPos] in3 start = do first 最后完成完整函数: 产生所有三步的可能位置，检查其中一个位置是否在里面 canReachIn3 :: KnightPos -> KnightPos -> Bool canReachIn3 start end = end `elem` in3 start Foldable import qualified Data.Foldable as F foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m instance F.Foldable Tree where foldMap f Empty = mempty foldMap f (Node x l r) = F.foldMap f l `mappend` f x `mappend` F.foldMap f r Data.Monoid 成员: 必须为具体类型(*不可是类型构造符(type constructor)) 准则(Monoid Law): 结合律 a·(b·c) = (a·b)·c 无需满足 a mappend b == b mappend a class Monoid m where mempty :: m -- identity mappend :: m -> m -> m mconcat :: [m] -> m mconcat = foldr mappend mempty 实例 instance Monoid [a] where mempty = [] mappend = (++) newtype Product a = Product { getProduct :: a } deriving (Eq, Ord, Read, Show, Bounded) instance Num a => Monoid (Product a) where mempty = Product 1 Product x `mappend` Product y = Product (x * y) ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2 24 newtype Any = Any { getAny :: Bool } deriving (Eq, Ord, Read, Show, Bounded) instance Monoid Any where mempty = Any False Any x `mappend` Any y = Any (x || y) ghci> getAny . mconcat . map Any $ [False, False, False, True] True newtype All = All { getAll :: Bool } deriving (Eq, Ord, Read, Show, Bounded) instance Monoid All where mempty = All True All x `mappend` All y = All (x && y) ghci> getAll . mconcat . map All $ [True, True, False] False instance Monoid Ordering where mempty = EQ LT `mappend` _ = LT EQ `mappend` y = y GT `mappend` _ = GT -- Tips: -- mappend 在左边不等于 EQ 的情况下都会回传左边的值。相反地则回传右边的值 -- 可代替多个 if/else 语句 import Data.Monoid lengthCompare :: String -> String -> Ordering lengthCompare x y = (length x `compare` length y) `mappend` (vowels x `compare` vowels y) `mappend` (x `compare` y) where vowels = length . filter (`elem` \"aeiou\") instance Monoid a => Monoid (Maybe a) where mempty = Nothing Nothing `mappend` m = m m `mappend` Nothing = m Just m1 `mappend` Just m2 = Just (m1 `mappend` m2) instance Monoid (First a) where mempty = First Nothing First (Just x) `mappend` _ = First (Just x) First Nothing `mappend` x = x ghci> getFirst $ First (Just 'a') `mappend` First Nothing Just 'a' 自定义 Typeclass 创建新类: 可以只有声明没有实现 class ClassName where defining code 创建已有类的实例: 必须实现所有已声明函数 作用等同于 deriving(自由度更大) 可以重写函数,去除默认函数处理,达到特定目的 - 先创建新类型 data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False instance Show TrafficLight where show Red = \"Red light\" show Yellow = \"Yellow light\" show Green = \"Green light\" 创建新类和实现实例时,使用 class constraint 可达到类似于继承的效果 可达到限制类型的效果 class (Eq a) => Num a where ... instance (Eq m) => Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False data type data SelfDefinedTypeName = ValueConstructorName ValueType .. | .. deriving (Typeclass, ..) data 范例 data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show) 导出 data module Shapes ( Point(..) , Shape(..) ) where 后构造器 > 前构造器 e.g True > False data Bool = False | True deriving (Ord) 函数特性 data type 也是函数,若省略参数亦会造成 Curry 化. e.g map fx list ghci> map (Circle 10 20) [4,5,6,6] [Circle 10.0 20.0 4.0, Circle 10.0 20.0 5.0, Circle 10.0 20.0 6.0, Circle 10.0 20.0 6.0 ] Value Constructor:使用ValueConstructorName ValueType ..可构造出一个该类型的定义/名字 ghci > Circle 10 20 30 Circle 10 20 30 记录语法(Record Syntax) 定义 data Person = Person { firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , flavor :: String } deriving (Show) 使用 ghci> Car {company=\"Ford\", model=\"Mustang\", year=1967} Car {company = \"Ford\", model = \"Mustang\", year = 1967} 类型参数(Type Parameters) 提高代码的复用性 data Car a b c = Car { company :: a , model :: b , year :: c } deriving (Show) tellCar :: (Show a) => Car String String a -> String tellCar (Car {company = c, model = m, year = y}) = \"This \" ++ c ++ \" \" ++ m ++ \" was made in \" ++ show y Maybe value constructor data Maybe a = Nothing | Just a Just 可实现转化: Just :: a -> Maybe a Deriving(派生) data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) ghci> Wednesday Wednesday ghci> show Wednesday \"Wednesday\" ghci> read \"Saturday\" :: Day Saturday ghci> Saturday == Sunday False ghci> Saturday == Saturday True ghci> Saturday > Friday True ghci> Monday `compare` Wednesday LT ghci> minBound :: Day Monday ghci> maxBound :: Day Sunday ghci> succ Monday Tuesday ghci> pred Saturday Friday ghci> [Thursday .. Sunday] [Thursday,Friday,Saturday,Sunday] ghci> [minBound .. maxBound] :: [Day] [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday] type 定义 为 data 声明别名 - typedef type String = [Char] type PhoneNumber = String type Name = String type PhoneBook = [(Name,PhoneNumber)] type 类型参数: 匹配 data 类型参数 type AssocList k v = [(k,v)] type IntMap v = Map.Map Int v type IntMap = Map.Map Int 类型别名,只可以在 Haskell 的类型部分中使用: 定义新类型 类型声明 类型注释(::) 禁止: 定义名字/定义 AssocList [(1,2),(4,5),(7,9)] 高级数据结构 栈 type Stack = [Int] pop :: Stack -> (Int,Stack) pop (x:xs) = (x,xs) push :: Int -> Stack -> ((),Stack) push a xs = ((),a:xs) 链表 data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord) data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord) 二叉树 data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) singleton :: a -> Tree a singleton x = Node x EmptyTree EmptyTree treeInsert :: (Ord a) => a -> Tree a -> Tree a treeInsert x EmptyTree = singleton x treeInsert x (Node a left right) | x == a = Node x left right | x a = Node a left (treeInsert x right) treeElem :: (Ord a) => a -> Tree a -> Bool treeElem x EmptyTree = False treeElem x (Node a left right) | x == a = True | x a = treeElem x right ghci> let nums = [8,6,4,1,7,3,5] ghci> let numsTree = foldr treeInsert EmptyTree nums 函数 递归函数 边界条件 递归基础 递归函数体 List 函数 边界条件: 空 List 递归函数体: x:xs 取出首元素进行一般操作,对尾部进行递归操作. maximum' :: (Ord a) => [a] -> a maximum' [] = error \"maximum of empty list\" maximum' [x] = x {- maximum' (x:xs) | x > maxTail = x | otherwise = maxTail where maxTail = maximum' xs -} maximum' (x:xs) = max x (maximum' xs) replicate' :: (Num i, Ord i) => i -> a -> [a] replicate' n x | n take' :: (Num i, Ord i) => i -> [a] -> [a] take' n _ | n reverse' :: [a] -> [a] reverse' [] = [] reverse' (x:xs) = reverse' xs ++ [x] repeat' :: a -> [a] repeat' x = x:repeat' x zip' :: [a] -> [b] -> [(a,b)] zip' _ [] = [] zip' [] _ = [] zip' (x:xs) (y:ys) = (x,y):zip' xs ys elem' :: (Eq a) => a -> [a] -> Bool elem' a [] = False elem' a (x:xs) | a == x = True | otherwise = a `elem'` xs Awesome Quick Sort quicksort :: (Ord a) => [a] -> [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a x] in smallerSorted ++ [x] ++ biggerSorted 高阶函数 Curry 化 当传入不全参数时,会改变函数的类型,返回值从单类型变成函数类型. 当传入不全参数时: compare 的类型变为 (Ord a) => a -> (a -> Ordering) compareWithHundred :: (Num a, Ord a) => a -> Ordering compareWithHundred x = compare 100 x 通过给二元中缀函数传递唯一参数: 中缀函数类型由 a -> a -> a 转为 a -> a divideByTen :: (Floating a) => a -> a divideByTen = (/10) ghci> :t (/10) (/10) :: (Fractional a) => a -> a 包装函数: 传入一个二元函数作为参数,便可实现 zipWithFunc 若在定义时便传入一个函数参数,便可实现 Curry 化 zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith' _ [] _ = [] zipWith' _ _ [] = [] zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys ghci> zipWith' (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci> zipWith' max [6,3,2,1] [7,3,1,5] [7,3,2,5] ghci> zipWith' (++) [\"foo \"，\"bar \"，\"baz \"] [\"fighters\"，\"hoppers\"，\"aldrin\"] [\"foo fighters\",\"bar hoppers\",\"baz aldrin\"] ghci> zipWith' (*) (replicate 5 2) [1..] [2,4,6,8,10] ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] [[3,4,6],[9,20,30],[10,12,12]] 通过 Curry 化,还可省略参数 foo a = bar b a -> foo = bar b map 函数 映射函数 - List Comprehension 的函数化 map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs 如果 map 传入的函数参数的类型为 a -> a -> a,则返回的 List 类型为[a -> a](f x 传参不完全,造成了 Curry 化). ghci> let listOfFuns = map (*) [0..] ghci> (listOfFuns !! 4) 5 20 ghci> map (+3) [1,5,3,1,6] [4,8,6,4,9] ghci> map (++ \"!\") [\"BIFF\"，\"BANG\"，\"POW\"] [\"BIFF!\",\"BANG!\",\"POW!\"] ghci> map (replicate 3) [3..6] [[3,3,3],[4,4,4],[5,5,5],[6,6,6]] ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]] [[1,4],[9,16,25,36],[49,64]] ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)] [1,3,6,2,2] filter 函数 过滤函数 - Comprehension 的函数化 filter :: (a -> Bool) -> [a] -> [a] filter _ [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1] [5,6,4] ghci> filter (==3) [1,2,3,4,5] [3] ghci> filter even [1..10] [2,4,6,8,10] ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]] [[1,2,3],[3,4,5],[2,2]] ghci> filter (`elem` ['a'..'z']) \"u LaUgH aT mE BeCaUsE I aM diFfeRent\" \"uagameasadifeent\" ghci> filter (`elem` ['A'..'Z']) \"i lauGh At You BecAuse u r aLL the Same\" \"GAYBALLS\" fold 函数与 scan 函数 如图中所示,左折叠时将 acc 视为第 0 个元素;右折叠时将 acc 视为最后一个元素. 三要素: 二元函数 \\acc x -> function 或 \\x acc -> function 初始累加值 待折叠 List 工作原理: 不断从 List 中取出元素,进行二元函数调用,直至 List 被取空 调用参数分别为 新取出元素 x 与 之前 n 次调用后的累加值 acc 返回值作为下次调用的累加值 acc 左折叠函数 foldl \\acc x -> foldl1: 取 List 首元素作为初始累加值 foldl :: (Foldable t) => (b -> a -> b) -> b -> t a -> b sum' :: (Num a) => [a] -> a sum' xs = foldl (\\acc x -> acc + x) 0 xs 右折叠函数 foldr \\x acc -> foldr1: 取 List 尾元素作为初始累加值 foldr :: (Foldable t) => (a -> b -> b) -> b -> t a -> b map' :: (a -> b) -> [a] -> [b] map' f xs = foldr (\\x acc -> f x : acc) [] xs 更多范例 maximum' :: (Ord a) => [a] -> a maximum' = foldr1 (\\x acc -> if x > acc then x else acc) reverse' :: [a] -> [a] reverse' = foldl (\\acc x -> x : acc) [] product' :: (Num a) => [a] -> a product' = foldr1 (*) filter' :: (a -> Bool) -> [a] -> [a] filter' p = foldr (\\x acc -> if p x then x : acc else acc) [] head' :: [a] -> a head' = foldr1 (\\x _ -> x) last' :: [a] -> a last' = foldl1 (\\_ x -> x) scanl/scanr/scanl1/scanr1 函数会将每次折叠的结果都记录在一个 List 中 ghci> scanl (+) 0 [3,5,2,1] [0,3,8,10,11] ghci> scanr (+) 0 [3,5,2,1] [11,8,3,1,0] ghci> scanl1 (\\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1] [3,4,5,5,7,9,9,9] ghci> scanl (flip (:)) [] [3,2,1] [[],[3],[2,3],[1,2,3]] 逆波兰表达式 import Data.List solveRPN :: String -> Float solveRPN = head . foldl foldingFunction [] . words where foldingFunction (x:y:ys) \"*\" = (x * y):ys foldingFunction (x:y:ys) \"+\" = (x + y):ys foldingFunction (x:y:ys) \"-\" = (y - x):ys foldingFunction (x:y:ys) \"/\" = (y / x):ys foldingFunction (x:y:ys) \"^\" = (y ** x):ys foldingFunction (x:xs) \"ln\" = log x:xs foldingFunction xs \"sum\" = [sum xs] foldingFunction xs numberString = read numberString:xs lambda 表达式 \\args -> function ghci> zipWith (\\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5] [153.0,61.5,31.0,15.75,6.6] ghci> map (\\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)] [3,8,9,8,7] flip' :: (a -> b -> c) -> b -> a -> c flip' f = \\x y -> f y x $函数 ($) :: (a -> b) -> a -> b 特性: 优先级最低,右结合 功能: 改变优先级,相当于在右方添加括号 f (g (z x)) f $ g $ z x .函数与 Function composition(函数组合) (.) :: (b -> c) -> (a -> b) -> a -> c f . g = \\x -> f (g x) - f 的参数类型必须与 g 的返回值类型相同 功能: 可以去除函数调用括号 fn x = ceiling (negate (tan (cos (max 50 x)))) -> 去括号: fn x = ceiling . negate . tan . cos . max 50 x -> Curry化: fn = ceiling . negate . tan . cos . max 50 Best Practice: 三种不同的函数写法 oddSquareSum :: Integer oddSquareSum = sum (takeWhile ( 常用函数 无参函数 “定义”(或者“名字”) tazimi = \"It's a-me, tazimi!\" 前缀函数 > succ 8 9 `FunctionName` - 可使前缀函数变为中缀函数 > 92 `div` 10 9 中缀函数 +: 从类型定义可以看出,+左右两边参数必须为同类型 ghci> :t (+) (+) :: (Num a) => a -> a -> a ++: List 连接符,遍历前一 List ghci> [1,2,3,4] ++ [9,10,11,12] [1,2,3,4,9,10,11,12] ghci> \"hello\" ++ \" \" ++ \"world\" \"hello world\" :: 连接单个元素 ghci> 'A':\" SMALL CAT\" \"A SMALL CAT\" ghci> 5:[1,2,3,4,5] [5,1,2,3,4,5] !!: 引用符 ghci> [9.4,33.2,96.2,11.2,23.25] !! 1 33.2 数学函数 x mod y even arg odd arg System.Random random :: (RandomGen g, Random a) => g -> (a, g) getStdGen newStdGen 数字函数 fromInteger 函数 (Num a) => Integer -> a fromIntegral 函数 (Integral a, Num b) => a -> b 模块 import import Data.List import Data.List (nub，sort) import Data.List hiding (nub) import qualified Data.Map 调用 Map 中的 filter 时,必须使用 Data.Map.filter. import quelified Data.Map as M Data.Map.filter M.filter 建立模块 单一模块 新建一个 Geometry.hs 的文件 module Geometry ( sphereVolume ，sphereArea ，cubeVolume ，cubeArea ，cuboidArea ，cuboidVolume ) where sphereVolume :: Float -> Float sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3) sphereArea :: Float -> Float sphereArea radius = 4 * pi * (radius ^ 2) cubeVolume :: Float -> Float cubeVolume side = cuboidVolume side side side cubeArea :: Float -> Float cubeArea side = cuboidArea side side side cuboidVolume :: Float -> Float -> Float -> Float cuboidVolume a b c = rectangleArea a b * c cuboidArea :: Float -> Float -> Float -> Float cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -> Float -> Float rectangleArea a b = a * b 使用 import Geometry 子模块 把 Geometry 分成三个子模块 建立一个 Geometry 文件夹(注意首字母要大写),新建三个文件 sphere.hs module Geometry.Sphere ( volume ，area ) where volume :: Float -> Float volume radius = (4.0 / 3.0) * pi * (radius ^ 3) area :: Float -> Float area radius = 4 * pi * (radius ^ 2) cuboid.hs module Geometry.Cuboid ( volume ，area ) where volume :: Float -> Float -> Float -> Float volume a b c = rectangleArea a b * c area :: Float -> Float -> Float -> Float area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -> Float -> Float rectangleArea a b = a * b cube.hs module Geometry.Cube ( volume ，area ) where import qualified Geometry.Cuboid as Cuboid volume :: Float -> Float volume side = Cuboid.volume side side side area :: Float -> Float area side = Cuboid.area side side side 使用 import Geometry.Sphere import qualified Geometry.Sphere as Sphere import qualified Geometry.Cuboid as Cuboid import qualified Geometry.Cube as Cube 常用基础模块 Learn you a haskell for great good Data.List intersperse intercalate transpose ghci> transpose [[1,2,3],[4,5,6],[7,8,9]] [[1,4,7],[2,5,8],[3,6,9]] ghci> transpose [\"hey\",\"there\",\"guys\"] [\"htg\",\"ehu\",\"yey\",\"rs\",\"e\"] ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] [18,8,6,17] foldl' 和 foldl1' 是它们各自惰性实现的严格版本,可防止溢出问题. concat - 移除一级嵌套 ghci> concat [\"foo\",\"bar\",\"car\"] \"foobarcar\" ghci> concat [[3,4,5],[2,3,4],[2,1,1]] [3,4,5,2,3,4,2,1,1] concatMap 函数与 map 一个 List 之后再 concat 它等价 ghci> concatMap (replicate 4) [1..3] [1,1,1,1,2,2,2,2,3,3,3,3] and ghci> and $ map (>4) [5,6,7,8] True ghci> and $ map (==4) [4,4,4,3,4] False or ghci> or $ map (==4) [2,3,4,5,6,1] True ghci> or $ map (>4) [1,2,3] False any 和 all 使用 any 或 all 会更多些 ghci> any (==4) [2,3,5,6,1,4] True ghci> all (>4) [6,9,10] True ghci> all (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\" False ghci> any (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\" True iterate 取一个函数和一个值作参数。它会用该值去调用该函数并用所得的结果再次调用该函数，产生一个无限的 List. ghci> take 10 $ iterate (*2) 1 [1,2,4,8,16,32,64,128,256,512] ghci> take 3 $ iterate (++ \"haha\") \"haha\" [\"haha\",\"hahahaha\",\"hahahahahaha\"] splitAt ghci> splitAt 3 \"heyman\" (\"hey\",\"man\") ghci> splitAt 100 \"heyman\" (\"heyman\",\"\") ghci> splitAt (-3) \"heyman\" (\"\",\"heyman\") ghci> let (a,b) = splitAt 3 \"foobar\" in b ++ a \"barfoo\" takeWhile 一旦遇到不符合条件的某元素就停止 ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1] [6,5,4] ghci> takeWhile (/=' ') \"This is a sentence\" \"This\" ghci> sum $ takeWhile ( dropWhile 扔掉符合条件的元素。一旦限制条件返回 False，它就返回 List 的余下部分 ghci> dropWhile (/=' ') \"This is a sentence\" \" is a sentence\" ghci> dropWhile ( span - 扩展takeWhile ghci> let (fw，rest) = span (/=' ') \\ \"This is a sentence\" in \"First word:\" ++ fw ++ \"，the rest:\" ++ rest \"First word: This，the rest: is a sentence\" break - 取反span ghci> break (==4) [1,2,3,4,5,6,7] ([1,2,3],[4,5,6,7]) ghci> span (/=4) [1,2,3,4,5,6,7] ([1,2,3],[4,5,6,7]) sort ghci> sort [8,5,3,2,1,6,4,2] [1,2,2,3,4,5,6,8] ghci> sort \"This will be sorted soon\" \" Tbdeehiillnooorssstw\" group ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7] [[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]] ghci> map (\\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7] [(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)] inits 和 tails ghci> inits \"w00t\" [\"\",\"w\",\"w0\",\"w00\",\"w00t\"] ghci> tails \"w00t\" [\"w00t\",\"00t\",\"0t\",\"t\",\"\"] ghci> let w = \"w00t\" in zip (inits w) (tails w) [(\"\",\"w00t\"),(\"w\",\"00t\"),(\"w0\",\"0t\"),(\"w00\",\"t\"),(\"w00t\",\"\")] isInfixOf 从一个 List 中搜索一个子 List search :: (Eq a) => [a] -> [a] -> Bool search needle haystack = let nlen = length needle in foldl (\\acc x -> if take nlen x == needle then True else acc) False (tails haystack) ghci> \"cat\" `isInfixOf` \"im a cat burglar\" True ghci> \"Cat\" `isInfixOf` \"im a cat burglar\" False ghci> \"cats\" `isInfixOf` \"im a cat burglar\" False isPrefixOf 与 isSuffixOf ghci> \"hey\" `isPrefixOf` \"hey there!\" True ghci> \"hey\" `isPrefixOf` \"oh hey there!\" False ghci> \"there!\" `isSuffixOf` \"oh hey there!\" True ghci> \"there!\" `isSuffixOf` \"oh hey there\" False elem 与 notElem partition ghci> partition (`elem` ['A'..'Z']) \"BOBsidneyMORGANeddy\" (\"BOBMORGAN\",\"sidneyeddy\") ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7] ([5,6,7],[1,3,3,2,1,0,3]) find ghci> find (>4) [1,2,3,4,5,6] Just 5 ghci> find (>9) [1,2,3,4,5,6] Nothing ghci> :t find find :: (a -> Bool) -> [a] -> Maybe a elemIndex '可能' (Maybe)返回我们找的元素的索引,若这一元素不存在，就返回 Nothing. ghci> :t elemIndex elemIndex :: (Eq a) => a -> [a] -> Maybe Int ghci> 4 `elemIndex` [1,2,3,4,5,6] Just 3 ghci> 10 `elemIndex` [1,2,3,4,5,6] Nothing elemIndices 与elemIndex相似. ghci> ' ' `elemIndices` \"Where are the spaces?\" [5,9,13] findIndex 与 find 相似. findIndices 返回所有符合条件的索引. ghci> findIndex (==4) [5,3,2,1,6,4] Just 5 ghci> findIndex (==7) [5,3,2,1,6,4] Nothing ghci> findIndices (`elem` ['A'..'Z']) \"Where Are The Caps?\" [0,6,10,14] ghci> zipWith3 (\\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3] [7,9,8] ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2] [(2,2,5,2),(3,2,5,2),(3,2,3,2)] 在处理来自文件或其它地方的输入时，lines 会非常有用. ghci> lines \"first line\\nsecond line\\nthird line\" [\"first line\",\"second line\",\"third line\"] unlines 是 lines 的反函数. ghci> unlines [\"first line\"，\"second line\"，\"third line\"] \"first line\\nsecond line\\nthird line\\n\" words 和 unwords 可以把一个字串分为一组单词或执行相反的操作. ghci> words \"hey these are the words in this sentence\" [\"hey\",\"these\",\"are\",\"the\",\"words\",\"in\",\"this\",\"sentence\"] ghci> words \"hey these are the words in this\\nsentence\" [\"hey\",\"these\",\"are\",\"the\",\"words\",\"in\",\"this\",\"sentence\"] ghci> unwords [\"hey\",\"there\",\"mate\"] \"hey there mate\" nub 可以将一个 List 中的重复元素全部筛掉. ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1] [1,2,3,4] ghci> nub \"Lots of words and stuff\" \"Lots fwrdanu\" delete ghci> delete 'h' \"hey there ghang!\" \"ey there ghang!\" ghci> delete 'h' . delete 'h' $ \"hey there ghang!\" \"ey tere ghang!\" ghci> delete 'h' . delete 'h' . delete 'h' $ \"hey there ghang!\" \"ey tere gang!\" \\ 差集 ghci> [1..10] \\\\ [2,5,9] [1,3,4,6,7,8,10] ghci> \"Im a big baby\" \\\\ \"big\" \"Im a baby\" union 并集 ghci> \"hey man\" `union` \"man what's up\" \"hey manwt'sup\" ghci> [1..7] `union` [5..10] [1,2,3,4,5,6,7,8,9,10] intersection 交集 ghci> [1..7] `intersect` [5..10] [5,6,7] insert ghci> insert 4 [1,2,3,5,6,7] [1,2,3,4,5,6,7] ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z'] \"abcdefghijklmnopqrstuvwxyz\" ghci> insert 3 [1,2,4,3,2,1] [1,2,3,4,3,2,1] 修正 Prelude 模块 length，take，drop，splitAt，!! 和 replicate Data.List 中包含了更通用的替代版,如: genericLength，genericTake，genericDrop，genericSplitAt，genericIndex 和 genericReplicate nub, delete, union, intsect 和 group 函数 也有各自的通用替代版 nubBy，deleteBy，unionBy，intersectBy 和 groupBy， 它们的区别就是前一组函数使用 (==) 来测试是否相等，而带 By 的那组则取一个函数作参数来判定相等性. ghci> let values = [-4.3，-2.4，-1.2，0.4，2.3，5.9，10.5，29.1，5.3，-2.4，-14.5，2.9，2.3] ghci> groupBy (\\x y -> (x > 0) == (y > 0)) values [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]] on :: (b -> b -> c) -> (a -> b) -> a -> a -> c f `on` g = \\x y -> f (g x) (g y) ghci> groupBy ((==) `on` (> 0)) values [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]] sort，insert，maximum 和 min 都有各自的通用版本。 如 groupBy 类似，sortBy，insertBy，maximumBy 和 minimumBy 都取一个函数来比较两个元素的大小. ghci> let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]] ghci> sortBy (compare `on` length) xs [[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]] Data.Char isControl 判断一个字符是否是控制字符。 isSpace 判断一个字符是否是空格字符，包括空格，tab，换行符等. isLower 判断一个字符是否为小写. isUper 判断一个字符是否为大写。 isAlpha 判断一个字符是否为字母. isAlphaNum 判断一个字符是否为字母或数字. isPrint 判断一个字符是否是可打印的. isDigit 判断一个字符是否为数字. isOctDigit 判断一个字符是否为八进制数字. isHexDigit 判断一个字符是否为十六进制数字. isLetter 判断一个字符是否为字母. isMark 判断是否为 unicode 注音字符，你如果是法国人就会经常用到的. isNumber 判断一个字符是否为数字. isPunctuation 判断一个字符是否为标点符号. isSymbol判断一个字符是否为货币符号. isSeperater 判断一个字符是否为 unicode 空格或分隔符. isAscii 判断一个字符是否在 unicode 字母表的前 128 位。 isLatin1 判断一个字符是否在 unicode 字母表的前 256 位. isAsciiUpper 判断一个字符是否为大写的 ascii 字符. isAsciiLower 判断一个字符是否为小写的 ascii 字符. ghci> all isAlphaNum \"bobby283\" True ghci> all isAlphaNum \"eddy the fish!\" False ghci> words \"hey guys its me\" [\"hey\",\"guys\",\"its\",\"me\"] ghci> groupBy ((==) `on` isSpace) \"hey guys its me\" [\"hey\",\" \",\"guys\",\" \",\"its\",\" \",\"me\"] ghci> ghci> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ \"hey guys its me\" [\"hey\",\"guys\",\"its\",\"me\"] ghci> generalCategory ' ' Space ghci> generalCategory 'A' UppercaseLetter ghci> generalCategory 'a' LowercaseLetter ghci> generalCategory '.' OtherPunctuation ghci> generalCategory '9' DecimalNumber ghci> map generalCategory \" \\t\\nA9?|\" [Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol] toUpper 将一个字符转为大写字母，若该字符不是小写字母，就按原值返回. toLower 将一个字符转为小写字母，若该字符不是大写字母，就按原值返回. toTitle 将一个字符转为 title-case，对大多数字元而言，title-case 就是大写. digitToInt 将一个字符转为 Int 值，而这一字符必须得在 '1'..'9','a'..'f'或'A'..'F' 的范围之内. ghci> map digitToInt \"34538\" [3,4,5,3,8] ghci> map digitToInt \"FF85AB\" [15,15,8,5,10,11] ghci> intToDigit 15 'f' ghci> intToDigit 5 '5' ord 与 char 函数可以将字符与其对应的数字相互转换. ghci> ord 'a' 97 ghci> chr 97 'a' ghci> map ord \"abcdefgh\" [97,98,99,100,101,102,103,104] encode :: Int -> String -> String encode shift msg = let ords = map ord msg shifted = map (+ shift) ords in map chr shifted decode :: Int -> String -> String decode shift msg = encode (negate shift) msg Data.Map findKey :: (Eq k) => k -> [(k,v)] -> v findKey key xs = snd . head . filter (\\(k,v) -> key == k) $ xs findKey :: (Eq k) => k -> [(k,v)] -> Maybe v findKey key [] = Nothing findKey key ((k,v):xs) = if key == k then Just v else findKey key xs findKey :: (Eq k) => k -> [(k,v)] -> Maybe v findKey key = foldr (\\(k,v) acc -> if key == k then Just v else acc) Nothing fromList 取一个关联列表，返回一个与之等价的 Map。 Map.fromList :: (Ord k) => [(k，v)] -> Map.Map k v 若其中存在重复的键,就将其忽略. ghci> Map.empty fromList [] insert ghci> Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100 Map.empty)) fromList [(3,100),(4,200),(5,600)] ghci> Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty fromList [(3,100),(4,200),(5,600)] fromList' :: (Ord k) => [(k,v)] -> Map.Map k v fromList' = foldr (\\(k,v) acc -> Map.insert k v acc) Map.empty null ghci> Map.null Map.empty True size ghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)] 5 singleton ghci> Map.singleton 3 9 fromList [(3,9)] ghci> Map.insert 5 9 $ Map.singleton 3 9 fromList [(3,9),(5,9)] lookup member ghci> Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)] True ghci> Map.member 3 $ Map.fromList [(2,5),(4,5)] False map 与 filter 与其对应的 List 版本相似 toList 是 fromList 的反函数 ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3 [(4,3),(9,2)] keys 与 elems phoneBook = [(\"betty\",\"555-2938\") ,(\"betty\",\"342-2492\") ,(\"bonnie\",\"452-2928\") ,(\"patsy\",\"493-2928\") ,(\"patsy\",\"943-2929\") ,(\"patsy\",\"827-9162\") ,(\"lucille\",\"205-2928\") ,(\"wendy\",\"939-8282\") ,(\"penny\",\"853-2492\") ,(\"penny\",\"555-2111\") ] phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String phoneBookToMap xs = Map.fromListWith (\\number1 number2 -> number1 ++ \", \" ++ number2) xs ghci> Map.lookup \"patsy\" $ phoneBookToMap phoneBook \"827-9162, 943-2929, 493-2928\" ghci> Map.lookup \"wendy\" $ phoneBookToMap phoneBook \"939-8282\" ghci> Map.lookup \"betty\" $ phoneBookToMap phoneBook \"342-2492，555-2938\" phoneBookToMap :: (Ord k) => [(k，a)] -> Map.Map k [a] phoneBookToMap xs = Map.fromListWith (++) $ map (\\(k,v) -> (k,[v])) xs ghci> Map.lookup \"patsy\" $ phoneBookToMap phoneBook [\"827-9162\",\"943-2929\",\"493-2928\"] 在遇到重复元素时，单选最大的那个值. ghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)] fromList [(2,100),(3,29),(4,22)] 将相同键的值都加在一起. ghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)] fromList [(2,108),(3,62),(4,37)] insertWith ghci> Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)] fromList [(3,104),(5,103),(6,339)] Data.Set 内部元素排序且唯一 import qualified Data.Set as Set fromList ghci> let set1 = Set.fromList text1 ghci> let set2 = Set.fromList text2 ghci> set1 fromList \" .?AIRadefhijlmnorstuy\" ghci> set2 fromList \" !Tabcdefghilmnorstuvwy\" ghci> Set.intersection set1 set2 fromList \" adefhilmnorstuy\" difference 差集 ghci> Set.difference set1 set2 fromList \".?AIRj\" ghci> Set.difference set2 set1 fromList \"!Tbcgvw\" union 并集 ghci> Set.union set1 set2 fromList \" !.?AIRTabcdefghijlmnorstuvwy\" null，size，member，empty，singleton，insert，delete ghci> Set.null Set.empty True ghci> Set.null $ Set.fromList [3,4,5,5,4,3] False ghci> Set.size $ Set.fromList [3,4,5,3,4,5] 3 ghci> Set.singleton 9 fromList [9] ghci> Set.insert 4 $ Set.fromList [9,3,8,1] fromList [1,3,4,8,9] ghci> Set.insert 8 $ Set.fromList [5..10] fromList [5,6,7,8,9,10] ghci> Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5] fromList [3,5] ghci> Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5] True ghci> Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5] True ghci> Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5] False ghci> Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5] False 执行 map 和 filter: ghci> Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4] fromList [3,5,7] ghci> Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4] fromList [3,4,5,6,7,8] 删除重复元素 ghci> let setNub xs = Set.toList $ Set.fromList xs ghci> setNub \"HEY WHATS CRACKALACKIN\" \" ACEHIKLNRSTWY\" ghci> nub \"HEY WHATS CRACKALACKIN\" \"HEY WATSCRKLIN\" 输入与输出 IO action name : 将 action 绑定至名字上,IO String -> String name 在一个do block中,最后一个action不能绑定任何名字,它会被绑定成为do block的结果值. main = do foo return return 功能:将 pure value 包成 I/O actions,不会终止函数/程序 return 作用: if condition then I/O action else I/O action 改变do block形成的I/O action的结果值: otherIOaction -> return pureValue e.g return \"haha\" - String -> IO String main = do line String reverseWords = unwords . map reverse . words Command Line System.Environment getArgs: getArgs :: IO [String] getProgName: getProgName :: IO String import System.Environment import Data.List main = do args import System.Environment import System.Directory import System.IO import Data.List dispatch :: [(String, [String] -> IO ())] dispatch = [ (\"add\", add) , (\"view\", view) , (\"remove\", remove) ] main = do (command:args) IO () add [fileName, todoItem] = appendFile fileName (todoItem ++ \"\\n\") view :: [String] -> IO () view [fileName] = do contents show n ++ \" - \" ++ line) [0..] todoTasks putStr $ unlines numberedTasks remove :: [String] -> IO () remove [fileName, numberString] = do handle BtyeString Data.ByteString Data.ByteString.Lazy lazy bytestrings 像装了一堆大小为 64K 的 strict bytestrings 的 list import qualified Data.ByteString.Lazy as B import qualified Data.ByteString as S pack/unpack fromChunks/toChunks cons/empty/head/tail/init/null/length/map/reverse/foldl/foldr/concat/takeWhile/filter 常用输入输出函数 输出 putChar/putStr/putStrLn putStr :: String -> IO () putStr [] = return () putStr (x:xs) = do putChar x putStr xs print print = putStrLn . show File/System.IO hPutStr hPutStrLn writeFile writefile :: FilePath -> String -> IO () - WriteMode, not AppendMode appendFile 输入 getChar :: IO Char main = do c getContents getContents :: IO String (Lazy I/O) - 内容暂存在文件,需要使用时读取至内存区 import Data.Char main = do contents File handle data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode openFile :: FilePath(String) -> IOMode -> IO Handle hGetContents :: Handle -> IO String hClose :: Handle -> IO () hGetChar hGetLine import System.IO main = do handle withFile withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a import System.IO main = do withFile \"girlfriend.txt\" ReadMode (\\handle -> do contents readFile contents Action when Control.Monad.when :: (Applicative f) => Bool -> f () -> f () when bool表达式 I/O-Action - 真时返回 Action,假时return () import Control.Monad main = do c sequence sequence :: [IO a] -> IO [a] main = do rs mapM mapM_ Control.Monad.forM = sequence . map ghci> mapM print [1,2,3] 1 2 3 [(),(),()] ghci> mapM_ print [1,2,3] 1 2 3 Control.Monad.forever 接受一个 I/O action 并回传一个永远作同一件事的 I/O action 以下代码实现了循环结构: import Control.Monad import Data.Char main = forever $ do putStr \"Give me some input: \" l hSetBuffering data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int) hSetBuffering :: Handle -> BufferMode -> IO () main = do withFile \"something.txt\" ReadMode (\\handle -> do hSetBuffering handle $ BlockBuffering (Just 2048) contents hFlush Other lines lines :: String -> [String] - 按换行符将段落切割成句子 interact arguments: String -> String 的函数 return: 一个 I/O action function: I/O action 会读取输入，调用提供的函数，然后把函数的结果打印出来 main = interact shortLinesOnly shortLinesOnly :: String -> String shortLinesOnly input = let allLines = lines input shortLines = filter (\\line -> length line main = interact $ unlines . filter (( respondPalindromes = unlines . map (\\xs -> if isPalindrome xs then \"palindrome\" else \"not a palindrome\") . lines where isPalindrome xs = xs == reverse xs System.Directory - removeFile/renameFile 异常 System.IO.Error catch catch :: IO a -> (IOError -> IO a) -> IO a import System.Environment import System.IO import System.IO.Error main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) IO () handler e | isDoesNotExistError e = putStrLn \"The file doesn't exist!\" | isFullError e = freeSomeSpace | isIllegalOperation e = notifyCops | otherwise = ioError e Advanced Monad Writer Monad Writer 可以让我们在计算的同时搜集所有 log 纪录，并汇集成一个 log 并附加在结果上 applyLog :: (a,String) -> (a -> (b,String)) -> (b,String) applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog) ghci> (30, \"A freaking platoon.\") `applyLog` isBigGang (True,\"A freaking platoon.Compared gang size to 9\") ghci> (\"Bathcat\",\"Got outlaw name.\") `applyLog` (\\x -> (length x, \"Applied length\")) (7,\"Got outlaw name.Applied length\") Control.Monad.Writer instance (Monoid w) => Monad (Writer w) where return x = Writer (x, mempty) (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v') import Control.Monad.Writer logNumber :: Int -> Writer [String] Int logNumber x = Writer (x, [\"Got number: \" ++ show x]) multWithLog :: Writer [String] Int multWithLog = do a Reader Monad instance Monad ((->) r) where return x = \\_ -> x h >>= f = \\w -> f (h w) w State Monad Control.Monad.State newtype State s a = State { runState :: s -> (a,s) } instance Monad (State s) where return x = State $ \\s -> (x,s) (State h) >>= f = State $ \\s -> let (a, newState) = h s (State g) = f a in g newState Control.Monad.State (MonadState) get = State $ \\s -> (s,s) put newState = State $ \\s -> ((),newState) 实例 import Control.Monad.State pop :: State Stack Int pop = State $ \\(x:xs) -> (x,xs) push :: Int -> State Stack () push a = State $ \\xs -> ((),a:xs) stackManip :: State Stack Int stackManip = do push 3 a Error Monad instance (Error e) => Monad (Either e) where return x = Right x Right x >>= f = f x Left err >>= f = Left err fail msg = Left (strMsg msg) ghci> :t strMsg strMsg :: (Error a) => String -> a ghci> strMsg \"boom!\" :: String \"boom!\" Useful Monad Functions HustCSer Repo liftM join filterM foldM (组合函数) Self-Defined Monad 注释 符号 -- 单行注释 {- -} 块注释 {-# #-} (文件头部)编译器参数 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/java/javaBasicNotes.html":{"url":"language/java/javaBasicNotes.html","title":"Java Basic Notes","keywords":"","body":"Java Basic Notes Java Basic Notes CLI Tools 编译 运行 反汇编 打包 Gradle Tool build.gradle 基本结构 数据类型 整型 类型 前/后缀 浮点型 float 型 double 型 字符型 布尔型 引用类型 数组(Array) 类(Class) 接口(Interface) 常量 运算符 短路与、短路或 移位符 字符串连接运算符 + 判断运算符 == ()强制类型转换运算符 +字符串连接符 字符串 子串 相等 代码点 常用方法 构建字符串 输入输出 Scanner 类 格式化输出方法 System.out.printf() 文件的输入与输出 输入(至内存) 输出(至文件) 表达式 控制流程 块作用域 switch 语句 loop 语句 循环五要素 for each 循环 break、continue 语句 break：跳出当前循环层 continue：跳过当前这次循环，进入下一次循环 大数值 java.math.BigInteger 类 java.math.BigDecimal 类 数组 定义+引用 初始化 方法 命令行参数——字符串数组 String[] args 排序 多维数组(数组的数组，引用的引用) 对象与类 面向对象的三大特征 封装性 继承性 多态性 完整的 Java 源文件 Behavior,State,Identity 预定义类 构造器(Constructor) GregoriaCalendar 类(日历类) 用户自定义类 完整的类定义 访问器方法(Accessor Method) 更改器方法(Mutator Method) 方法 Method 方法参数 方法标签(Signature) 对象构造 构造器方法的定义 构造器方法的执行 包 类路径 文档注释 类注释：位于类定义前 方法注释：位于方法定义前 域注释：位于实例域定义前 通用注释 @see 与@link 包注释 类设计技巧 数据私有化 数据初始化 实例域封装化 构造器多样化 职责明晰化 继承 父类与子类(superclass and subclass) 属性的继承 方法的继承 方法的覆盖 方法的重载 super 关键字 父类与子类的转换(Is-A 关系) Object 类 equals 方法 hashCode 方法 toString 方法 泛型数组列表 对象包装器与自动装箱 父类：Number final 类(强不可变类)：无子类，不可改变数 编译器特性 API 说明 可变参数方法 枚举类 定义 扩展 访问控制符 非访问控制符 abstract abstract 方法 abstract 类 final final 局部变量(方法内的变量) final 实例域 final 方法 final 类 static static 实例域(类域) static 方法 static final 实例域 反射(Reflection) 反射机制 Class 类 分析类的能力 分析对象 泛型数组实现 调用任意方法(函数指针) 接口与内部类 接口 基本定义 接口方法 实现接口 接口作为方法参数 接口变量 对象克隆 Cloneable 接口 Object 类的 clone 方法 自定义 clone 方法 回调 回调设计模式 ActionListener 接口 内部类 内部类调用格式 局部内部类 匿名内部类 静态内部类 代理类 图形程序设计 Swing 组件继承层次 Swing 组件功能层次 JFrame 内部结构：重点位于 ContentPane 框架基础 位置和大小 属性(get/set、is/set) 自定义绘制组件 继承 JComponent 绘制法 class 继承 JPanel 绘制法：另类用法 实现 Shape 接口绘制法：处理 2D 图形 图形颜色 事件处理 定义与基础 事件源与事件监听器 实现 ActionListner 接口的事件监听器 适用情况 事件监听器对象执行其他对象事件源产生事件影响 自动创建监听器：EventHandler 类 改变 Swing 组件观感(LookAndFeel) 适配器类 XXAdapter 类 动作 Aciton 接口与 AbstractAction 类 基本方法 动作与点击按钮：将自定义动作与按钮关联 动作与按键映射：每个组件有三个输入映射和一个动作映射 鼠标事件 AWT 事件继承层次 事件类 事件处理 监听器接口 事件处理 适配器类 Swing 组件 Awt 和 Swing 设计中的设计模式 组合(composite)模式 装饰器(decorator)模式 策略(strategy)模式 模型-视图-控制器(model-view-controller)模式 简单布局管理器 流式布局(FlowLayout 类) 边框布局(BorderLayout 类) 网格布局(GridLayout 类) 复杂布局管理器 网格组布局(GridBagLayout 类) 基本步骤 组布局 (GroupLayout 类) 空布局(null，不使用布局管理器) 自定义布局 文本组件 文本域(JTextField 组件) 标签(JLabel 组件) 密码域(JPassWordField 组件) 文本区(JTextArea 组件) 滚动窗格(JScrollPane 类) 选择组件 复选框(JCheckBox 组件) 单选按钮(ButtonGroup 类 add JRadioButton 类) 边框 组合框(JComboBox 组件，泛型类) 滑动条(JSlider 组件) 菜单组件 创建菜单 图标菜单项 单选按钮/复选框菜单项 弹出菜单(JPopupMenu 组件) 快捷键 启用/禁用菜单项 工具栏(JToolBar 组件) 对话框(顶级框架) 选项对话框(JOptionPane 组件) 自定义对话框 文件对话框(JFileChooser 组件插入对话框) 颜色对话框(JColorChooser 组件插入对话框) 部署应用程序 JNLP API Applet 首选项 异常、断言、日志、调试 处理错误 异常分类 捕获异常 捕获多个异常 重抛异常 关闭异常：关闭频率低/不可能发生的异常 记录日志 调试技巧 使用断言 JUnit 框架单元测试 日志代理 Throwable.printStackTrace() GUI 调试 泛型 泛型类 泛型方法 泛型变量 T 泛型代码 使用限制 通配符类型 反射与泛型 集合 集合接口 Collection 接口：泛型接口 AbstractCollection 类：实现 Collection 接口 迭代器：泛型接口 Iterable 接口：泛型接口 Queue 接口与 Deque 接口 具体集合 数组列表(ArrayList implements List) 链表(LinkedList implements List，Deque) 散列集 树集 比较接口 Comparable 接口：泛型接口 Comparator 接口(比较器)：泛型接口 队列 映射表 集合框架 集合算法 早期集合 线程 线程基础 线程状态 new runnable blocked/waiting/timed waiting：不活动状态 blocked waiting timed waiting terminated 线程属性 优先级：默认情况下继承父线程的优先级 Thread.setDaemon(true) 未捕获异常的处理器 中断线程 Interrupt 方法 InterruptedException 处理 InterruptedException 线程同步 锁对象(实例域) 条件对象(实例域) 内部锁：synchronized 关键字 截获内部锁 读写锁 监视器 volatile 关键字:修饰实例域 死锁 ThreadLocal 辅助类 线程安全 原子整数 线程安全集合 异步计算 执行器 同步器 线程与 Swing:事件分配线程 Self-Defined Class 常用工具类 输入与输出 输入 输出 正则表达式 基本写法 matcher.group(int) Garbage Collection Garbage Collection Optimization GC Tools CLI Tools 编译 javac name.java 运行 java name(无后缀类名) 反汇编 javap –c name(无后缀类名) 打包 jar {c t x u f} [v m e 0 M i][-c 目录] 文件名 解释： c：创建 jar 包 t：显示 jar 包内容 x：解压 jar 包 u：添加文件到 jar 包 f：命名 jar 包 v：显示详细执行过程报告 m：指定 manufest.mf 文件(对 jar 包做相关设置) 0：打包 jar 包是不压缩 M：不产生 manufest.mf 文件，覆盖 m 参数的设置 i：创建索引文件 C：进入某目录后再执行 jar 命令 生成 API 文档：java doc –d [ ] 类名/包名 可选参数： -author/-version：文档中显示作者和版本信息(默认不显示) -link superlink 标准类名：为标准类添加超链接 -linksourse：方法/类名转化为超链接，指向生成的 html 格式的源文件 Gradle Tool sudo apt install gradle gradle help gradle tasks gradle assemble gradle build gradle clean gradle test gradle jar gradle javadoc build.gradle apply plugin: 'java' jar { manifest { attributes 'Main-Class': 'com.sabertazimi.tao.Tao' } } 基本结构 数据类型 整型 类型 byte 型:1 字节 -128~127 short 型:2 字节 -2^15~2^15 -1 int 型:4 字节 -2^31~2^31 -1(20 亿) long 型:8 字节 -2^63~2^63 -1 前/后缀 二进制前缀 0b/0B 八进制前缀 0 十六进制前缀 0x/0X 长整型后缀 l/L 浮点型 float 型 后缀 F:4 字节 -3403E38~3.403E38(有效位数 6~7 位) float f = 1.2; //ERROR float f = 1.2F; //OK double 型 后缀 D(默认型):8 字节 -1798E308~1.798E308(有效位数 15 位) 科学计数法：指数均为十进制，符号为 e(尾数为十进制)/p(尾数为十六进制) Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY，Double.isNaN(检数) 千分位下划线分隔法 e.g 123_456.789_000 字符型 1 个 char 型占 2 个字节(Unicode 编码) ’ ’(定界符)内可用八/十六进制转义字符表示字符 八:\\xxx 十六:\\uxxxx(\\u 转义序列可出现在任何地方) e.g ‘\\u0061’ 改进的 Unicode 字符集: 代码点(前缀 U+)分为 17 个代码级别(code plane) 第一个级别为经典 Unicode 代码， 其余附加级别 U+10000 至 U+10FFFF。 布尔型 只允许赋值为 true、false(不可取 0 或非 0 值)，不可与整型相互转换 引用类型 数组(Array) 字符串 String：不可变性(需要修改变量名所引用值，必须重新创建一个 String 对象例) 旧的对象实例若被判定为垃圾便会被系统自动回收 类(Class) 接口(Interface) 常量 定义(随使用随定义) 运算符 短路与、短路或 &&:第一个操作数为假不再向后运算 ||:第一个操作数为真不再向后运算 移位符 有符号右移>>:最高位补符号位 左操作数 int/long，右操作数 mod32/mod64 e.g int a >> 33 即 int a >> 1 无符号右移>>>:最高位补 0 字符串连接运算符 + 左右操作数 String 字符串/其他类型(自动被转化为 String) 判断运算符 == 基本类型值相等，引用类型引用相等 基本类型：转换后比较；boolean 型不与 int 型比较 引用类型：指向两个不同对象实例的变量不相等;若判断两个对象实例内容是否相等，必须调用 equals()方法 ()强制类型转换运算符 只能在继承层次内进行强制类型转换(同一家族) 将父类转换为子类前，应使用 instanceof 运算符进行检查 +字符串连接符 调用 toString 方法 x.toString() \"\"+x; 字符串 子串 stringTest.substring(a, b)方法返回长度为 b-a 的子串，a(包括)、b(不包括)为起止位置 相等 内容相等：stringOne.equals(stringTwo)方法返回值 true/false 不区分大小写 equalsIgnoreCase 代码点 常用方法 构建字符串 StringBuilder 类：单线程，功能同 StringBuffer 类(多线程) 输入输出 Scanner 类 监视器，功能最强大的输入类，new Scanner(System.in) 格式化输出方法 System.out.printf() 静态创建格式化字符串 文件的输入与输出 输入(至内存) 用 File 对象构造一个 Scanner 对象：new Scanner(Paths.get(“FileName”))(反斜杠需双写) 输出(至文件) 用文件名构造一个 PrintWriter 对象: new PrintWriter(“FileName”), 之后调用System.PrintWriter.print方法. 表达式 整数提升:算术运算前 byte,short,char 提升为 int 没有”,”运算符和表达式语句 控制流程 合法语句：赋值语句和方法调用语句 块作用域 不允许内层块与外层块变量同名(无 C 语言中的可见性) 块内声明变量不允许在块外使用：if 块、for 块、while 块、普通 block switch 语句 case 标签变量类型：字符型(包装类)、三整型(包装类)、枚举常量、字符串类 loop 语句 循环五要素 初始化部分(init_statement); 循环条件部分(test_explanation); 循环体部分(body_statement); 迭代部分(alter_statement):自加/自减运算符改变条件变量 结束后处理 for each 循环 //只读遍历；变量age只作用于for循环体 for (int age : arrayName) {} break、continue 语句 break：跳出当前循环层 label: { break label; } //可跳出任意语句块：跳至标签块末尾 continue：跳过当前这次循环，进入下一次循环 label: { continue label; } //跳至循环块首部 大数值 java.math.BigInteger 类 java.math.BigDecimal 类 数组 定义+引用 类型(包括类/对象) + [] + 标识符 类型(包括类/对象) + 标识符 + [] int a[N] 非法 数组是引用类型 不可对数组名进行自增操作(尽管[]与*具有类似作用) 初始化 默认初始化数值类型为 0/false，引用类型为 null 使用 new 分配内存单元 两种不同初始化方式： 声明时：MyDate[] dates = {new Mydate(),……}; 赋值时：MyDate[] dates = new MyDate[] (匿名数组){new Mydate(),…..}; 方法 属性:arrayName.length 打印:arrays.toString 方法 复制:arrayName.Copy( source, 0, destination, 0, source.length); Arrays.copyOf(ArrayName, Array.length); //可用来增长数组长度 比较:Arrays.equals(type[] a,type[] b); 命令行参数——字符串数组 String[] args args 数组不包括程序名 排序 Arrays.sort(ArrayName)快速排序方法 多维数组(数组的数组，引用的引用) 多维数组的声明和初始化应按从高维到低维的顺序进行 声明&初始化 int[][] t = new int[3][]; 子数组交换 atemp = a[i];a[i]=a[i+1];a[i+1]=atemp; 子数组长度可不一致：可先构造一维长度，再使用循环构造子数组各自长度 对象与类 面向对象的三大特征 封装性 模块化+信息隐蔽(隐藏细节(private)，只提供受保护的访问接口(public)) 只可通过方法改变对象实例的状态(State)(Instance Field) 继承性 父类和子类共享数据和方法（提高代码重用率和可维护性） 可继承成员：公有域、公有方法 不可继承成员：私有域、静态域、实例域初始化块、私有方法、静态方法、构造器方法 多态性 不同的对象收到同一个消息(method 调用)可产生不同效果(由对象内封装的细节决定) 编译时多态：重载(Overload) 运行时多态：覆盖(Override) 根据对象实例的类型进行动态绑定(Dynamic Binding) 虚方法调用(Virtual Method Invoking) ： 在调用方法时，程序会正确地调用子类对象的方法 无法进行虚方法调用情况 static 的方法：以声明类型(标识符前的类型)为准，无关实例类型 final/private 方法：子类无法覆盖/继承父类同名方法，不存在虚化问题 完整的 Java 源文件 package packageName; //指定文件中的类所在的包，0个或1个 import packageName.[className|*]; //指定引入的类/API，0个或多个 public classDefinition //属性为public的类定义，0个或1个 interfaceDefinition and classDefinition //接口或类定义，0个或多个 Behavior,State,Identity 预定义类 构造器(Constructor) GregoriaCalendar 类(日历类) 用户自定义类 完整的类定义 [public] [abstact|final] class className[extends superclassName] [implements interfaceNameList] { //成员变量声明，可为多个： //实例域一般添加private修饰符，保持封装性 [public | protected | private] [static] [final] [transient] [volatile]type variableName; //方法(包括构造方法)定义及实现，可为多个 [public | protected | private] [static] [final | abstract] [native] [synchronized] returnType methodName( [paramList] ) [throws exceptionList]{ statements; } } class Class_Name{ int/String characteristic; //状态(State)：变量(实例域 instance field) constructor(){}; //标识(Identity)：构造器(constructor) void function(){}; //行为(Behavior)：函数(方法method) } 访问器方法(Accessor Method) 只访问实例域不进行修改的方法 returnType get() { //保持封装性 //返回引用类型对象时，必须返回克隆体对象引用而不是实例域对象引用 return instanceFieldVariable.clone(); } 更改器方法(Mutator Method) 修改实例域的方法 e.g add、set 方法 Method 方法参数 Java 所有普通方法的参数传递方式:值传递 基本类型：传递值的拷贝 方法中无法更改原变量的值 引用类型：传递引用的拷贝 方法中无法更改原变量的引用(指针指向),只可更改引用对象的状态(State) 方法标签(Signature) 方法名称 方法参数 方法返回值类型不是方法标签(不存在同名同参而不同返回值的方法) 对象构造 构造器方法完整定义： ClassName (ClassPropertiesVariableTable) { //进行输入参数合法化检查 Property n = Variablea; Statement Block; } 构造器方法的定义 未定义任何构造器方法 系统会自动产生一个构造器方法，称为无参空默认构造器方法（defaultconstructor） 并将所有实例域初始化为默认值 注意事项 不应在构造器中定义实例域同名变量 在构造器中尽量只调用 final/private 方法(不会(继承后)被子类方法覆盖) this()可调用此类的其他构造方法，this()必须位于构造器方法首行 构造器方法的执行 构造器方法前语句/语句块将先于构造器执行 编译器会在编译时在每个构造器方法内首行自动添加 super();(若父类没有无参构造器方法编译出错)/人工显式调用父类构造器方法，直至实现 Object 类(超类)的构造器方法，再执行构造器方法语句 包 导入 import 包的导入 import java.包路径.* //导入指定包的所有类 静态导入 import static java.包路径.类名.* //导入指令类的所有静态域和静态方法 类路径 package 语句 文档注释 Java 除了可以采用我们常见的注释方式（//、/* */(二型注释不可嵌套)）之外,Java 语言规范还定义了一种特殊的 Javadoc 注释： /** *@author 对类的说明 标明开发该类模块的作者 *@version 对类的说明 标明该类模块的版本 *@see 对类、属性、方法的说明 参考转向，也就是相关主题 *@param 对方法的说明 对方法中某参数的说明 *@return 对方法的说明 对方法返回值的说明 *@exception 对方法的说明 对方法可能抛出的异常进行说明 *@Override 对方法覆盖的说明 *@FunctionalInterface 函数式接口：包含不超过一个abstract方法（可以有其他非abstract方法） */ 类注释：位于类定义前 /** *整体性描述 * * @author 作者 * @version 1.0, 05/22/07 * @since version1.0 */ 方法注释：位于方法定义前 /** *整体性描述 * *@param 对方法的说明 对方法中某参数的说明 *@return 对方法的说明 对方法返回值的说明 *@exception/throws 对方法的说明 对方法可能抛出的异常进行说明 */ 域注释：位于实例域定义前 /** * 备注信息 */ 通用注释 @see 与@link 可在文档中看到引用(文本、类/方法/变量、超链接) @see/@link package.class#feature label @see/@link label @see/@link “text” 区别: link 注释可在任意位置，see 注释需在类/方法/变量定义前 包注释 新建 package-info.java 源文件: package 包路径 /** * 包注释 */ 类设计技巧 数据私有化 保持封装性 数据初始化 不依赖实例域默认值，且应进行数据合法化检查 实例域封装化 过多相关的基本类型实例域可封装成一个轻型类 构造器多样化 最低标准为显式无参构造器+一个带参数(包括合法化检查)构造器 职责明晰化 一个类的方法应与类本身紧密相关，且不过少也不过多 继承 父类与子类(superclass and subclass) 属性的继承 可继承：公有域 不可继承：私有域、静态域、实例域初始化块 若要访问(修改)父类私有域，必须使用调用公有的 super.get()方法得到父类私有域 初始化父类私有域：super(ParamList); 调用父类构造方法进行初始化 方法的继承 可继承：公有方法 不可继承：私有方法、静态方法、构造器方法 方法的覆盖 标签相同(不可降低父类方法可见性) 方法的重载 标签不同，属于新加方法 super 关键字 不是隐式参数，是提示编译器执行的特殊关键字 父类与子类的转换(Is-A 关系) Subclass must be superclass,superclass may not be subclass. 可将子类引用赋值给父类变量(Upcasting)或替换父类作参数 Person p = new Student(); //p仍是父类变量 注：若父类变量和子类变量引用同一个子类对象实例时，父类某些操作可能引起内存混乱 例如：先调用父类构造器方法构造子类，再调用子类扩展方法访问子类扩展私有域(根本未分配内存空间) 不可将父类引用赋值给子类变量 Student s = new Person(); //ERROR:e.g. s.getStuID(); Object 类 equals 方法 子类中覆盖(@override)父类 equals 方法：super.equals(superClassName other); 显式参数名：Object otherObject if (this == otherObject) return true; if (otherObject == null) return false; if (getClass != otherObject.getClass()) return false; ClassName other = (ClassName) otherObject; return field == other.field hashCode 方法 String 类 hashCode：ΣStringChar[i]^(n-i-1), (i:0~(n-1)) Objec 对象 hashCode：内部 ID(存储地址) 若重写 equals 方法，也应重写 hashCode 方法，使对象实例 hashCode 分布散列化 return 各域 hashCode 值加权和:31x+y rule 引用类型、包装类：hashCode() 数组：Arrays.deepHashCode() return Objects.hash(field1,..,fieldn); //自动组合各域 hashCode hash 值：return (key.hashCode() & 0x7fffffff) % M; toString 方法 设计 return getClass().getName() + ”[“ + field + ”]”; Object 类 toString 方法：用于输出 CassName 和 hashCode 数组直接继承 Object 类 toSrting 方法，输出数组需调用 Arrays.(deep)toString(); 自动调用：+ 字符串连接符、println(obj) 泛型数组列表 ArrayList VariableName = new ArrayList<>(); toArray(ArrayName)转化为同类型普通数组存至 ArrayName：可以创建一个 ArrayList，再转化为数组，方便使用[]下标操作 插入、删除操作时间复杂度高(数据元素左/右移) 对象包装器与自动装箱 Void,Boolean,Byte,Character,Short,Integer, Long, Float, Double 类:包装器(Wrapper)类 父类：Number final 类(强不可变类)：无子类，不可改变数 编译器特性 自动装箱（auto-boxing） Integer I = 10; myArrayList.add(10); 自动拆箱（auto-unboxing） int i= I; 自动装箱+拆箱 Integer I = 0;I++; // 实际译为: Integer I = Integer.valueOf(10); myArrayList.add(Integer.valueOf(10)); Int I = I.intValue(); API 说明 可变参数方法 枚举类 定义 扩展 访问控制符 public>protected(包作用域+)>默认(包作用域)>private(类作用域) 最大限度：不同包的非子类(所有类)、同一个包/不同包的子类、同一个包、同一个类 非访问控制符 abstract abstract 方法 语法形式：abstract + MethodName(ParamList)； abstract 类 定义 若一个类包含 abstract 方法，则必须是 abstract 类 一个 abstract 类可以不包含 abstrat 方法 一个 abstract 类可以包含具体数据和具体方法 构造器方法 需要实现构造器方法 构造器方法可以被非 abstract 子类调用 不能使用 new 构造 abstract 类对象实例 final final 局部变量(方法内的变量) 只读常量，必须进行一次初始化 final 实例域 必须进行一次(类定义/构造器)初始化 final 引用类型实例域的引用不可更改，但所引用对象的状态(State)可被更改 final 方法 可继承，不可重写 final 类 不可继承 实例域可以不是 final 实例域，方法自动成为 final 方法 static static 实例域(类域) 属于类整体，保存在类的内存区域的公共存储单元(不可继承) 可通过类名/对象实例名访问该属性 static 方法 类方法，属于类整体(不可继承) 没有隐式参数(this/super) 只能处理该类中的 static 实例域/调用该类中的 static 方法 既可通过类名调用该方法(推荐)，又可通过对象实例名调用 static 方法 Tips:工厂模式：利用 static 方法可模拟构造器方法：可自定义构造器名和返回对象类型 static final 实例域 默认初始化(数值型为 0，布尔型为 false，引用型为 null) 常结合 public 将变量设置为全局静态常量 e.g. e、PI 反射(Reflection) 反射机制 运行中分析 类的能力 运行中查看对象 实现通用的数组操作代码 利用 Method 对象 Class 类 分析类的能力 分析对象 泛型数组实现 调用任意方法(函数指针) 接口与内部类 接口 基本定义 interface 类型是引用类型 常量 + 方法 [修饰符(public)]interface 接口名 [extends 父接口名列表(多个接口)] { //常量声明，可为多个 [public] [static] [final] type constantName= Value; //方法声明，可为多个 [public] [abstract] retumType methodName( [paramList] ); } 接口方法 自动默认：public abstract 方法(声明时无需关键字) 实现接口 在类中必须实现(override)接口中的所有方法 接口作为方法参数 设计此类方法时： 可调用接口中公有静态常量/公有方法(interfaceVariableName.invokeMethod) 可将接口参数传递给其他接口作参数的方法，调用其他方法 实际调用方法时：将实现了该接口的类作为参数传递给方法，可提高方法的灵活性 例子：Comparable 接口和 sort 静态方法 接口变量 不可创建 interface 实例(即不可用 new 关键字) 可声明一个 interface 变量，并使其引用实现了该接口的对象实例 //TimePrinter：实现了ActionListener接口的类 ActionListener myListener = new TimePrinter(); 对象克隆 Cloneable 接口 标签接口(tagging interface)之一：无方法 Object 类的 clone 方法 浅拷贝: 无法克隆目标对象实例域中的对象成员 自定义 clone 方法 鉴于默认 clone 方法的局限性，需自定义用户需要的 clone 方法 实现接口：implements Cloneable 改变可见性&抛出异常: public clone() throws CloneNotSupportedException {}; 自定义克隆体：克隆子对象 回调 回调设计模式 某个特定事件发生时采取某个特定动作 ActionListener 接口 内部类 内部类调用格式 声明与构造(实例化) OuterClass.InnerClass variableName = OuterClass/this.new InnerClass(); 定义：应使用 private 关键字 访问实例域/方法 内部类：this.fieldName/methodName 外部类：OuterClass.this.fieldName/methodName 局部内部类 定义在方法中的内部类 修饰符：无/abstract/final 可访问外围类成员/final 局部变量 匿名内部类 在实际构造父类/实现接口时定义在构造器方法中的内部类 外围为父类：内部类需要扩展该父类 new SuperType (construction parameters) { inner class methods and data{}; //直接定义实例域和方法，构造器参数传递给父类构造器 } 外围为接口：内部类需要实现该接口 new InterfaceType () //一对括号 { Inner class methods and data{}; //需实现接口中的所有抽象方法 } 例子：积分、线程、回调函数(HookFunction)、事件处理(ActionListener) 静态内部类 只可访问外围类的静态域/静态方法(可视作不可访问外围类) 实例化：new OuterClass.InnerClass() 代理类 图形程序设计 Swing 组件继承层次 Swing 组件功能层次 JFrame 内部结构：重点位于 ContentPane 框架基础 位置和大小 方法概览 //继承于：Component类 //功能：设置JFrame的位置和大小 //坐标：相对于电脑屏幕 setLocation(x, y); setBounds(x, y, width, height); setLocationByPlatform(true); 动态设置 //得到屏幕大小 Dimension screenSize = Toolkit.getDefaultToolKit().getScreenSize(); int screenWidth = screensSize.width; int screenHeight = screenSize.height; //根据屏幕大小设置框架大小 setSize(screenWidth / 2, screenHeight / 2); setLocationByPlatform(true); 属性(get/set、is/set) 标题 //继承于：Frame类 //功能：标题属性 public String getTitle(); public void setTitle (String title); 定位 //继承于：Window类 //功能：定位属性 public boolean isLocationByPlatform(); public void setLocationByPlatform (boolean b); 标题图标 Image img = new ImageIcon(“icon.gif”).getImage(); setIconImage(img); 其他属性 自定义绘制组件 所有绘制都使用 Graphics 类作参数(包含绘制图案、图像、文本等的方法) 继承 JComponent 绘制法 class class MyComponent extends JComponent { //@override public void paintComponent (Graphics g) { g.drawString(text, x, y); } //@override public Dimension getPreferredSize() { return new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT) } } 继承 JPanel 绘制法：另类用法 class MyJPanel extends JPanel { public void paintComponent(Graphics g) { super.paintComponent(g); code for drawing; } } 实现 Shape 接口绘制法：处理 2D 图形 图形类继承关系图 图形颜色 Color 类预定义颜色(Color.XX) SystemColor 类预定义颜色(SystemColor.XX) 事件处理 定义与基础 事件源与事件监听器 实现 ActionListner 接口的事件监听器 适用情况 按钮点击事件(click button) 鼠标双击选择列表框某一选项 选择某一菜单项 文本域键入回车键 imer 组件达到指定时间间隔 事件监听器对象执行其他对象事件源产生事件影响 此时，可使用匿名内部类或 Lambda 表达式简化代码 .addActionListener(new ActionListener() { public void actionPerformed(ActionEvevt event) { //code for procedure } }); 或 .addActionListener( (e) -> { //code for procedure }); 自动创建监听器：EventHandler 类 改变 Swing 组件观感(LookAndFeel) 适配器类 XXAdapter 类 此类实现相应接口所有方法，但每个方法方法体皆空;简化 Listener 实现，只需重写所需方法 .addWindowLister(new WindowAdapter() { //重写所需方法 }); 动作 Aciton 接口与 AbstractAction 类 Action 接口可连接多个事件源，AbstractAction 类是实现该接口的类(可继承此类编写动作) 基本方法 actionPerformed：继承于 ActionListener 接口 enabled：启用/禁用动作 value：动作对象中的任意名/值 e.g.Action.NAME,“按键名称” key 为动作属性的名称，value 为对应具体属性(如 String、ImageIcon) propertyChangeListener：将动作对象属性变化传给监听器，再传给其他组件对象 动作与点击按钮：将自定义动作与按钮关联 JButton 构造器：JButton(Action act); 动作与按键映射：每个组件有三个输入映射和一个动作映射 建立输入映射(三种方式得到(次)顶层组件的输入映射) InputMap imap = panel.getInputMap(JComponent.InputMapFlag); 关联输入映射和动作映射:put 方法含有两个参数 imap.put( KeyStroke.getKeyStroke(“ctrl Y”) , Object actionMapKeyName ); 建立动作映射 ActionMap amap = panel.getActionMap(); 关联动作映射和动作:put 方法含有两个参数 amap.put(Object actionMapkeyName , Action act); 注：将 Object 设为 String ”none” 时 表示 空动作(按键无效) 鼠标事件 AWT 事件继承层次 事件类 语义事件类(semantic)： ActionEvent、AdjustmentEvent、ItemEvent 低级事件类(low-level) FocusEvent、MouseEvent、MouseWheelEvent、KeyEvent、WindowEvent 事件处理 监听器接口 事件处理 适配器类 FocusAdapter MouseAdapter MouseMotionAdapter KeyAdapter WindowAdapter Swing 组件 Awt 和 Swing 设计中的设计模式 组合(composite)模式 将对象组合成树形结构以表示”部分-整体“的层次结构，使得用户对单个对象和组合对象的使用具有一致性 容器与组件(具有共同接口) - 容器与组件具有层次结构,用户可对容器与组件实施同样的操作(点击、删除、输入等) 装饰器(decorator)模式 保持接口，增强性能 以对客户透明的方式动态地给一个对象附加上更多的责任(对象前后本体未变化) 抽象组件(Component)角色: 给出一个抽象接口，以规范准备接收附加责任的对象(透明不变性) 具体组件(ConcreteComponent)角色: 定义一个将要接收附加责任的类(透明不变性) 装饰(Decorator)角色: 持有一个组件对象的实例 定义一个与抽象构件组件接口一致的接口 添加额外功能 具体装饰(ConcreteDecorator)角色: 负责给组件对象“贴上”附加的责任 带滚动条的面板 Component：面板,Decorator：滚动条 策略(strategy)模式 动态改变行为 定义了不同的算法族，并且之间可以互相替换 环境对象：实现了抽象策略接口或者引用了具体策略类 抽象策略接口/类：接口/抽象类，环境对象中变化部分 具体策略类：实现了抽象策略接口，可有多个不同的具体策略类(动态变化) 设计原则: 把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口 布局管理器 环境对象：面板，抽象策略：抽象布局管理接口，具体策略：具体布局管理类 模型-视图-控制器(model-view-controller)模式 组件三要素：外观、内容(状态)、行为 模型类：存储内容(状态) state getter/setter 视图类：显示内容(状态)对应外观 一个模型可以有多个视图(模型的不同部分/形式) 控制器类：处理用户输入事件(点击鼠标、敲击键盘)，改变模型类/视图类状态，调用模型类/视图类中方法 一个模型类可以适用多个组件(如 DefaultButtonModel 是多种 Button 包装器类的模型对象): 几乎所有组件都有一个带后缀 UI 的视图对象;不是所有组件都有一个专门的控制器对象 简单布局管理器 流式布局(FlowLayout 类) 逐行填充组件，可设置对齐方式和组件间距 边框布局(BorderLayout 类) 改变面板大小时，只有中央组件大小变化 技巧：可在五个区块内添加子面板 frame.add(panel, BorderLayout.CENTER/NORTH/SOUTH/WEST/EAST) 网格布局(GridLayout 类) 组件按行列排列，且大小一致(只能逐行逐列添加组件) 复杂布局管理器 网格组布局(GridBagLayout 类) 没有行列大小和个数限制的网格布局：行列大小可不一致，可合并相邻行/列(合并单元格) gridBagPanel.add(component, GridBagConstraints);给每一个组件都构造一个 GridBagConstraints 类 基本步骤 画框图 设置 gridXX 四值 设置 fill/anchor 值、 设置增量 weightx/weight 全部 100：行列可随容器大小变化 设置某一行/列所有 weightx/weighty 为 0：此行/列保持默认大小 e. gridBagPanel.add(component, GridBagConstraints); 组布局 (GroupLayout 类) 通过(嵌套)组的水平与垂直计算(间距与组件)，实现灵活的布局: GroupLayout 类 Group 类 ParallelGroup 类 SequentialGroup 类 空布局(null，不使用布局管理器) 自定义布局 实现 LayoutManager 接口，自定义 setSizes(Container parent) 在 layoutContainer 方法中调用每个组件的 setBounds 方法，摆放组件 文本组件 JTextComponent 抽象类 文本域(JTextField 组件) 标签(JLabel 组件) 标签无法响应用户输入事件，只提供标识功能 密码域(JPassWordField 组件) 文本区(JTextArea 组件) 滚动窗格(JScrollPane 类) 将文本区组件/其他组件插入到滚动窗格中，可实现文本区/其他组件的滚动 选择组件 复选框(JCheckBox 组件) 勾取选项(可自定义选项标签)：勾选/不勾选状态 .addActionListener( if ( .isSelected() ) {……}); 多个复选框可共用一个监听器，通过 isSelected 方法检测不同复选框的状态 单选按钮(ButtonGroup 类 add JRadioButton 类) ButtonGroup 对象负责调度任务：保证只有一个 JRadioButton 对象被按下 JRadioButton 对象:add 至 JPanel 对象,add 至 ButtonGroup 对象,addActionListener 注册监听器 边框 在面板/子面板(TextPanel、ButtonPanel 功能区等)调用 setBorder 方法填充边框 组合框(JComboBox 组件，泛型类) 下拉选框(N 个选项 Item)，.addActionListener( getItemAt( getSelectedIndex() ) ) 滑动条(JSlider 组件) 可连续选择数值 .addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent event) { Jslider source = (JSlider) event.getSource(); int Value = source.getValue(); code for operating; //with Value } }); 菜单组件 创建菜单 JMenuBar –> JMenu -> JMenuItem 利用 Action 创建 MenuItem：(调用 insert 方法) Action exitAction = new AbstractAction (“ Exit ”) //MenuItems text goes here { public void actionPerformed (ActionEvent event) { code for action; } }; 图标菜单项 JMenuItem 类扩展 AbstractButton 类 同样地，JMenuItem 类构造器/Action.putValue(Action.SMALL_ICON,……)； 单选按钮/复选框菜单项 将 MenuBar 视作 JPanel 即可 弹出菜单(JPopupMenu 组件) 不依附于 MenuBar 的浮动菜单(Window 系统下右键弹出菜单) 快捷键 同样地，两个方式：MenuItem 类构造器/Action.putValue(Action.MNEMONIC_KEY,……)； 加速器：不打开菜单项即可起作用的快捷键(如 Ctrl+……)，关联 JMenuItem 启用/禁用菜单项 工具栏(JToolBar 组件) 同样地，JToolBar 构造器/Action.putValue(Action.SHORT_DESCRIPTION,……)； 对话框(顶级框架) 模式对话框：弹出时不允许用户作其他交互 无模式对话框：弹出时允许用户作其他交互(如工具栏) 选项对话框(JOptionPane 组件) 自定义对话框 在构造器中调用超类 Jdialog 构造器方法 添加对话框的用户界面组件 添加事件处理器 设置对话框大小 文件对话框(JFileChooser 组件插入对话框) 文件选择器 文件过滤器：可添加文件视图类 颜色对话框(JColorChooser 组件插入对话框) 部署应用程序 JNLP API Applet 首选项 异常、断言、日志、调试 处理错误 异常分类 已检查异常：需要抛出声明(非 RuntimeException) 未检查异常：不可控(Error)/可避免(RuntimeException：下标越界等) 子类覆盖父类方法(该方法)抛出必检异常数必须少于父类方法 捕获异常 原则：捕获知道如何处理的异常，传递不知如何处理的异常 捕获多个异常 普通形式 try { 语句组(可能抛出异常的语句：抛出异常后，try语句块直接终止) } catch (匹配Exception ex) { 子子异常类名 异常处理语句组； } catch (匹配Exception ex) { 子异常类名 异常处理语句组； } catch (匹配Exception ex) { 父异常类名 异常处理语句组； } [ finally { 必定(即使try return)会被执行异常处理语句组：用于释放资源，不能捕获异常 }] catch:0~n, finally:可选项（无论是否有 break/return，都会被执行多遍） 更好的形式 try { try { code that might throw exceptions{}; } finally { in.close(); } } catch (IOException e) { show error message{}; throw exception{}; throw new exception{}; } 常用 catch 处理语句 System.out.println(“Error” + e); System.out,println(“Cause” + e.getCause()); throw e; throw new Exception(String)/(String, e); 重抛异常 将当前捕获的异常再次抛出：throw e; 重新生成并抛出一个新异常(沿调用堆栈传递) hrow new Exception(\"some message\"); throw new Exception(\"some message\"，e); 将原始异常作为新异常的 initCause catch (SQLException e) { Throwable se = new ServletException(“database error”); se.initCause(e); throw se; } 上级便可通过 se.getCause()方法得到原始异常 关闭异常：关闭频率低/不可能发生的异常 catch 语句体为空，便可关闭捕获的异常 记录日志 调试技巧 使用断言 assert 表达式:字符串信息 JUnit 框架单元测试 import static org.JUnit.Assert.* 为每个类构置一个 main 方法进行单元测试 日志代理 Logger.getGlobal().info(\" ……\" + targetVariableName); Throwable.printStackTrace() GUI 调试 泛型 泛型类 自定义类型 Class Person {} 泛型方法 自定义方法 [修饰符] T PeronMethod(Param) {} 泛型变量 T 类型变量用“，”分隔，限定类型用“&”分隔(一个父类+多个接口) 泛型代码 翻译关键：擦除类型参数，用 Object/限定类型代换 虚拟机中没有泛型 多态性：合成桥方法 类型安全性：必要时插入强制类型转换 使用限制 T 类型变量：不可为基本类型，必须为引用类型 类型查询(getClass()/instanceof)：返回原始类型(如 Person)，不返回 T 类型 不可创建参数化类型的数组(如 Person[]) 不可实例化类型变量(如 new T()、new T[]) 不可在静态域/方法中引用类型变量(如 private static T variableName) 泛型类不可扩展 Throwable 及其子类(因此泛型类不可被抛出/捕获) 通配符类型 反射与泛型 集合 集合接口 Collection 接口：泛型接口 AbstractCollection 类：实现 Collection 接口 将 size 和 iterator 抽象化，将 contains、toString 具体化 迭代器：泛型接口 工作位置: 迭代器位于两元素间 工作机制 previos 方法：迭代器越过前一元素，并将该元素的引用作为返回值 next 方法：迭代器越过下一元素，并将该元素的引用作为返回值 工作方法 add 方法：将新元素的引用插入至迭代器当前位置 remove 方法：与 previos/next 相互依赖，删除前一次越过元素(不可连续调用 remove 方法) next->( remove )->next->remove 使用原则 给容器附加多个只读迭代器，单独附加唯一一个读写迭代器 并发修改检测: 只检测结构性改变(改变长度),不检测数值性改变(如 set 方法) Iterable 接口：泛型接口 任何实现了 Iterable 接口及其子接口(如 Collection 接口)的对象都可使用 for each 循环 public interface Iterable { Iterator iterator(); } Queue 接口与 Deque 接口 Deque extends Queue extends Collection) 具体集合 数组列表(ArrayList implements List) 随机访问：利用索引值访问元素 get/set(int Index)方法：效率高 链表(LinkedList implements List，Deque) 非随机存取：必须从头/尾开始遍历链表访问元素 E get(int Index)方法：效率极低 ListIterator: add 方法：依赖于迭代器位置 remove 方法：依赖于迭代器状态 previousIndex 方法：返回迭代器前一元素的整数索引 nextIndex 方法：返回迭代器后一元素的整数索引 散列集 HashSet implements Set：无序无重复元素集，基于 HashTable 散列表：列表/链表数组(多个列表/链表)，每个列表/链表成为桶(bucket) 元素的桶的整数索引：元素散列码 mod 桶的总数(余数) 桶数：预计元素个数的 75%~150% e.g 标准类库桶数为 2 的 n 次方，默认值 16 散列冲突(hash collision)：目标桶已满 再散列(rehashed)：创建大通数(如双倍桶数)的新散列表，丢弃原散列表 装填因子(load factor)：再散列时机决定因素，一般为 0.75(75%桶中含有至少一个元素) hash 值：return (key.hashCode() & 0x7fffffff) % M; 方法 add：先查找对象存在性，不存在则添加元素 contains：重写方法 散列集迭代器：依次访问所有桶 树集 TreeSet implements SortedSet，NavigableSet：有序集 比较接口 Comparable 接口：泛型接口 // AB正值(B代表other) public interface Comparable { int compareTo(T other); } Comparator 接口(比较器)：泛型接口 // AB正值 public interface Comparator { int compare(T a, T b); } SortedSet setSortedByName = new TreeSet<>(Comparetor comp)；//实现比较器的类 队列 双端队列: ArrayDeque 类与 LinkedList 类 优先级队列: PriorityQueue 类, 未对所有元素进行排序 add 和 remove 方法: 引用最小元素 映射表 实现 Map 接口，未实现 Collection 接口 散列/比较函数只作用于键 key 添加/删除/检索对象时，必须提供键 key 键 key 具有唯一性 集合框架 RandomAccess 接口：标记接口，无任何方法，标记一个集合是否支持高效的随机访问 集合算法 早期集合 线程 线程基础 线程：分享 CPU、共享内存(多个线程访问同一数据/对象) 线程一般用于需长时间执行的任务：循环、下载、浏览图片 线程状态 new 创建线程的方法： 父类:继承 Thread 类，重写 run 方法 接口:new Thread(Runnable Task)实现 Runnable 接口的类：实名类/匿名类/Lambda 表达式 runnable thread.start() 线程处于可运行状态：可能在运行，可能不在运行，不必始终保持运行 blocked/waiting/timed waiting：不活动状态 blocked 获取锁不得时，进入阻塞状态 waiting 等待调度器时，进入等待状态 timed waiting 调用含超时参数的方法时，进入计时等待状态保持到超时或通知 Object.wait、Thread.sleep、Thread.join、Lock.tryLock、Condition.await terminated run 方法正常退出或抛出未捕获异常时，进入(自然/意外)死亡状态 线程属性 优先级：默认情况下继承父线程的优先级 需防止低优先级线程被饿死(因此不要依赖优先级进行编程) MIN_PRIORITY(1)~NORM_PRIORITY(5)~MAX_PRIORITY(10) 每当线程调度器选择新线程时,首选具有较高优先级的线程 Thread.setDaemon(true) 设置为后台线程：随时可能中断 虚拟机会在只有后台线程时退出,后台线程不可访问固有资源(文件、数据库等) 未捕获异常的处理器 实现 Thread.UncaughtExceptionHandler 接口 不安装默认处理器时,默认处理器为空 中断线程 Interrupt 方法 对一个线程调用此方法时,线程将进入中断状态 InterruptedException 对一个阻塞线程(调用 sleep/wait 方法等)调用 interrupt 方法时，抛出此异常 处理 InterruptedException 线程同步 两个线程都有多个语句，无法保证一个线程所有语句全部执行完再调用另一个线程,必然会出现交错调用不同线程中的语句现象，导致调用混乱现象 锁对象(实例域) 可重复(持有计数)，可共用(共用锁对象的方法可互相调用) 条件对象(实例域) 管理有锁却不能正常工作的线程 一个锁对象可以有多个相关的条件对象 内部锁：synchronized 关键字 每个对象都有一个内部锁，可将静态方法声明为 synchronized 等价于 wait/notifyAll 等价于 await/signalAll 截获内部锁 读写锁 监视器 volatile 关键字:修饰实例域 声明一个域可并发更新,通知编译器和虚拟器注意此特性 死锁 所有线程处于等待或阻塞状态 e.g. 两个线程互相等待状态 ThreadLocal 辅助类 线程安全 java.util.concurrent 并发 API：线程安全(同时只有一个线程调用某对象) 原子整数 AtomicInteger.getAndIncrement(); //cnt++; AtomicInteger.getAndDecrement(); //cnt— AtomicBoolead、AtomicLong、AtomicReference类 线程安全集合 阻塞队列 高效映射表、队列 写数组列表和写数组集的拷贝 - CopyOnWriteArrayList 类、CopyOnWriteArraySet 类 同步包装器(synchronization wrapper) - 任何集合类通过同步包装器变成线程安全集合类 异步计算 执行器 线程池：创建大量生命周期短的线程 CachedThreadPool：提交任务多，创建新线程 FixedThreadPool：提交任务多，等待当前任务完成再运行其他任务 SingleThreadExecutor：逐一执行提交任务 ScheduledExecutorServiec 接口：预定执行/重复执行任务 以上工厂方法返回：实现 ExecutorService 接口的 ThreadPoolExecutor 对象 创建 ExecutorService pool = Executors.newCachedThreadPool(); 方法 pool.execute(myTask); pool.shutdown(); Future 对象用于查询任务完成情况 同步器 线程与 Swing:事件分配线程 事件分配线程不应进行 input/output/sleep 调用(可能使线程阻塞) Timer 类(亦是线程)：每隔一段时间重复执行 MyTask 更新图形化界面：SwingUtilites.invokeLater(Runnable MyTask); EventQueue.invokeLater(new Runnable() { public void run() { Statements; } }); 指定布局(Layout) 以下可合成一个方法: 创建组件(Component) 添加组件(getContentPane.add(Component) //得到 Container 类) 响应事件(Event) 设置属性(size、location、bounds、locationByPlatform、title、iconImage、visible、resizable、undecorated、extendedState) // 取得点击按钮的名字 String itemName = ((JRadioButton) e.getSource()).getText(); //Source：事件源(点击按钮事件) Self-Defined Class @override: euqals hashCode toString Comparable(compareTo) Cloneable(clone) 常用工具类 java.lang Java 语言的核心类库 java.util 实用工具 java.io 标准输入/输出类库 java.awt/javax.swing 图形用户界面(GUI)的类库 java.net 网络功能的类库 java.sql 数据库访问的类库 java.io 输入输出流 输入与输出 输入 InputStream 类：read(字节) Reader 类：read(char) 输出 OutputStream 类：write、flush、close Writer 类：write(char,String)、flush、close 正则表达式 基本写法 ([字符]){数量}\\位置 matcher.group(int) 0 表示整个正则表达式，i 表示第 i 个圆括号 Garbage Collection Garbage Collection Optimization GC 优化的核心思路: 尽可能让对象在新生代中分配和回收, 尽量避免过多对象进入老年代, 导致对老年代频繁进行垃圾回收, 同时给系统足够的内存减少新生代垃圾回收次数. 分析系统的运行状况: 系统每秒请求数, 每个请求创建多少对象, 占用多少内存 Young GC 触发频率, 对象进入老年代的速率 老年代占用内存, Full GC 触发频率, Full GC 触发的原因, 长时间 Full GC 的原因 GC Tools 监控告警系统：Zabbix、Prometheus、Open-Falcon jdk 自动实时内存监控工具：VisualVM 堆外内存监控：Java VisualVM 安装 Buffer Pools 插件、google perf工具、Java NMT(Native Memory Tracking)工具 GC 日志分析：GCViewer、gceasy # jstat：JVM 自带命令行工具, 可用于统计内存分配速率、GC 次数，GC 耗时 jstat -gc # jmap：JVM 自带命令行工具, 可用于了解系统运行时的对象分布 jmap -histo jmap -dump:live,format=b,file=dump.hprof # 用来查看正在运行的 Java 应用程序的扩展参数 # 包括 Java System 属性和 JVM 命令行参数 jinfo © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/java/javaNamingConventions.html":{"url":"language/java/javaNamingConventions.html","title":"Java Naming Conventions","keywords":"","body":"Java Naming Conventions Java Naming Conventions 使用前注意事项 包名的书写规范 （Package） Package 一般要求 Package 实际应用 类名的书写规范 (Class) Class 一般要求 Class 实际应用 变量的命名 普通变量 Var 一般要求 Var 实际应用 变量使用技巧 静态变量 方法的命名 Method 一般要求 Method 实际应用 使用前注意事项 由于 Java 面向对象编程的特性, 在命名时应尽量选择名词 驼峰命名法（Camel-Case） 当变量名或函式名是由一个或多个单字连结在一起，而构成的唯一识别字时，首字母以小写开头，每个单词首字母大写（第一个单词除外）。 包名的书写规范 （Package） 推荐使用公司或机构的顶级域名为包名的前缀，目的是保证各公司/机构内所使用的包名的唯一性。包名全部为小写字母，且具有实际的区分意义。 Package 一般要求 选择有意义的名字，能快速地传达该类的用途。 所有包的命名必须采用小写英文字母。 Package 实际应用 应用系统中经常应用分层，Dao 层（数据库访问）、Service 层（业务处理）、Web 层（页面控制 action 类） 包名的前几个为固定名称, 如果是网站的话，采用网站的域名的反写，如果域名还没有确定的话，采用公司固定的几个名称。如：net.vschool 在包名的接下来一个单词为模块的名称。如：用户模块，包名为 net.vschool.user 关于模块的访问操作，采用分层形式,一般分为： Dao 层操作：一般定义在 net.vschool.xxx.dao 中，其中 xxx 为模块名称。Service 层操作：一般定义在 net.vschool.xxx.servie 中。web 层操作：一般定义在 net.vschool.xxx.action 中。 net.vschool.usernet.vschool.user.daonet.vschool.user.actionnet.vschool.user.service 类名的书写规范 (Class) 类名必须使用名词，如果一个类名内含多个单词，那么各个单词第一个字母大写，后续字母小写，起伏呈驼峰状，人称驼峰式命名。给类名命名时，必须保证准确、简洁且容易理解。尽量使用完整单词，避免使用缩写词（除了大家公认的） 类 Class 一般要求 选择有意义的名字，能快速地传达该类的用途。 参照 java 驼峰命名法，类名的首字母必须采用大写的形式，如果类名为多词组合而成的话，那么每个词的首字母必须采用大写。如：StudentAnswer.java 当要区别接口类和实现类的时候，可以在类的后面加上“Impl”。 推荐实体类没有后缀名。 public class 应与.java 文件同名 Class 实际应用 应用系统中经常应用分层，Dao 层（数据库访问）、Service 层（业务处理）、Web 层（页面控制 action 类），每一层的类的名称尽量带上该层后缀。 Dao 层 接口类：采用 JavaBean+Interface+Dao 的形式来定义,即，实体对象+Interface+Dao 实现类：采用 JavaBean+Interface+Impl+Dao 的形式来定义,即，实体对象+Interface+Impl+Dao Service 层 接口类：采用 Xxx+Interface+Service 的形式来定义,即，模块+Interface+Service 实现类：采用 Xxx+Interface+Impl+Service 的形式来定义,即，模块+Interface+Impl+Service Web 层（action 类） 实现类：采用县 Xxx+Operator+Action 的形式来定义,即，模块+操作+Action 变量的命名 普通变量 Var 一般要求 选择有意义的名字，能快速地传达该变量的用途。 参照 java 驼峰命名法，首字母以小写开头，每个单词首字母大写（第一个单词除外）。 Var 实际应用 变量命名采用基本结构为 typeVariableName，使用 3 字符前缀来表示数据类型。 做数组用时，再加前缀-a,如字符串数组：astr， 自定义类型的变量可以采用本身的名称，把首字母改为小写。 采用名称要能代表在方法中的意义。如果员工列表：employeeList 原词 缩写 byte byt char chr float flt boolean bln Integer/int int short sht Long/long lng Double/double dbl string str 变量使用技巧 在一段函数中不使用同一个变量表示前后意义不同的两个数值。 除非是在循环中，否则一般不推荐使用单个字母作为变量名，i、j、k 等只作为小型循环的循环索引变量。 避免用 Flag 来命名状态变量。 用 Is 来命名逻辑变量，如：blnFileIsFound。通过这种给布尔变量肯定形式的命名方式，使得其它开发人员能够更为清楚的理解布尔变量所代表的意义。 如果需要对变量名进行缩写时，一定要注意整个代码中缩写规则的一致性。 例如，如果在代码的某些区域中使用 intCnt，而在另一些区域中又使用 intCount，就会给代码增加不必要的复杂性. 建议变量名中尽量不要出现缩写. 静态变量 选择有意义的名字，能快速地传达该变量的用途。 参照 java 驼峰命名法，采用全部大写的形式来书写，对于采用多词合成的变量采用-来连接各单词。如：USER_LIST 方法的命名 Method 一般要求 选择有意义的名字，能快速地传达该方法的用途。 参照 java 驼峰命名法，首字母以小写开头，每个单词首字母大写（第一个单词除外）。 Method 实际应用 方法表示一种行为，它代表一种动作，最好是一个动词或者动词词组或者第一个单词为一个动词。 属性方法：以 get/set 开头，其后跟字段名称，字段名称首字母大写。如：getUserName() 数据层方法：只能以 insert（插入）,delete（删除）,update（更新）,select（查找）,count（统计）开头 他层方法避免以这个 5 个单词开头，以免造成误解。 服务层方法，根据方法的行为命名，只描述方法的意义，而不采用方法的目的命名. 比如系统的添加新用户，用户可以前台注册，也可以管理员后台添加，方法会被重用，所以最好不要用使用 register，采用 add 会更好写. 避免使用与 web 层相关的方法. Web 层方法最好是贴近 web 的语言，如 register，login，logout 等方法。 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/python/pythonBasicNotes.html":{"url":"language/python/pythonBasicNotes.html","title":"Python Basic Notes","keywords":"","body":"Python Basic Notes Python Basic Notes Python Basics Basic Types Tuples Baisc Control Statement For Loop While Loop Functions Classes NumPy Basics Numpy Array Creation Numpy Indexing Numpy Matrix Operations CLI Application Basic CLI Progress Bar Process Data Files CSV File JSON File XML File Plain Text File Converter Matplotlib Usage Plot Type Basic Usage Plot Style Plot Axis Tick Plot Legend Subplot Double y-axis 3D Plot Paper Figures Config Paper Standard Awesome Library Debugging and Testing Python Basics Basic Types Tuples tuples in python are immutable Baisc Control Statement For Loop for i in range(3): # goes from i = 0 to i = 2 x += 1 for i in [0, 1, 2]: x += 1 While Loop while x > 0: x -= 1 Functions def join_name(first_name, last_name): joined_name = first_name + \" \" + last_name return joined_name Classes class Pet(object): def __init__(self, species, color, name): self.species = species self.color = color self.name = name def __str__(self): return \"{0} {1} named {2}.\".format(self.color, self.species, self.name) def change_name(self, new_name): self.name = new_name my_dog = Pet(species=\"dog\", color=\"orange\", name=\"Guiness\") print(my_dog) print(my_dog.name) # => output: # orange dog named Guiness. # Guiness NumPy Basics import numpy as np np.random.seed(seed=1234) Numpy Array Creation x = np.array(6) x.ndim x.shape x.size x.dtype np.zeros((2, 2)) np.ones((2, 2)) np.eye((2)) np.random.random.((2, 2)) Numpy Indexing x = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) x[:, 1] # [2, 6, 10] x[0, :] # [1, 2, 3, 4] x[:3, 1:3] # [[2, 3], [6, 7], [10, 11]] x[[0, 1, 2], [0, 2, 1]] # [1, 7, 10] # Boolean array indexing x = np.array([[1,2], [3, 4], [5, 6]]) print (\"x:\\n\", x) print (\"x > 2:\\n\", x > 2) print (\"x[x > 2]:\\n\", x[x > 2]) # x: # [[1 2] # [3 4] # [5 6]] # x > 2: # [[False False] # [ True True] # [ True True]] # x[x > 2]: # [3 4 5 6] Numpy Matrix Operations math: x+y/x-y/x*y np.add/subtract/multiply dot product: a.dot(b) sum: np.sum(x) column sum: np.sum(x, axis=0) row sum: np.sum(x, axis=1) transposing: x.T reshape: np.reshape(x, (2, 3)) CLI Application Basic CLI import click from caesar_encryption import encrypt @click.command() @click.option( '--input_file', type=click.File('r'), help='File in which there is the text you want to encrypt/decrypt.' 'If not provided, a prompt will allow you to type the input text.', ) @click.option( '--output_file', type=click.File('w'), help='File in which the encrypted / decrypted text will be written.' 'If not provided, the output text will just be printed.', ) @click.option( '--decrypt/--encrypt', '-d/-e', help='Whether you want to encrypt the input text or decrypt it.' ) @click.option( '--key', '-k', default=1, help='The numeric key to use for the caesar encryption / decryption.' ) def caesar(input_file, output_file, decrypt, key): if input_file: text = input_file.read() else: text = click.prompt('Enter a text', hide_input=not decrypt) if decrypt: key = -key cyphertext = encrypt(text, key) if output_file: output_file.write(cyphertext) else: click.echo(cyphertext) if __name__ == '__main__': caesar() Progress Bar import click import enchant from tqdm import tqdm from caesar_encryption import encrypt @click.command() @click.option( '--input_file', type=click.File('r'), required=True, ) @click.option( '--output_file', type=click.File('w'), required=True, ) def caesar_breaker(input_file, output_file): cyphertext = input_file.read() english_dictionnary = enchant.Dict(\"en_US\") best_number_of_english_words = 0 for key in tqdm(range(26)): plaintext = encrypt(cyphertext, -key) number_of_english_words = 0 for word in plaintext.split(' '): if word and english_dictionnary.check(word): number_of_english_words += 1 if number_of_english_words > best_number_of_english_words: best_number_of_english_words = number_of_english_words best_plaintext = plaintext best_key = key click.echo(f'The most likely encryption key is {best_key}. It gives the following plaintext:\\n\\n{best_plaintext[:1000]}...') output_file.write(best_plaintext) if __name__ == '__main__': caesar_breaker() Process Data Files CSV File import csv filename = \"my_data.csv\" fields = [] rows = [] # Reading csv file with open(filename, 'r') as csvfile: # Creating a csv reader object csvreader = csv.reader(csvfile) # Extracting field names in the first row fields = csvreader.next() # Extracting each data row one by one for row in csvreader: rows.append(row) # Printing out the first 5 rows for row in rows[:5]: print(row) import csv # Field names fields = ['Name', 'Goals', 'Assists', 'Shots'] # Rows of data in the csv file rows = [ ['Emily', '12', '18', '112'], ['Katie', '8', '24', '96'], ['John', '16', '9', '101'], ['Mike', '3', '14', '82']] filename = \"soccer.csv\" # Writing to csv file with open(filename, 'w+') as csvfile: # Creating a csv writer object csvwriter = csv.writer(csvfile) # Writing the fields csvwriter.writerow(fields) # Writing the data rows csvwriter.writerows(rows) import pandas as pd filename = \"my_data.csv\" # Read in the data data = pd.read_csv(filename) # Print the first 5 rows print(data.head(5)) # Write the data to file data.to_csv(\"new_data.csv\", sep=\",\", index=False) JSON File import json import pandas as pd # Read the data from file # We now have a Python dictionary with open('data.json') as f: data_listofdict = json.load(f) # We can do the same thing with pandas data_df = pd.read_json('data.json', orient='records') # We can write a dictionary to JSON like so # Use 'indent' and 'sort_keys' to make the JSON # file look nice with open('new_data.json', 'w+') as json_file: json.dump(data_listofdict, json_file, indent=4, sort_keys=True) # And again the same thing with pandas export = data_df.to_json('new_data.json', orient='records') XML File import xml.etree.ElementTree as ET import xmltodict import json tree = ET.parse('output.xml') xml_data = tree.getroot() xmlstr = ET.tostring(xml_data, encoding='utf8', method='xml') data_dict = dict(xmltodict.parse(xmlstr)) print(data_dict) with open('new_data_2.json', 'w+') as json_file: json.dump(data_dict, json_file, indent=4, sort_keys=True) Plain Text File import numpy as np x, y = np.loadtxt('input.dat', delimiter=',', unpack=True) Converter import pandas as pd from dicttoxml import dicttoxml import json # Building our dataframe data = {'Name': ['Emily', 'Katie', 'John', 'Mike'], 'Goals': [12, 8, 16, 3], 'Assists': [18, 24, 9, 14], 'Shots': [112, 96, 101, 82] } df = pd.DataFrame(data, columns=data.keys()) # Converting the dataframe to a dictionary # Then save it to file data_dict = df.to_dict(orient=\"records\") with open('output.json', \"w+\") as f: json.dump(data_dict, f, indent=4) # Converting the dataframe to XML # Then save it to file xml_data = dicttoxml(data_dict).decode() with open(\"output.xml\", \"w+\") as f: f.write(xml_data) import json import pandas as pd import csv # Read the data from file # We now have a Python dictionary with open('data.json') as f: data_listofdict = json.load(f) # Writing a list of dicts to CSV keys = data_listofdict[0].keys() with open('saved_data.csv', 'wb') as output_file: dict_writer = csv.DictWriter(output_file, keys) dict_writer.writeheader() dict_writer.writerows(data_listofdict) Matplotlib Usage pip3 install matplotlib pip3 install ggplot Plot Type bar plot line plot scatter plot pie plot stack plot histogram plot interval plot box plot KDE plot candlestick_ohlc plot Basic Usage import matplotlib.pyplot as plt fig = plt.figure() ax = plt.subplot2grid((1, 1), (0, 0)) ax.fill_between(x, y, y[0],where=(y > y[0]), facecolor='g', alpha=0.5) ax.grid(True) ax.xaxis.label.set_color('c') ax.yaxis.label.set_color('r') ax.set_yticks([0,25,50,75]) ax.xaxis.get_ticklabels() ax.spines['left'].set_color('c') ax.spines['right'].set_visible(False) ax.spines['top'].set_visible(False) ax.spines['left'].set_linewidth(5) ax.tick_params(axis='x', colors='#f06215') ax.axhline(20, color='k', linewidth=5) ax.text(x, y, 'text') ax.annotate( 'Bad News!', xytext=(0.8, 0.9), textcoords='axes fraction', arrowprops = dict(facecolor='grey', color='grey') ) plt.plot(x, y, label='label', color='red', linewidth=5) plt.bar(x, y, label='label', color='#111') plt.scatter(x, y, label='label', marker='*', size=100) plt.stackplot(x, y1, y2, ..., yn, colors=[]) plt.pie(slices, labels=[], colors=[], startangle=90, explode=(), autopct='%1.1f%%') plt.hist(data, bins=10, histtype='bar', rwidth=0.8) plt.xlabel('xlabel') plt.ylabel('ylabel') plt.title('title') plt.legend() plt.subplots_adjust() plt.show() Plot Style from matplotlib import style print(plt.style.available) print(plt.__file__) style.use('ggplot') style.use('fivethirtyeight') plt.style.use('mystylesheet.mplrc') Plot Axis Tick ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) ax3.xaxis.set_major_locator(mticker.MaxNLocator(10)) ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower')) for label in ax3.xaxis.get_ticklabels(): label.set_rotation(45) plt.setp(ax1.get_xticklabels(), visible=False) plt.setp(ax2.get_xticklabels(), visible=False) Plot Legend up middle legend ax.legend() leg = ax.legend(loc=9, ncol=2,prop={'size':11}) leg.get_frame().set_alpha(0.4) Subplot tall and witdh for grid template fig = plt.figure() ax1 = fig.add_subplot(221) ax2 = fig.add_subplot(222) ax3 = fig.add_subplot(212) ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1) ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1) ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1) Double y-axis ax2v = ax2.twinx() 3D Plot from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import style style.use('ggplot') fig = plt.figure() ax1 = fig.add_subplot(111, projection='3d') x = [1,2,3,4,5,6,7,8,9,10] y = [5,6,7,8,2,5,6,3,7,2] z = [1,2,6,3,2,7,3,3,7,2] x2 = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10] y2 = [-5,-6,-7,-8,-2,-5,-6,-3,-7,-2] z2 = [1,2,6,3,2,7,3,3,7,2] ax1.scatter(x, y, z, c='g', marker='o') ax1.scatter(x2, y2, z2, c ='r', marker='o') ax1.set_xlabel('x axis') ax1.set_ylabel('y axis') ax1.set_zlabel('z axis') plt.show() from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt import numpy as np from matplotlib import style style.use('ggplot') fig = plt.figure() ax1 = fig.add_subplot(111, projection='3d') x3 = [1,2,3,4,5,6,7,8,9,10] y3 = [5,6,7,8,2,5,6,3,7,2] z3 = np.zeros(10) dx = np.ones(10) dy = np.ones(10) dz = [1,2,3,4,5,6,7,8,9,10] ax1.bar3d(x3, y3, z3, dx, dy, dz) ax1.set_xlabel('x axis') ax1.set_ylabel('y axis') ax1.set_zlabel('z axis') plt.show() Paper Figures Config import matplotlib.pyplot as plt import matplotlib def latexify(fig_width=None, fig_height=None, columns=1): '''Set up matplotlib's RC params for LaTeX plotting. Call this before plotting a figure. Parameters ---------- fig_width : float, optional, inches fig_height : float, optional, inches columns : {1, 2} ''' # code adapted from http://www.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # Width and max height in inches for IEEE journals taken from # computer.org/cms/Computer.org/Journal%20templates/transactions_art_guide.pdf assert(columns in [1,2]) if fig_width is None: fig_width = 3.39 if columns==1 else 6.9 # width in inches if fig_height is None: golden_mean = (sqrt(5)-1.0)/2.0 # Aesthetic ratio fig_height = fig_width*golden_mean # height in inches MAX_HEIGHT_INCHES = 8.0 if fig_height > MAX_HEIGHT_INCHES: print(\"WARNING: fig_height too large:\" + fig_height + \"so will reduce to\" + MAX_HEIGHT_INCHES + \"inches.\") fig_height = MAX_HEIGHT_INCHES params = {'backend': 'ps', 'text.latex.preamble': ['\\usepackage{gensymb}'], 'axes.labelsize': 8, # fontsize for x and y labels (was 10) 'axes.titlesize': 8, 'text.fontsize': 8, # was 10 'legend.fontsize': 8, # was 10 'xtick.labelsize': 8, 'ytick.labelsize': 8, 'text.usetex': True, 'figure.figsize': [fig_width,fig_height], 'font.family': 'serif' } matplotlib.rcParams.update(params) def format_axes(ax): for spine in ['top', 'right']: ax.spines[spine].set_visible(False) for spine in ['left', 'bottom']: ax.spines[spine].set_color(SPINE_COLOR) ax.spines[spine].set_linewidth(0.5) ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') for axis in [ax.xaxis, ax.yaxis]: axis.set_tick_params(direction='out', color=SPINE_COLOR) return ax latexify() ax.set_xlabel(\"X label\") ax.set_ylabel(\"Y label\") ax.set_title(\"Title\") plt.tight_layout() format_axes(ax) plt.savefig(\"figure.pdf\") import numpy as np import matplotlib as mpl mpl.use('pdf') import matplotlib.pyplot as plt plt.rc('font', family='serif', serif='Times') plt.rc('text', usetex=True) plt.rc('xtick', labelsize=8) plt.rc('ytick', labelsize=8) plt.rc('axes', labelsize=8) # width as measured in inkscape width = 3.487 height = width / 1.618 fig, ax = plt.subplots() fig.subplots_adjust(left=.15, bottom=.16, right=.99, top=.97) x = np.arange(0.0, 3*np.pi , 0.1) plt.plot(x, np.sin(x)) ax.set_ylabel('Some Metric (in unit)') ax.set_xlabel('Something (in unit)') ax.set_xlim(0, 3*np.pi) fig.set_size_inches(width, height) fig.savefig('plot.pdf') Paper Standard Matplotlib for Papers Awesome Library Debugging and Testing PySnooper © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"language/verilog/verilogBasicNotes.html":{"url":"language/verilog/verilogBasicNotes.html","title":"Verilog Basic Notes","keywords":"","body":"﻿# Verilog Basic Notes Verilog Basic Notes General Flow Create Project RTL Analysis Simulate Design Synthesize Design Implement Design Post-Implementation Timing Simulate Design Generate Bitstream Testing and Verification Timing in Circuits Combinational Circuit Timing Sequential Circuit Timing Key Words Module 外部端口 function task Variable/Data Structure 常量 向量 部分位选 数字 有符号数 无符号数 Register - reg/integer/time/real/realtime integer real Net - wire/wand/wor Gate Level Basic Gate Use Gate Self-Defined Gate(用户自定义原语) Dataflow Level Operators 整数提升 { } Behavior Level 时延控制 事件控制 语句内/间控制 always if-else case/casex/casez for repeat loop forever loop force/release Blocking/Non-Blocking disable 结构建模 generate 语句 Delay(时延) 预编译指令 define 宏 默认未连接端口 Data Path Multiplexer Adder Register Memory Demos Binary Multiplier Multi-Hz Tips 不可综合结构 混合编程 上升沿/下降沿 Parameter Overload Method Constant Variable Test Bench 有限状态机(FSM) 算术状态机(ASM) SystemVerilog Enum Struct and Union Procedural Block Interface Testing U280 Platform Host Application Basic Flow TLP U280 Tools GDB Based Debugging xclbinutil xocc xp flag xbutil dmesg ILA Trigger AXI Protocol AXI Channels Read Address Channel Read Data Channel Write Address Channel Write Data Channel Write Response Channel AXI Burst Read Burst Write Burst Verilog Components Clock Unit Signal Unit ALU Unit Memory Unit General Flow Create Project .v (sources) .xdc (constraints) RTL Analysis Schematic Simulate Design _tb.v: test bench simulation options: 500ns Scopes -> dut -> swt/led Schematic Synthesize Design Schematic Implement Design Schematic Post-Implementation Timing Simulate Design Generate Bitstream Testing and Verification low-level (circuit) simulation is much slower than high-level (C, HDL) simulation: check only functionality at high level (C, HDL) check only timing, power at low level (circuit) module testbench(); reg clk, reset; // clock and reset are internal reg a, b, c, yexpected; // values from testvectors wire y; // output of circuit reg [31:0] vectornum, errors; // bookkeeping variables reg [3:0] testvectors[10000:0]; // array of testvectors // instantiate device under test sillyfunction dut(.a(a), .b(b), .c(c), .y(y) ); // generate clock always // no sensitivity list, so it always executes begin clk = 1; #5; clk = 0; #5; // 10ns period end // at start of test, load vectors and pulse reset initial // Only executes once begin $readmemb(\"example.tv\", testvectors); // Read vectors: e.g 000_0 001_1 ... xxx_x vectornum = 0; errors = 0; // Initialize reset = 1; #27; reset = 0; // Apply reset wait end // Note: $readmemh reads testvector files written in // hexadecimal // apply test vectors on rising edge of clk always @(posedge clk) begin #1; {a, b, c, yexpected} = testvectors[vectornum]; end always @(negedge clk) begin if (~reset) // don’t test during reset begin if (y !== yexpected) begin $display(\"Error: inputs = %b\", {a, b, c}); $display(\" outputs = %b (%b exp)\",y,yexpected); errors = errors + 1; end // increment array index and read next testvector vectornum = vectornum + 1; if (testvectors[vectornum] === 4'bx) begin $display(\"%d tests completed with %d errors\", vectornum, errors); $finish; // End simulation end end end endmodule Timing in Circuits Combinational Circuit Timing contamination delay (t_cd): minimum path in circuits, outputs start to change propagation delay (t_pd): maximum path in circuits, outputs complete change (delay) heavy dependence on voltage and temperature Sequential Circuit Timing minimize clock skew time: requires intelligent clock network across a chip, making clock arrives at all locations at roughly the same time. T_clock >= T_pcq + T_pd + (T_setup + T_skew) T_ccq + T_cd > (T_hold + T_skew) Key Words module input, output, inout wire, reg, parameter always@(), assign posedge, negedge if-else, case, begin ... end port, signal Module Inout(Net) -> (Net)Module(Net) -> Inout(Net) Input(Net/Register) -> (Net)Module(Net/Register) -> Output(Net) module moduleName( In1, In2, Out1, Out2, InOut1); // 输入输出定义: 说明端口是输入还是输出 input In1, In2; output Out1, Out2; inout InOut1; // 数据类型定义: 说明端口数据类型 - Net/Register wire In1, In2, Out1; wire InOut1; reg Out2; // Instantiation of lower level modules Design u_2(.(端口(信号1), .(端口2(信号2), .(端口3(信号3)); // Functionality // 三种层次的描述: 逻辑层次(Gate Level), 数据流层次(Dataflow Level), 行为层次(Behavior Level) // and/or - gate level and and1( Out1, In1, In2); // assign - dataflow level assign #2 Out1 = In1 & In2; // always/initial - behavior level allways @(*) begin Out2 = In1 & In2 end // Timing specification endmodule 外部端口 封装内部端口,装饰者模式 一个内部端口可与多个外部端口相连 module scram_b ( .data(arb), .control(ctrl), .mem_word(mem_blk), .addr(byte) ); input [0:3] arb; input ctrl; input [8:0] mem_blk; output [0:3] byte; endmodule function 不含时间/事件控制 至少 1 个输入 至多 1 个输出 只含行为模块 只含阻塞赋值语句 function [7: 0] aligned_word; // function declaration input [7: 0] word; begin aligned_word = word; if (aligned_word != 0) while (aligned_word[7] == 0) aligned_word = aligned_word module arithmetic_unit (result_1, result_2, operand_1, operand_2,); output [4: 0] result_1; output [3: 0] result_2; input [3: 0] operand_1, operand_2; assign result_1 = sum_of_operands (operand_1, operand_2); assign result_2 = larger_operand (operand_1, operand_2); function [4: 0] sum_of_operands(input [3:0] operand_1, operand_2); sum_of_operands = operand_1 + operand_2; endfunction function [3: 0] larger_operand(input [3:0] operand_1, operand_2); larger_operand = (operand_1 >= operand_2) ? operand_1 : operand_2; endfunction endmodule task 将测试流程分为多个任务: 初始化任务 模拟生成任务 自我检查任务 module adder_task (c_out, sum, clk, reset, c_in, data_a, data_b); output reg [3: 0] sum; output reg c_out; input [3: 0] data_a, data_b; input clk, reset, c_in; always @(posedge clk or posedge reset) begin if (reset) {c_out, sum} 常用的 task 有: $display(\"fmt\", ...), $monitor(\"fmt\", ...), $time, $finish Variable/Data Structure 常量 0: 逻辑 0 1: 逻辑 1 x/X: Unknow/Floating z/Z: 高阻抗状态(High Impendence) parameter: #define localparam idle = 2'b00; parameter Bit = 8, cnt_up = 1'b1; output [Bit - 1:0] A; reg [Bit - 1:0] A; A = A + cnt_up; 向量 [MSB: LSB] 或 [LSB: MSB] output [3:0] A; // 4 bit reg [0:3] B, C; // 4 bit wire [63:0] D; // 64 bit wire E; // 1 bit A[2:1] = B[0] & C[1:2]; // A[2] = 0 & C[1], A[1] = B[0] & C[2] B[0:1] = 0; C = 4'b1011; // C[0] = 1, C[1] = 0, C[2] = 1, C[3] = 1 integer [7:0] A [3:0]; // 4元素数组. 每个元素为16bit元 reg B [3:0] [15:0]; // arr[4][16]数组, 每个元素为1bit元 reg [7:0] C [3:0] [15:0]; // arr[4][16]数组, 每个元素为8bit元 A[3] = 0; // 置零A中第三个元素(8 bit) A = 0; // 置零A B[1][0] = 1; // B[1][0](1 bit)置1 C[0][0][3:0] = 4'b0010; // C[0][0] 低4bit为0010 C[2][8][5] = 1; // C[2][8] 第5bit为1 部分位选 vector[base_expr+: const_width]; vector[base_expr-: const_width]; inst_mode[mark+:2]; // => mark,mark+1 gpio_mode[mark-:4]; // => mark,mark-1,mark-2,mark-3 数字 // size ' signed base value '[signed] 位长不能用表达式表示,只可用固定的 parameter Num = 5'b01101; // 二进制 Num = 22; // 十进制 Num = 12'b0000_1111_0000; // 可读性 Num = 4'hf; // 十六进制(1111) Num = 4'bxxx1; // 前三位未知 Num = 4'bz01; // 前两位为z, 后两位为01 有符号数 signed reg signed wire integer 'sxx 无符号数 reg wire 'xx Register - reg/integer/time/real/realtime 有记忆性 默认值: x integer 长度为 32 Bit, 补码表示, 常用于计数器 always @(posedge CLK) begin integer i; for (i = 0;i real real 默认值为 0,不可为 x/z 不可声明位宽 Net - wire/wand/wor 局部变量, 没有记忆性 默认值: z wire 间不可直接相连, wand/wor 间课直接相连 可用 wire 定义局部变量 Gate Level Basic Gate and nand(与非) or nor(或非) xor(异或) xnor(同或) Use Gate 同一模块中, 实例名不能与线网名相同 and (w1, In1, In2); // w1 = Int and In2 or or1(w2, w1, In2); // w2 = w1 or In2 xor xor(Out, w1, w2); // Out = w1 xor w2 实例数组 wire [3:0] irq, ctrl, sense; /* * => * nand * u8nand3 (irq[3], ctrl[3], sense[3]); * u8nand2 (irq[2], ctrl[2], sense[2]); * u8nand1 (irq[1], ctrl[1], sense[1]); * u8nand0 (irq[0], ctrl[0], sense[0]); */ nand u8nand [3:0] (irq, ctrl, sense); parameter NUM_BITS = 4; wire [NUM_BITS - 1 : 0] gated_d, din; wire bypass; and #(1, 2) u0and [NUM_BITS - 1: 0] (gated_d, din, bypass); Self-Defined Gate(用户自定义原语) 可以有一个/多个输入 只能有一个输出 第一个端口必须是输出端口 - 表示 值\"无变化\" primitive XOR2 (DOUT, X1, X2); input X1, X2; output DOUT; table // X1 X2 : DOUT 0 0 : 0; 0 1 : 1; 1 0 : 1; 1 1 : 0; endtable endprimitive Dataflow Level assign net = net/reg: 左式只能是 net Operators 赋值: , = !=. == [ ]. { } > +, -, *, /, % 整数提升 表达式所有中间取 最大位宽(最长(左/右)操作数) { } 可实现 haskell 中的模式匹配 // 连接运算符 A = { 1'b0, 1'b1}; // A = 2'b01 A = { B[1:0], C[0], D[2] }; // A = B[1], B[2], C[0], D[2] A = { 2{2'b01} }; // A = 4'b0101 A = { 3'b101, 2{1'b0} }; // A = 5'b101_00 Behavior Level reg = net/reg: *左式只能是 reg 时延控制 #num parameter cycle = 30; # 2 # cycle/2 事件控制 @(*); @( sel, a, b); @(sel or a or b); @(posedge CLK); @(negedge CLK); 语句内/间控制 q = @(posedge clk_iol) d; // 语句内事件控制 @(posedge clk_iol) // 语句间事件控制 q = temp; always always @(事件1, 事件2, ...) begin ...; end if-else 必须添加 else if (condition1) begin ...; end else if (condition2) begin ...; end else begin ...; end case/casex/casez expr: 常量/变量/连接运算符{ }/x/z casex: 当输入某一位为 x/z 时，忽略此位匹配(恒将此位匹配为真) casez: 当输入某一位为 z 时，忽略此位匹配(恒将此位匹配为真) case (expr) item 1: begin ...; end item 2: begin ...; end item 3: begin ...; end default: ...; endcase for for (循环初值; 循环条件; 控制部分) begin ...; end repeat loop initial for test bench 当需 if/else 进行断言时,注意 延时 造成的错误逻辑 // 重复事件控制: // 先计算好右值, 等待时钟 tclk 上出现2个负跳变沿, 再把右值赋给 hresult hresult = repeat (2) @(negedge tclk) hw_data + hr_data; // repeat 循环语句: repeat (2) @(posedge tclk) hresult = hw_data + hr_data; initial begin inc_DAC = 1’b1; repeat(4095) @(posedge clk); // bring DAC right up to point of rollover inc_DAC = 1’b0; inc_smpl = 1’b1; repeat(7)@(posedge clk); // bring sample count up to 7 inc_smpl = 1’b0; end initial begin #100 $finish; // run simulation for 100 units end forever loop // $stop, $finish 可以终止 forevr loop forever #10 clk = ~ clk; force/release initial begin force test_reset = penable & rtc_intr; #5; release test_reset; end Blocking/Non-Blocking Blocking(=): 顺序执行 Non-Blocking( output = input_logic; output disable begin : break for (i = 0; i 结构建模 generate 语句 generate for (gv_i = 0; gv_i // module.sblka[0].uxor // module.sblka[1].uxor // module.sblka[2].uxor // ... Delay(时延) 语句内时延 语句间时延 语句内时延期间：右值保持稳定不变，才可成功赋给左值 sum = (a ^ b) ^ cin; #4 t1 = a & cin; 预编译指令 define 宏 将多个 define 宏,放至 _defines.v, 作为全局宏 默认未连接端口 `unconnected_drive pull1 // 此区间未连接输入端口为上拉(1) `nounconnected_drive `unconnected_drive pull0 // 此区间未连接输入端口为下拉(0) `nounconnected_drive Data Path Multiplexer Adder Register Memory 其中数据文件中地址必须在系统任务中定义的范围内，系统任务中定义的地址必须在存储器定义的地址范围内 优先考虑数据文件中的地址>系统任务中定义的起始地址和结束地址>存储器定义的起始地址和结束地址 Demos gitbooks.io Xilinx Lab Binary Multiplier 1100 (the multiplicand) x 1011 (the multiplier) ---- 0000 (initial partial product, start with 0000) 1100 (1st multiplier bit is 1, so add the multiplicand) ---- 1100 (sum) ---- 01100 (shift sum one position to the right) 1100 (2nd multiplier bit is 1, so add multiplicand again) ---- 100100 (sum, with a carry generated on the left) ---- 100100 (shift sum once to the right, including carry) 0100100 (3rd multiplier bit is 0, so skip add, shift once) ---- 1100 (4th multiplier bit is 1, so add multiplicand again) ---- 10000100 (sum, with a carry generated on the left) 10000100 (shift sum once to the right, including carry) Multi-Hz /* * 利用计数器实现任意分频 */ always @(posedge f_clk) begin //设定频率控制字p if (i == p) begin i=0; f_out=~f_out; end else begin i=i+1; end end Tips 不可综合结构 initial: 只用于 test bench events: Events 同步测试各个组件 real: Real 数据类型不可综合 time: Time 数据类型不可综合 force/release assign(reg)/deassign(reg) fork join primitive: 只有门级的原语（primitives）可综合 table: 用户自定义原语（UDP）及 table 不可综合 #1 延迟只用于仿真，综合器直接忽略延迟 混合编程 内部变量用 assign 赋值 输出变量通过监听 内部变量 改变输出值 assign DT0 = ...; assign DT1 = ...; always @(DT0) begin Aout 上升沿/下降沿 always @(posedge A or negedge B) begin if (A) ... else if (!B) ... else ... end Parameter 只在定义的模块内部起作用 Overload Method module data_path #(parameter DATA_WIDTH = 8) ( input A, input [(DATA_WIDTH - 1): 0] B, output [(DATA_WIDTH - 1): 0] C ); ...... endmodule module data_path_tb ( ); data_path #(.DATA_WIDTH(16)) DUT (.A(A), .B(B), .C(C)); ...... endmodule Constant Variable reset_value = {{(DATA_WIDTH/2){1'b0}}, {(DATA_WIDTH/2){1'b1}}}; Test Bench always begin clk = 0; forever #DELAY clk = ~clk; end reg clock; integer no_of_clocks; parameter CLOCK_PERIOD = 5; parameter TIME = 50000; initial no_of_clocks = 0; initial clock = 1'b0; always #(CLOCK_PERIOD/2.0) clock = ~clock; always @(posedge clock) no_of_clocks = no_of_clocks +1 ; initial begin #TIME; $display(\"End of simulation time is %d , total number of clocks seen is %d expected is %d\",$time,no_of_clocks,($time/5)); $finish; end 有限状态机(FSM) reset: initial state default: illegal/unreachable state 算术状态机(ASM) state box: moore fsm conditional box: mealy fsm decision box: x_input = 0/1 SystemVerilog Enum typedef enum logic [2:0] { RED, GREEN, BLUE, CYAN, MAGENTA, YELLOW } color_t; color_t my_color = GREEN; initial $display(\"The color is %s\", my_color.name()); Struct and Union typedef struct packed { bit [10:0] expo; bit sign; bit [51:0] mant; } FP; FP zero = 64'b0; Procedural Block always_comb: 用于组合逻辑电路（相当于 Verilog 中对所有输入变量电平敏感的 always，但 always_comb 无需手动列出所有输入变量，系统会自动识别） always_ff: 用于触发器及相关的时序逻辑电路（相当于 Verilog 中对某个或某几个信号有效跳变沿敏感、并带有信号储存特性的 always） always_latch: 用于锁存器级相关的时序逻辑电路（相当于 Verilog 中对某个或某几个信号电平敏感、并带有信号储存特性的的 always） always_comb begin tmp = b * b - 4 * a * c; no_root = (tmp Interface interface intf; logic a; logic b; modport in (input a, output b); modport out (input b, output a); endinterface module top; intf i (); u_a m1 (.i1(i)); u_b m2 (.i2(i)); endmodule module u_a (intf.in i1); endmodule module u_b (intf.out i2); endmodule Testing module top; integer num_pkts = $random; reg A, B, C, clk, reset_n; wire D; register_logic dut(A, B, C, clk, reset_n, D); // generate clock // ... initial begin run(); end task run(); reset_n = 1; #20 reset_n = 0; @(posedge clk) reset_n class Packet; string name; rand bit[3:0] sa, da; rand reg A, B, C; function void display(result); $display(A, B, C, result); endfunction endclass: Packet // inheritance class Packet_da_3 extends Packet; constraint da_3 { da == 3; } function void display(result); super.display(result); $display(sa, da); endfunction endclass: Packet_da_3 class Generator; Packet pkt; Channel out_chan; int num_pkts; function void gen(); pkt = new(): pkt.randomize(); out_chan.put(pkt); endfunction task run(); while (num_pkts-- != 0) gen(); endtask endclass class Driver; Channel in_chan; task send(); in_chan.get(pkt); top.A = pkt.A; top.B = pkt.B; top.C = pkt.C; @(posedge top.clk); endtask task run(); forever send(); endtask endclass module top; initial begin build(); run(); end task build(); Config cfg = new(); Channel chan = new(); Generator gen = new(); Driver drv = new(); gen.out_chan = chan; drv.in_chan = chan; cfg.randomize() with { num_pkts > 1500; } gen.num_pkts = cfg.num_pkts; endtask task run(); fork gen.run(); drv.run(); join $finish; endtask endmodule U280 Platform -xp param (clock frequency etc.) -R report level -slr SLR region setting -sp meomry resources mapping tools: xbutil query platforminfo kernelinfo xclbinutil dmesg Host Application Basic Flow set the kernel arguments before performing any enqueue operation keeping the buffer size 2 MB ~ 4 GB posix_memalign is used instead of malloc for the host memory space pointer uint32_t *a, *b, *c, *d = NULL; posix_memalign((void **)&a, 4096, BUFSIZE * sizeof(uint32_t)); posix_memalign((void **)&b, 4096, BUFSIZE * sizeof(uint32_t)); posix_memalign((void **)&c, 4096, BUFSIZE * sizeof(uint32_t)); posix_memalign((void **)&d, 4096, BUFSIZE * sizeof(uint32_t)); release resources for proper performance profile report clReleaseCommandQueue(Command_Queue); clReleaseContext(Context); clReleaseDevice(Target_Device_ID); clReleaseKernel(Kernel); clReleaseProgram(Program); free(Platform_IDs); free(Device_IDs); TLP It is advisable to use the posix_spawn() system call to launch another process from the SDAccel environment application. U280 Tools GDB Based Debugging xprint queue [] xprint event xprint mem [] xprint kernel xprint all xstatus all xstatus -- xclbinutil xclbinutil -i binary_container_1.xclbin --info xocc xp flag Checking out-of-bound access made by kernel interface buffers (option: address) and uninitialized memory access initiated by kernel local to kernel (option: memory). xocc -l –t sw_emu --xp param:compiler.fsanitize=address -o bin_kernel.xclbin xocc -l –t sw_emu --xp param:compiler.fsanitize=memory -o bin_kernel.xclbin xocc -l –t sw_emu --xp param:compiler.fsanitize=address,memory -o bin_kernel.xclbin xbutil sudo /opt/xilinx/xrt/bin/xbutil flash -a # flash the firmware sudo lspci -vd 10ee: sudo /opt/xilinx/xrt/bin/xbutil flash scan sudo /opt/xilinx/xrt/bin/xbutil validate -d xbutil program -p xbutil query # check memory banks usage xbutil status --lapc # check AXI violations dmesg ILA Trigger debug protocol hangs examine the burst size, pipelining and data width to locate the bottleneck .... std::string binaryFile = xcl::find_binary_file(device_name,\"vadd\"); cl::Program::Binaries bins = xcl::import_binary_file(binaryFile); devices.resize(1); cl::Program program(context, devices, bins); cl::Kernel krnl_vadd(program,\"krnl_vadd_rtl\"); // wait_for_enter(\"\\nPress ENTER to continue after setting up ILA trigger...\"); std::cout inBufVec, outBufVec; cl::Buffer buffer_r1(context,CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY, vector_size_bytes, source_input1.data()); // ... // ... // ... //Copy input data to device global memory q.enqueueMigrateMemObjects(inBufVec,0/* 0 means from host*/); //Set the Kernel Arguments // ... // ... // ... //Launch the Kernel q.enqueueTask(krnl_vadd); AXI Protocol Advanced eXtensible Interface Protocol: handshake protocol: ready-valid protocol AXI Channels Read Address Channel arburst: burst type araddr: start address arlen: (# of transfers) - 1 arsize: bytes/transfer arready (memory to host) arvalid Read Data Channel rdata: data rresp: response (failure check) rlast: flag for last piece of data rready (host to memory) rvalid Write Address Channel awburst: burst type awaddr: start address awlen: (# of transfers) - 1 awsize: bytes/transfer awready (memory to host) awvalid Write Data Channel wdata: data wstrb: write strobe -> write mask (1 bit mask for 1 byte data) wlast: flag for last piece of data wready (memory to host) wvalid Write Response Channel bresp: response (failure check) bready (host to memory) bvalid AXI Burst AxBURST[1:0] Burst Type 0b00 FIXED 0b01 INCR 0b10 WRAP 0b11 Reserved burst length = AxLEN[7:0] + 1 (up to 256 transfers in each burst) AxSIZE[2:0] Bytes in Transfer 0b000 1 0b001 2 0b010 4 0b011 8 0b100 16 0b101 32 0b110 64 0b111 128 Read Burst Write Burst Verilog Components Clock Unit /** * @module tick_divider * @author sabertazimi * @email sabertazimi@gmail.com * @brief simple clock divider * @param DATA_WIDTH data width * @input clk_src clock signal * @ouput clk_group divided clock signals */ module tick_divider #(parameter DATA_WIDTH = 32) ( input clk_src, output reg [(DATA_WIDTH-1): 0] clk_group ); initial begin clk_group Signal Unit /** * @module integer_to_segment * @author sabertazimi * @email sabertazimi@gmail.com * @brief raw data to segment encoder * @param DATA_WIDTH data width * @input data raw decimal data (4 bit) * @output seg_data bit data for cnodes */ module integer_to_segment ( input [3:0] int_data, output reg [7:0] seg_data ); always @(int_data) begin case (int_data) 4'b0000: seg_data /** * @module data_to_segment * @author sabertazimi * @email sabertazimi@gmail.com * @brief raw data to segment encoder * @param DATA_WIDTH data width * @input data raw decimal data * @output seg_data bit data for cnodes */ module data_to_segment #(parameter DATA_WIDTH = 32) ( input [(DATA_WIDTH-1):0] data, output [(DATA_WIDTH*2)-1:0] seg_data ); integer_to_segment trans1 ( .int_data(data[3:0]), .seg_data(seg_data[7:0]) ); integer_to_segment trans2 ( .int_data(data[7:4]), .seg_data(seg_data[15:8]) ); integer_to_segment trans3 ( .int_data(data[11:8]), .seg_data(seg_data[23:16]) ); integer_to_segment trans4 ( .int_data(data[15:12]), .seg_data(seg_data[31:24]) ); integer_to_segment trans5 ( .int_data(data[19:16]), .seg_data(seg_data[39:32]) ); integer_to_segment trans6 ( .int_data(data[23:20]), .seg_data(seg_data[47:40]) ); integer_to_segment trans7 ( .int_data(data[27:24]), .seg_data(seg_data[55:48]) ); integer_to_segment trans8 ( .int_data(data[31:28]), .seg_data(seg_data[63:56]) ); endmodule /** * @module led_unit * @author sabertazimi * @email sabertazimi@gmail.com * @brief led display module (bind to anodes and cnodes in FPGA) * @param DATA_WIDTH data width * @input clk_src clock signal (light different led on in round turn) * @input led_data raw decimal data * @output anodes determine which led light on at now * @output cnodes determine how led light on (number) */ module led_unit #(parameter DATA_WIDTH = 32) ( input clk_src, input [(DATA_WIDTH-1):0] led_data, output reg [7:0] anodes, output reg [7:0] cnodes ); reg [2:0] count; // 2^3 = 8 wire [(DATA_WIDTH*2)-1:0] seg_data; initial begin count ALU Unit /** * @module counter * @author sabertazimi * @email sabertazimi@gmail.com * @brief up counter * @param DATA_WIDTH data width * @param STEP counting step * @input clk clock signal * @input rst reset signal * @output en enable signal * @output count counting value */ module counter #(parameter DATA_WIDTH = 1, STEP = 1) ( input clk, input rst, input en, output reg [(DATA_WIDTH-1):0] count ); always @(posedge clk) begin if (rst) begin count /** * @module latch_counter * @author sabertazimi * @email sabertazimi@gmail.com * @brief latch counter (latching when reaching max vlaue) * @input clk clock signal * @input rst reset signal * @output en enable signal * @output count counting value */ module latch_counter ( input clk, input rst, input en, output reg count ); initial begin count /** * @module alu_flags * @author sabertazimi * @email sabertazimi@gmail.com * @brief get flags after alu calculation * @param DATA_WIDTH data width * @input srcA A port data * @input srcB B port data * @input aluop operation code * @output zero equal flag * @output of signed overflow flag * @output uof unsigned overflow flag */ module alu_flags #(parameter DATA_WIDTH = 32) ( input [DATA_WIDTH-1:0] srcA, input [DATA_WIDTH-1:0] srcB, input [3:0] aluop, output zero, output of, output uof ); wire [DATA_WIDTH-1:0] sum, diff; wire carry1, carry2; assign {carry1, sum} = srcA + srcB; // awesome tip assign {carry2, diff} = srcA - srcB; // awesome tip assign zero = (srcA == srcB); assign of = (aluop == 4'd5) ? ( (srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1])) : (aluop == 4'd6) ? ( (srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1]) | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1])) : 0; assign uof = (aluop == 4'd5) ? (carry1) : (aluop == 4'd6) ? (carry2) : 0; endmodule // alu_flags /** * @module alu * @author sabertazimi * @email sabertazimi@gmail.com * @param DATA_WIDTH data width * @input srcA A port data * @input srcB B port data * @input aluop operation code * @ouput aluout calculation result * @output zero equal flag * @output of signed overflow flag * @output uof unsigned overflow flag */ module alu #(parameter DATA_WIDTH = 32) ( input [DATA_WIDTH-1:0] srcA, input [DATA_WIDTH-1:0] srcB, input [3:0] aluop, output reg [DATA_WIDTH-1:0] aluout, output zero, output of, output uof ); wire signed [DATA_WIDTH-1:0] signed_srcA; wire signed [DATA_WIDTH-1:0] signed_srcB; assign signed_srcA = $signed(srcA); assign signed_srcB = $signed(srcB); always @ ( * ) begin case (aluop) 4'd0: aluout >> srcB; 4'd2: aluout > srcB; 4'd3: aluout Memory Unit /** * @module register * @author sabertazimi * @email sabertazimi@gmail.com * @brief D filp flop * @param DATA_WIDTH data width * @input clk clock signal * @input rst reset signal * @input en enable signal * @input din data in * @ouput dout data out */ module register #(parameter DATA_WIDTH = 32) ( input clk, input rst, input en, input [DATA_WIDTH-1:0] din, output reg [DATA_WIDTH-1:0] dout ); always @ (posedge clk) begin if (rst) begin dout /** * @module regfile * @author sabertazimi * @email sabertazimi@gmail.com * @brief register files for MIPS CPU, contains 32 D flip-flop registers * @param DATA_WIDTH data width * @input clk clock signal * @input we write enable signal * @input raddrA read address (No.register) for A out port * @input raddrB read address (No.register) for B out port * @input waddr write address (No.register) for wdata (in port) * @input wdata data to write into regfile * @output regA A port output * @output regB B port output */ module regfile #(parameter DATA_WIDTH = 32) ( input clk, input rst, input we, input [4:0] raddrA, input [4:0] raddrB, input [4:0] waddr, input [DATA_WIDTH-1:0] wdata, output [DATA_WIDTH-1:0] regA, output [DATA_WIDTH-1:0] regB, output [DATA_WIDTH-1:0] v0_data, output [DATA_WIDTH-1:0] a0_data ); `include \"defines.vh\" reg [4:0] i; /// /** * @module imem * @author sabertazimi * @email sabertazimi@gmail.com * @brief instruction cache memory (ROM) * @param DATA_WIDTH data width * @param BUS_WIDTH bus width * @param CODE_FILE MIPS assembly hexdecimal code file * @input addr memory address * @output rdata instruction read out from memory */ module imem #(parameter DATA_WIDTH = 32, BUS_WIDTH = 10, CODE_FILE= \"mips/benchmark.hex\") ( input [BUS_WIDTH-1:0] addr, output [DATA_WIDTH-1:0] rdata ); reg [DATA_WIDTH-1:0] ROM [0:(2**BUS_WIDTH)-1]; initial begin $readmemh(CODE_FILE, ROM, 0, (2**BUS_WIDTH)-1); end assign rdata = ROM[addr]; endmodule // imem /** * @module dmem * @author sabertazimi * @email sabertazimi@gmail.com * @brief data cache memory (RAM) * @param DATA_WIDTH data width * @param BUS_WIDTH bus width * @input clk clock signal * @input re read enable signal * @input we write enable signal * @input addr memory address * @input wdata data write into memory * @output rdata data read out from memory */ module dmem #(parameter DATA_WIDTH = 32, BUS_WIDTH = 10) ( input clk, input re, input we, input [BUS_WIDTH-1:0] addr, input [DATA_WIDTH-1:0] wdata, input [4:0] switch_addr, output [DATA_WIDTH-1:0] rdata, output [DATA_WIDTH-1:0] led_data ); reg [DATA_WIDTH-1:0] RAM [0:(2**BUS_WIDTH)-1]; always @ (posedge clk) begin if (we) begin RAM[addr] © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/android/androidBasicNotes.html":{"url":"programming/android/androidBasicNotes.html","title":"Android Basic Notes","keywords":"","body":"Android Basic Notes Android Basic Notes Android Framework Dalvik virtual machine Basic Building Blocks Android Studio Plugins Code generator API Conventions Manager.Service Activity BaseActivity Activity Collector StartActivity UI Design Layout Basic TableLayout Custom Layout Component Custom Component AlertDialog ListView Custom ListView Layout Custom ListView Listener Drawable Fragment Basic Fragment Xml in Activity.xml Create View in Fragment Add Fragment in Activity Transfer Information In Activity In Fragment Runtime Loop Basic Override Funciton Broadcast Register Receiver Custom Broadcast Normal Broadcast Ordered Broadcast Local Broadcast Local Brodcast Local Receiver Data Store Files Store SharedPreferences DataBase SQLiteOpenHelper establish table Basic Operator Transaction Content Provider Read Other App Content Provide App Content Service Handler AsyncTask Basic Service IBinder ForeGround Service IntentService(Thread) Alarm Service Media Notification SMS Audio Music NetWork WebView Three Steps HttpURLConnection HttpClient XML Pull SAX DefaultHandler JSON JSONObject GSON Network Best Practice Map Location Sensor Light Sensor Accelerometer Sensor Orientation Sensor Best Practice Global Context 用 Intent 传递对象 Serializable Parcelable Custom Logger Android Framework Dalvik virtual machine register-based machine 基于寄存器(不写入内存) minimizeing instruction diapath and memory accesses 最小化指令分配黑内存访问 giving more efficient instruction stream(a lot more semantic content) 提供更加高效的指令流 Basic Building Blocks Activity(Managed by activity stack) Service(Running in the background;with no UI) Broadcast Receiver(Can invoke(调用) activity;with no UI) Content Provider(accessing and managing application data) Android Studio Plugins Code generator Constructor getter/setter ViewHolder Parcelable Implemention GsonFormat : 根据 JSONObject 生成相应类 API Conventions Manager.Service PreferenceManager.getDefaultSharedPreferences LocalBroadcastManager.getInstance Activity BaseActivity 查看当前界面属于哪个 Activity，自定义 Activity 继承 BaseActivity public class BaseActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(\"BaseActivity\", getClass().getSimpleName()); } } Activity Collector 在所有 Activity 的 onCreate 方法调用静态的 addActivity 方法，onDestroy 方法调用静态的 removeActivity 方法。 ActivityCollector.addActivity(this); ActivityCollector.removeActivity(this); public class ActivityCollector { public static List activities = new ArrayList(); public static void addActivity(Activity activity) { activities.add(activity); } public static void removeActivity(Activity activity) { activities.remove(activity); } public static void finishAll() { for (Activity activity : activities) { if (!activity.isFinishing()) { activity.finish(); } } } } StartActivity 为每个 Activity 添加静态的 actionStart 方法，供其他 Activity 启用此 Activity public static void actionStart(Context context, String data1, String data2) { Intent intent = new Intent(context, thisActivity.class); intent.putExtra(\"param1\", data1); intent.putExtra(\"param2\", data2); context.startActivity(intent); } UI Design N activities can respond to a particular intent: Android will pop(弹出) up a little dialogue list(对话框) to user showing application icon defining the intent 当有多个活动可相应某个特定意图时，系统将会弹出对话框提示用户选择一个应用的活动或者设定默认值(default) e.g web browsers Layout Basic android:layout_weight 自适配布局 android:SingleLine 单行显示模式 android:ellipsize=\"end\" 文字过多时缩略方式 TableLayout 拉伸第 2 列 android:layout_span=\"2\" 占 2 列 Custom Layout LayoutInflater 作用是将 layout 的 xml 布局文件实例化为 View 类对象。 View view = LayoutInflater.from(context).inflate(R.layout.title, this/null); Component View(ViewGroup): e.g button、textbox(文本框)、checkbox(复选框) Custom Component custom Xml titie.xml custom class public class TitleLayout extends LinearLayout { public TitleLayout(Context context, AttributeSet attrs) { super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); //Register button click Listener titleBack.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { ((Activity) getContext()).finish(); } }); titleEdit.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Toast.makeText(getContext(), \"You clicked Edit button\", Toast.LENGTH_SHORT).show(); } }); //other awesome things //like material design ripple effect //animations and music } } AlertDialog //builder pattern AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(context); dialogBuilder.setTitle(\"Warning\"); dialogBuilder.setMessage(\"You are forced to be offline. Please try to login again.\"); dialogBuilder.setCancelable(false); dialogBuilder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { ActivityCollector.finishAll(); // 销毁所有活动 Intent intent = new Intent(context, LoginActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); // 重新启动LoginActivity } }); AlertDialog alertDialog = dialogBuilder.create(); // 需要设置AlertDialog的类型,保证在广播接收器中可以正常弹出 alertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); alertDialog.show(); ListView ArrayAdapter adapter = new ArrayAdapter( MainActivity.this, android.R.layout.simple_list_item_1, data ); listView.setAdapter(adapter); Custom ListView Layout Custom class Custom Sub Xml(单项) Custom ArrayAdapter 重写构造函数 重写 getView 方法 重用 convertView 提升性能 ViewHolder 提升性能 //内部类，其中字段与自定义class的字段一致 class ViewHolder { ImageView fruitImage; TextView fruitName; } public FruitAdapter( Context context, int textViewResourceId, List objects) { super(context, textViewResourceId, objects); resourceId = textViewResourceId; } @Override public View getView(int position, View convertView, ViewGroup parent) { Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; ViewHolder viewHolder; //大幅提升性能 if (convertView == null) { view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder存储在View中 } else { view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder } ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } Custom ListView Listener listView.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick( AdapterView parent, View view, int position, long id) { Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); } }); adapter.notifyDataSetChanged(); // 当有新消息时,刷新ListView中的显示 msgListView.setSelection(msgList.size()); // 将ListView定位到最后一行 Drawable 修改特定组件的背景颜色 Resources myColor=getBaseContext().getResources(); //getBaseContext()获得基础Context //getResources()获得资源 Drawable color_M=myColor.getDrawable(R.color. lightgreen ); //由资源 myColor来获得Drawable R.color.lightgreen是颜色值的ID引用 text.setBackgroundDrawable(color_M); //设置背景 Fragment android.app.Fragment Basic Fragment Xml in Activity.xml android:name=\"com.example.fragmenttest.RightFragment\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" /> Create View in Fragment @Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view = inflater.inflate(R.layout.left_fragment, container, false); return view; } Add Fragment in Activity AnotherRightFragment fragment = new AnotherRightFragment(); FragmentTransaction transaction = getFragmentManager.beginTransaction(); //容器的 id 和待添加的碎片实例 transaction.replace(R.id.right_layout, fragment); //模拟返回栈 transaction.addToBackStack(null); transaction.commit(); Transfer Information In Activity getFragmentManager().findFragmentById(R.id.right_fragment); In Fragment MainActivity activity = (MainActivity) getActivity(); Runtime Loop Basic Override Funciton onAttach() 当碎片和活动建立关联的时候调用。 onCreateView() 为碎片创建视图(加载布局)时调用。 onActivityCreated() 确保与碎片相关联的活动一定已经创建完毕的时候调用。 onDestroyView() 当与碎片关联的视图被移除的时候调用。 onDetach() 当碎片和活动解除关联的时候调用。 Broadcast Normal Broadcasts : async Ordered Broadcasts : sync Register Receiver In Activity //Custom BroadcastReceiver,Override onReceive methods //intentFilter : action //前为响应后的行为，后为响应何种广播 registerReceiver(networkChangeReceiver, intentFilter); //in onDestroy unregisterReceiver(); In AndroidManifest,xml Custom Broadcast Normal Broadcast intent intent = new Intent(\"com.example.broadcasttest.MY_BROADCAST\"); sendBroadcast(intent); Ordered Broadcast intent intent = new Intent(\"com.example.broadcasttest.MY_BROADCAST\"); sendOrderedBroadcast(intent, null); Local Broadcast // 获取实例 localBroadcastManager = LocalBroadcastManager.getInstance(this); Local Brodcast localBroadcastManager.sendBroadcast(intent); // 发送本地广播 Local Receiver localBroadcastManager.registerReceiver(CustomReceiver, intentFilter); localBroadcastManager.unregisterReceiver(CustomReceiver); Data Store Files Store /data/data//files/ Write String data = \"Data to save\"; FileOutputStream out = null; BufferedWriter writer = null; try { out = openFileOutput(\"data\", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null) { writer.close(); } } catch (IOException e) { e.printStackTrace(); } } Read FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try { in = openFileInput(\"data\"); reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; while ((line = reader.readLine()) != null) { content.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } return content.toString(); SharedPreferences /data/data//shared_prefs/ Write //get Editor SharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit(); //store date editor.putString(\"name\", \"Tom\"); editor.putInt(\"age\", 28); editor.putBoolean(\"married\", false); //commit editor.commit(); editor.clear(); clear pref file content Read SharedPreferences pref = getSharedPreferences(\"data\", MODE_PRIVATE); //second argument - default value if target key don't exists String name = pref.getString(\"name\", \"\"); int age = pref.getInt(\"age\", 0); boolean married = pref.getBoolean(\"married\", false); DataBase /data/data//databases/ SQLiteOpenHelper @Override onCreate() @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { switch (oldVersion) { case 1: db.execSQL(CREATE_CATEGORY); case 2: db.execSQL(\"alter table Book add column category_id integer\"); default: } } Custom 实现创建、升级数据库的逻辑 构建出 SQLiteOpenHelper 的实例后,再调用getReadableDatabase()或getWritableDatabase()方法创建数据库 establish table create table Book ( id integer primary key autoincrement, author text, price real, pages integer, name text ) Basic Operator 创建一个新的数据库并返回一个 SQLiteDatabase 对象 Context.createDatabase(String name,int version ,int mode,CursorFactory factory); 删除数据库 this.deleteDatabase(\"myDatabase.db\"); 打开数据库 SQLiteDatabase my_DataBase = this.openOrCreateDatabase(\"myDateBase.db\",MODE_PRIVATE , null); my_DataBase.close(); 非查询 SQL 指令 //创建一个名为\"test\"并带两个参数的表 my_DataBase.execSQL(\"CREATE TABLE test (_id INTEGER PRIMARY KEY, someNumber INTERGER);\"); //在数据库中插入一个元组 my_DataBase.execSQL(\"INSERT INTO test (_id,someNumber) values(1,8);\"); SQLiteDatabase db = dbHelper.getWritableDatabase(); //INSERT ContentValues values = new ContentValues(); // 开始组装第一条数据 values.put(\"name\", \"The Da Vinci Code\"); values.put(\"author\", \"Dan Brown\"); values.put(\"pages\", 454); values.put(\"price\", 16.96); db.insert(\"Book\", null, values); // 插入第一条数据 values.clear(); // 开始组装第二条数据 values.put(\"name\", \"The Lost Symbol\"); values.put(\"author\", \"Dan Brown\"); values.put(\"pages\", 510); values.put(\"price\", 19.95); db.insert(\"Book\", null, values); // 插入第二条数据 //update ontentValues values = new ContentValues(); values.put(\"price\", 10.99); db.update(\"Book\", values, \"name = ?\", new String[] { \"The DaVinci Code\" }); //delete db.delete(\"Book\", \"pages > ?\", new String[] { \"500\" }); //删除表 my_DataBase.execSQL(\"DROP TABLE test\"); 查询 SQL 指令-游标 Cursors query() 方法参数 对应 SQL 部分 描述 table from tableName 指定查询的表名 columns select column1, column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 groupBy group by column 指定需要 group by 的列 having having column = value 对 group by 后的结果进一步约束 orderBy order by column1, column2 指定查询结果的排序方式 SQLiteDatabase db = dbHelper.getWritableDatabase(); // 查询Book表中所有的数据 Cursor cursor = db.query(\"Book\", null, null, null, null, null, null); // 遍历Cursor对象,取出数据 //cursor.moveToFirst() //cursor.moveToNext() String name = cursor.getString(cursor.getColumnIndex(\"name\")); String author = cursor.getString(cursor.getColumnIndex(\"author\")); int pages = cursor.getInt(cursor.getColumnIndex(\"pages\")); double price = cursor.getDouble(cursor.getColumnIndex(\"price\")); //为了创建一个Cursor(游标),必须执行一个查询,要么通过SQL使用rawQuery()方法 //或是更精心设计的方法,像query()方法 Cursor cur = my_DataBase.rawQuery(\"SELECT * FORM test\", null); if(cur!=null) {//游标不为空 //返回给定名称的列的基于0开始的index,如果该属性列不存在则返回-1 //通过它们的index来检索属性值 int numColumn=cur.getColumnIndex(\"someNumber\"); if(cur.moveToFirst()) { //cur.moveToFirst()让游标指向第一行,如果游标指向第一行,则返回true do { int num=cur.getInt(numColumn);//获得当前行该属性的值 /*Cursor提供了不同的方法来回索不同的数据类型 例如getInt(int index)/getString(int index)等等*/ /*做一些事情*/ } while (cur.moveToNext()); /*游标移动到下一行,如果游标已经通过了结果集中的最后, 即没有行可以移动时,则返回false*/ //其他可能移动的是 previous() 和first()方法 } } Transaction SQLiteDatabase 的beginTransaction()方法 调用setTransactionSuccessful()表示事务已经执行成功 finally 代码块中调用endTransaction()来结束事务 Content Provider Read Other App Content Uri uri = Uri.parse(\"content://com.example.app.provider/table1\"); getContentResolver().query/insert/delete/update(); ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME ContactsContract.CommonDataKinds.Phone.NUMBER Provide App Content With CotentProvider public class MyProvider extends ContentProvider { @Override public boolean onCreate() { return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { return null; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { return 0; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { return 0; } @Override public String getType(Uri uri) { return null; } } UriMatcher.addURI(uri, customNumber)/.match(uri) 为传入 URI 指定自定义常量作为代号 Service Handler //在主线程重写handleMessage,更新UI new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case UPDATE_TEXT: // 在这里可以进行UI操作 text.setText(\"Nice to meet you\"); break; default: break; } } } //在后台执行子线程 new Thread(new Runnable() { @Override public void run() { Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); // 将Message对象发送出去 } }).start(); AsyncTask AsyncTask 中的几个方法才能完成对任务的定制。经常需要去重写的方法 有以下四个: onPreExecute() 这个方法会在后台任务开始执行之前调用,用于进行一些界面上的初始化操作, 比如显示一个进度条对话框等。 doInBackground(Params...) 这个方法中的所有代码都会在子线程中运行,我们应该在这里去处理所有的耗时任务。 任务一旦完成就可以通过 return 语句来将任务的执行结果返回,如果 AsyncTask 的 第三个泛型参数指定的是 Void,就可以不返回任务执行结果。注意,在这个方法中是不 可以进行 UI 操作的,如果需要更新 UI 元素,比如说反馈当前任务的执行进度, 可以调用 publishProgress(Progress...)方法来完成。 onProgressUpdate(Progress...) 当在后台任务中调用了 publishProgress(Progress...)方法后,这个方法就会很快被调用, 方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作, 利用参数中的数值就可以对界面元素进行相应地更新。 onPostExecute(Result) 当后台任务执行完毕并通过 return 语句进行返回时,这个方法就很快会被调用。 返回的数据会作为参数传递到此方法中,可以利用返回的数据来进行一些 UI 操作, 比如说提醒任务执行的结果,以及关闭掉进度条对话框等。 class DownloadTask extends AsyncTask { @Override protected void onPreExecute() { progressDialog.show(); // 显示进度对话框 } @Override protected Boolean doInBackground(Void... params) { try { while (true) { int downloadPercent = doDownload(); // 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent >= 100) { break; } } } catch (Exception e) { return false; } return true; } @Override protected void onProgressUpdate(Integer... values) { // 在这里更新下载进度 progressDialog.setMessage(\"Downloaded \" + values[0] + \"%\"); } @Override protected void onPostExecute(Boolean result) { progressDialog.dismiss(); // 关闭进度对话框 // 在这里提示下载结果 if (result) { Toast.makeText(context, \"Download succeeded\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, \" Download failed\", Toast.LENGTH_SHORT).show(); } } } Basic Service //in AndroidManifest.xml stopSelf() public class MyService extends Service { @Override public IBinder onBind(Intent intent) { return null; } @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); } } IBinder In Custom Service class private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder { public void startDownload() { Log.d(\"MyService\", \"startDownload executed\"); } public int getProgress() { Log.d(\"MyService\", \"getProgress executed\"); return 0; } } @Override public IBinder onBind(Intent intent) { return mBinder; } In Activity class case R.id.bind_service: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务 break; case R.id.unbind_service: unbindService(connection); // 解绑服务 break; default: break; @Override public void onServiceDisconnected(ComponentName name) { } @Override public void onServiceConnected(ComponentName name, IBinder service) { downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); } ForeGround Service In service onCreate Notification notification = new Notification(R.drawable.ic_launcher, \"Notification comes\", System. currentTimeMillis()); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, \"This is title\", \"This is content\", pendingIntent); startForeground(1, notification); IntentService(Thread) public class MyIntentService extends IntentService { public MyIntentService() { super(\"MyIntentService\"); // 调用父类的有参构造函数 } @Override protected void onHandleIntent(Intent intent) { // 打印当前线程的id Log.d(\"MyIntentService\", \"Thread id is \" + Thread.currentThread().getId()); } @Override public void onDestroy() { super.onDestroy(); Log.d(\"MyIntentService\", \"onDestroy executed\"); } } Alarm Service 结合 BroadcastReceiver 可以实现定时任务 AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000; manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent); Service 延时发出广播 BroadcastReceiver 接受广播后再次启动 Service public int onStartCommand(Intent intent, int flags, int startId) { new Thread(new Runnable() { @Override public void run() { Log.d(\"LongRunningService\", \"executed at \" + new Date().toString()); } }).start(); AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE); int anHour = 60 * 60 * 1000; // 这是一小时的毫秒数 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; //关键：在服务里发送广播 Intent i = new Intent(this, AlarmReceiver.class); PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); return super.onStartCommand(intent, flags, startId); } Media Notification NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification(R.drawable.ic_launcher, \"This is ticker text\", System.currentTimeMillis()); Intent intent = new Intent(this, NotificationActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT); notification.setLatestEventInfo(this, \"This is content title\", \"This is content text\", pi); manager.notify(1, notification); //在被启动Activity manager.cancel(1); SMS Audio Music NetWork Networked Apps Network latency(网络延迟)——UI thread seperated from data loading thread Battery drain(电池耗尽) Intermittent service(中断服务) WebView Three Steps webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); // 根据传入的参数再去加载新的网页 return true; // 表示当前WebView可以处理打开新网页的请求,不用借助系统浏览器 } }); webView.loadUrl(\"http://www.github.com\"); HttpURLConnection HttpClient XML Pull HttpClient httpClient = new DefaultHttpClient(); // 指定访问的服务器地址是电脑本机 HttpGet httpGet = new HttpGet(\"http://10.0.2.2/get_data.xml\"); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { // 请求和响应都成功了 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity,\"utf-8\"); //XML Pull 方式解析 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType = xmlPullParser.getEventType(); String id = \"\"; String name = \"\"; String version = \"\"; while (eventType != XmlPullParser.END_DOCUMENT) { String nodeName = xmlPullParser.getName(); switch (eventType) { // 开始解析某个结点 case XmlPullParser.START_TAG: { if (\"id\".equals(nodeName)) { id = xmlPullParser.nextText(); } else if (\"name\".equals(nodeName)) { name = xmlPullParser.nextText(); } else if (\"version\".equals(nodeName)) { version = xmlPullParser.nextText(); } break; } // 完成解析某个结点 case XmlPullParser.END_TAG: { if (\"app\".equals(nodeName)) { Log.d(\"MainActivity\", \"id is \" + id); Log.d(\"MainActivity\", \"name is \" + name); Log.d(\"MainActivity\", \"version is \" + version); } break; } default: break; } eventType = xmlPullParser.next(); } // end of while } // end of if SAX DefaultHandler public class ContentHandler extends DefaultHandler { private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; @Override public void startDocument() throws SAXException { id = new StringBuilder(); name = new StringBuilder(); version = new StringBuilder(); } @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { // 记录当前结点名 nodeName = localName; } @Override public void characters( char[] ch, int start, int length) throws SAXException { // 根据当前的结点名判断将内容添加到哪一个StringBuilder对象中 if (\"id\".equals(nodeName)) { id.append(ch, start, length); } else if (\"name\".equals(nodeName)) { name.append(ch, start, length); } else if (\"version\".equals(nodeName)) { version.append(ch, start, length); } } @Override public void endElement( String uri, String localName, String qName) throws SAXException { if (\"app\".equals(localName)) { Log.d(\"ContentHandler\", \"id is \" + id.toString().trim()); Log.d(\"ContentHandler\", \"name is \" + name.toString().trim()); Log.d(\"ContentHandler\", \"version is \" + version.toString().trim()); // 最后要将StringBuilder清空掉 id.setLength(0); name.setLength(0); version.setLength(0); } } @Override public void endDocument() throws SAXException { } } HttpClient httpClient = new DefaultHttpClient(); // 指定访问的服务器地址是电脑本机 HttpGet httpGet = new HttpGet(\"http://10.0.2.2:8080/get_data.xml\"); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { // 请求和响应都成功了 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, \"utf-8\"); SAXParserFactory factory = SAXParserFactory.newInstance(); XMLReader xmlReader = factory.newSAXParser().getXMLReader(); ContentHandler handler = new ContentHandler(); // 将ContentHandler的实例设置到XMLReader中 xmlReader.setContentHandler(handler); // 开始执行解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); JSON JSONObject HttpClient httpClient = new DefaultHttpClient(); // 指定访问的服务器地址是电脑本机 HttpGet httpGet = new HttpGet(\"http://10.0.2.2/get_data.json\"); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { // 请求和响应都成功了 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, \"utf-8\"); JSONArray jsonArray = new JSONArray(response); for (int i = 0; i GSON HttpClient httpClient = new DefaultHttpClient(); // 指定访问的服务器地址是电脑本机 HttpGet httpGet = new HttpGet(\"http://10.0.2.2/get_data.json\"); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { // 请求和响应都成功了 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, \"utf-8\"); Gson gson = new Gson(); List appList = gson.fromJson(response, new TypeToken>() {}.getType()); for (App app : appList) { Log.d(\"MainActivity\", \"id is \" + app.getId()); Log.d(\"MainActivity\", \"name is \" + app.getName()); Log.d(\"MainActivity\", \"version is \" + app.getVersion()); } } Network Best Practice public interface HttpCallbackListener { void onFinish(String response); void onError(Exception e); } public class HttpUtil { public static void sendHttpRequest(final String address, final HttpCallbackListener listener) { new Thread(new Runnable() { @Override public void run() { HttpURLConnection connection = null; try { URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { response.append(line); } if (listener != null) { // 回调onFinish()方法 // 将respone传入回调方法 listener.onFinish(response.toString()); } } catch (Exception e) { if (listener != null) { // 回调onError()方法 listener.onError(e); } } finally { if (connection != null) { connection.disconnect(); } } } // end of run }).start(); // end of runnable } // end of sendHttpRequest } // end of class //以后每当需要发起一条 HTTP 请求的时候就可以这样写: String address = \"http://www.github.com\"; String response = HttpUtil.sendHttpRequest(address, new HttpCallbackListener() { @Override public void onFinish(String response) { // 在这里根据返回内容执行具体的逻辑 } @Override public void onError(Exception e) { // 在这里对异常情况进行处理 } }); Map Location public class MainActivity extends Activity { public static final int SHOW_LOCATION = 0; private TextView positionTextView; private LocationManager locationManager; private String provider; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); positionTextView = (TextView) findViewById(R.id.position_text_view); locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); // 获取所有可用的位置提供器 List providerList = locationManager.getProviders(true); if (providerList.contains(LocationManager.GPS_PROVIDER)) { provider = LocationManager.GPS_PROVIDER; } else if (providerList.contains(LocationManager.NETWORK_PROVIDER)) { provider = LocationManager.NETWORK_PROVIDER; } else { // 当没有可用的位置提供器时，弹出Toast提示用户 Toast.makeText(this, \"No location provider to use\", Toast.LENGTH_SHORT).show(); return; } Location location = locationManager.getLastKnownLocation(provider); if (location != null) { // 显示当前设备的位置信息 showLocation(location); } locationManager.requestLocationUpdates(provider, 5000, 1, locationListener); } protected void onDestroy() { super.onDestroy(); if (locationManager != null) { // 关闭程序时将监听器移除 locationManager.removeUpdates(locationListener); } } LocationListener locationListener = new LocationListener() { @Override public void onStatusChanged(String provider, int status, Bundle extras) { } @Override public void onProviderEnabled(String provider) { } @Override public void onProviderDisabled(String provider) { } @Override public void onLocationChanged(Location location) { // 更新当前设备的位置信息 showLocation(location); } }; private void showLocation(final Location location) { new Thread(new Runnable() { @Override public void run() { try { // 组装反向地理编码的接口地址 StringBuilder url = new StringBuilder(); url.append(\"http://maps.googleapis.com/maps/api/geocode/json?latlng=\"); url.append(location.getLatitude()).append(\",\") .append(location.getLongitude()); url.append(\"&sensor=false\"); HttpClient httpClient = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(url.toString()); // 在请求消息头中指定语言，保证服务器会返回中文数据 httpGet.addHeader(\"Accept-Language\", \"zh-CN\"); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, \"utf-8\"); JSONObject jsonObject = new JSONObject(response); // 获取results节点下的位置信息 JSONArray resultArray = jsonObject.getJSONArray(\"results\"); if (resultArray.length() > 0) { JSONObject subObject = resultArray.getJSONObject(0); // 取出格式化后的位置信息 String address = subObject.getString(\"formatted_address\"); Message message = new Message(); message.what = SHOW_LOCATION; message.obj = address; handler.sendMessage(message); } } } catch (Exception e) { e.printStackTrace(); } } }).start(); } private Handler handler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case SHOW_LOCATION: String currentPosition = (String) msg.obj; positionTextView.setText(currentPosition); break; default: break; } } }; } Sensor SensorManager senserManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE); SensorEventListener listener = new SensorEventListener() { @Override public void onAccuracyChanged(Sensor sensor, int accuracy) { } @Override public void onSensorChanged(SensorEvent event) { } }; senserManager.registerListener(listener, senser, SensorManager.SENSOR_DELAY_NORMAL); sensorManager.unregisterListener(listener); Light Sensor Sensor sensor = senserManager.getDefaultSensor(Sensor.TYPE_LIGHT); Accelerometer Sensor Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); Orientation Sensor Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); Best Practice Global Context ...... public class MyApplication extends Application { private static Context context; @Override public void onCreate() { context = getApplicationContext(); } public static Context getContext() { return context; } } 用 Intent 传递对象 Serializable public class Person implements Serializable Parcelable public class Person implements Parcelable { private String name; private int age; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); // 写出name dest.writeInt(age); // 写出age } public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { @Override public Person createFromParcel(Parcel source) { Person person = new Person(); person.name = source.readString(); // 读取name person.age = source.readInt(); // 读取age return person; } @Override public Person[] newArray(int size) { return new Person[size]; } }; } Custom Logger public class LogUtil { public static final int VERBOSE = 1; public static final int DEBUG = 2; public static final int INFO = 3; public static final int WARN = 4; public static final int ERROR = 5; public static final int NOTHING = 6; //custom key public static final int LEVEL = VERBOSE; public static void v(String tag, String msg) { if (LEVEL © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/codeGuide/bugGuideBasicNotes.html":{"url":"programming/codeGuide/bugGuideBasicNotes.html","title":"Bug Guide Basic Notes","keywords":"","body":"Bug List Bug List Basic Bug C Bug 低概率/偶发性 Bug Basic Bug 必须进行输入验证 - 永远不要相信用户输入 永不使用未经验证的数值的长度或大小 必须返回正确的错误状态 注意(隐式)类型转换 C Bug 栈缓冲区溢出 空指针解引用 (隐式)类型转换 GOT 覆写(Global Offset Table) 低概率/偶发性 Bug 多进程完全异步编程的复杂性 逐渐地内存泄漏 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/codeGuide/cleanCodeBasicNotes.html":{"url":"programming/codeGuide/cleanCodeBasicNotes.html","title":"Clean Code Basic Notes","keywords":"","body":"Clean Code Basic Notes Clean Code Basic Notes Programming Principles SOLID principle Single Responsibility Principle Open-Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle Programming Paradigms Taxonomy of Paradigms Observable Nondeterminism Named State Functional Programming Programming Principles SOLID principle Single Responsibility Principle A class should have only one job class Animal { constructor(name) {} getAnimalName() {} saveAnimal(animal) {} } // => class Animal { constructor(name) {} getAnimalName() {} } class AnimalDB { getAnimal(animal) {} saveAnimal(animal) {} } Open-Closed Principle Software entities(Classes, modules, functions) should be open for extension, close for modification. const animals: Array = [ new Animal('lion'), new Animal('mouse') ]; function AnimalSound(a: Array) { for(int i = 0; i class Animal { makeSound(); //... } class Lion extends Animal { makeSound() { return 'roar'; } } class Squirrel extends Animal { makeSound() { return 'squeak'; } } class Snake extends Animal { makeSound() { return 'hiss'; } } //... function AnimalSound(a: Array) { for(int i = 0; i class Discount { giveDiscount() { if(this.customer == 'fav') { return this.price * 0.2; } if(this.customer == 'vip') { return this.price * 0.4; } } } class VIPDiscount: Discount { getDiscount() { return super.getDiscount() * 2; } } class SuperVIPDiscount: VIPDiscount { getDiscount() { return super.getDiscount() * 2; } } Liskov Substitution Principle A sub-class must be substitutable for its super-class function AnimalLegCount(a: Array) { for(int i = 0; i class Animal { //... LegCount(); } //... class Lion extends Animal{ //... LegCount() { //... } } //... function AnimalLegCount(a: Array) { for(let i = 0; i Interface Segregation Principle Make fine grained interfaces that are client specific Clients should not be forced to depend upon interfaces that they do not use interface IShape { drawCircle(); drawSquare(); drawRectangle(); } class Circle implements IShape { drawCircle(){ //... } drawSquare(){ //... } drawRectangle(){ //... } } class Square implements IShape { drawCircle(){ //... } drawSquare(){ //... } drawRectangle(){ //... } } class Rectangle implements IShape { drawCircle(){ //... } drawSquare(){ //... } drawRectangle(){ //... } } interface IShape { draw(); } interface ICircle { drawCircle(); } interface ISquare { drawSquare(); } interface IRectangle { drawRectangle(); } interface ITriangle { drawTriangle(); } class Circle implements ICircle { drawCircle() { //... } } class Square implements ISquare { drawSquare() { //... } } class Rectangle implements IRectangle { drawRectangle() { //... } } class Triangle implements ITriangle { drawTriangle() { //... } } class CustomShape implements IShape { draw(){ //... } } OR class Circle implements IShape { draw(){ //... } } class Triangle implements IShape { draw(){ //... } } class Square implements IShape { draw(){ //... } } class Rectangle implements IShape { draw(){ //... } } Dependency Inversion Principle Dependency should be on abstractions not concretions: High-level modules should not depend upon low-level modules. Both should depend upon abstractions Abstractions should not depend on details. Details should depend upon abstractions class XMLHttpService extends XMLHttpRequestService {} class Http { constructor(private xmlhttpService: XMLHttpService) { } get(url: string , options: any) { this.xmlhttpService.request(url,'GET'); } post() { this.xmlhttpService.request(url,'POST'); } //... } interface Connection { request(url: string, opts:any); } // Abstraction not upon on details (but upon on abstractions) class Http { constructor(private httpConnection: Connection) { } get(url: string , options: any) { this.httpConnection.request(url,'GET'); } post() { this.httpConnection.request(url,'POST'); } //... } class XMLHttpService implements Connection { const xhr = new XMLHttpRequest(); //... request(url: string, opts:any) { xhr.open(); xhr.send(); } } class NodeHttpService implements Connection { request(url: string, opts:any) { //... } } class MockHttpService implements Connection { request(url: string, opts:any) { //... } } Programming Paradigms Each programming language realizes one or more paradigms. Each paradigm is defined by a set of programming concepts. Taxonomy of Paradigms Nondeterminism is important for real-world interaction. Named state is important for modularity. Observable Nondeterminism During the execution, this choice is made by a part of the run-time system called the scheduler. The nondeterminism is observable if a user can see different results from executions that start at the same internal configuration. concurrency or race condition (timing effects) shared-state concurrency or message-passing concurrency concurrent programming language e.g Java Named State State is the ability to remember information (a sequence of values in time). Distinguish three axes of expressiveness, depending on whether the state is: unnamed or named deterministic or nondeterministic sequential or concurrent named, nondeterministic and concurrent paradigmh as the most expressiveness of state named state for updatable memory (mutable state) and modularity The least expressive combination is functional programming (threaded state: unnamed, deterministic, sequential). Adding concurrency gives declarative concurrent programming (synchrocells: unnamed, deterministic, concurrent). Adding nondeterministic choice gives concurrent logic programming (stream mergers: unnamed, nondeterministic, concurrent). Adding ports or cells, gives message passing or shared state (named, nondeterministic, concurrent). Functional Programming Based on the concept of first-class function or closure, which makes it equivalent to the λ-calculus which is Turing complete. © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/codeGuide/codeReviewBasicNotes.html":{"url":"programming/codeGuide/codeReviewBasicNotes.html","title":"Code Review Basic Notes","keywords":"","body":"Code Review Notes Code Review Notes Tools Basic Security Documents 注释 Test Tools checkstyle findbugs pmd Basic 逻辑正确 简单易懂 编程规范(linter) 模块化 多余或重复 代码/日志/测试 重复轮子(可被基本库替换) 无必要的全局变量 代码误注释 死循环(边界检查) Security 所有的数据输入是否都进行了检查（检测正确的类型，长度，格式和范围）并且进行了编码？ 在哪里使用了第三方工具，返回的错误是否被捕获？ 输出的值是否进行了检查并且编码？ 无效的参数值是否能够处理？ Documents 注释 数据结构 计量单位 描述代码意图 函数块 非常规行为/边界检查 TODO 标记 FIXME 标记 第三方库文档 Test 代码是否可以测试？比如，不要添加太多的或是隐藏的依赖关系，不能够初始化对象，测试框架可以使用方法等。 是否存在测试，它们是否可以被理解？比如，至少达到你满意的代码覆盖(code coverage)。 单元测试是否真正的测试了代码是否可以完成预期的功能？ 是否检查了数组的“越界“错误？ 是否有可以被已经存在的 API 所替代的测 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/codeGuide/designPatternsNotes.html":{"url":"programming/codeGuide/designPatternsNotes.html","title":"Design Patterns Notes","keywords":"","body":"Design Patterns Notes Design Patterns Notes Baisc Patterns SOLID 原则 Literal Pattern Closure and IIFE Check Pattern 函数(function) 参数 解耦 事件处理与 UI 逻辑 Env and Config Stand Library Idioms Other Modular Patterns Object Literal 立即函数模式(IIFE) UMD(Universal Module Definition) Pattern Common Design Patterns Classification Creational Patterns Structural Patterns Behavioral Patterns Prototype Bridge Composite Strategy State Iterator IOC and DI Class Pattern Mix-In Pattern Singleton Pattern Abstract Factory Factory Method Adapter Pattern Decorator Pattern 实现 1(关键 - 实现传递方式) return this.uber.function() Decorators List 实现 2 Facade Pattern Flyweight Pattern Proxy Pattern Command Pattern Mediator Pattern Observer Pattern Pub-Sub Pattern Implementation Sample Ajax Callback MV* Pattern jQuery Pattern Plugin Pattern Awesome Book Baisc Patterns SOLID 原则 Single Responsibility Principle 单一功能原则 Open/Closed Principle 开闭原则 Liskov Substitution Principle 里氏替换原则 Interface Segregation Principle 接口隔离原则 Dependency Inversion Principle 依赖反转原则 SOLID Principles 单一职责是所有设计原则的基础 开闭原则是设计的终极目标 里氏替换原则强调的是子类替换父类后程序运行时的正确性, 它用来帮助实现开闭原则 接口隔离原则用来帮助实现里氏替换原则, 同时它也体现了单一职责 依赖倒置原则是过程式设计与面向对象设计的分水岭, 同时它也被用来指导接口隔离原则 Literal Pattern 不要使用 new Boolean()/new Number()/new String() 避免使用 new Object()/new Array() Closure and IIFE Check Pattern O || {} O || (O = {}) if (O && O.property) if (typeof v === \" \") toString. apply(var) 函数(function) 参数 函数不应依赖于全局变量，实现与执行全局环境的的解耦 全局变量应以函数参数/依赖的形式，注入函数内部 解耦 事件处理与 UI 逻辑 事件处理函数与应用逻辑函数分开成单独函数,提高代码重用率 应用逻辑函数不依赖于 event 对象，其属性值作为参数传入，易于解耦与测试 const MyApp = { // 事件处理函数 handleClick: function(event) { /* 将事件的属性作为参数，传递给应用逻辑函数 * 使得应用逻辑函数不依赖于 event 对象，易于解耦与测试 */ this.showPopup(event.clientX, event.clientY); } // 应用逻辑函数 showPopup: function(x, y) { const popup = document.getElementById('popup'); popup.style.left = x + 'px'; popup.style.top = y + 'px'; popup.className = 'reveal'; } } Env and Config 配置文件以 .env/JS(Object)/JSON/JSONP/XML/YML 格式单独存放，方便读取 Stand Library Idioms use Number.isNaN not isNaN use Number.isFinite not isFinite Other !!result 转化成 Boolean Modular Patterns Object Literal 通过对象字面量创建命名空间 MYAPP.namespace = function(namespaceString) { var parts = namespaceString.split('.'), parent = MYAPP, i; // strip redundant leading global if (parts[0] === 'MYAPP') { // remove leading global parts = parts.slice(1); } for (i = 0; i // assign returned value to a local var var module2 = MYAPP.namespace('MYAPP.modules.module2'); module2 === MYAPP.modules.module2; // true // skip initial `MYAPP` MYAPP.namespace('modules.module51'); // long namespace MYAPP.namespace('once.upon.a.time.there.was.this.long.nested.property'); 立即函数模式(IIFE) 通过调用立即函数，返回一个对象，暴露(exposed to public)公共接口(特权/公共方法): 闭包: 定义私有变量与特权方法 返回对象: 即使通过外部代码改变返回对象的接口，也不会影响原接口 var myobj = (function () { // private member var name = \"tazimi\", // private method // excluded in return object // privileged method function getName() { return name; }, function setName(n) { if (typeof n === 'string') { name = n; } return this; }, // public method function logName() { console.log(name); }; // 闭包 return { // 公共接口: 特权/公共方法 // 特权方法 getName: getName, setName: setName, // 公共方法 log: logName; }; }()); var myApp = myApp || {}; myApp.utils = {}; (function() { var val = 5; this.getValue = function() { return val; }; this.setValue = function(newVal) { val = newVal; }; // also introduce a new sub-namespace this.tools = {}; }.apply(myApp.utils)); // inject new behaviour into the tools namespace // which we defined via the utilities module (function() { this.diagnose = function() { return 'diagnosis'; }; }.apply(myApp.utils.tools)); jQuery Plugin Pattern: 通过给立即函数传参，注入全局变量/其他依赖 UMD(Universal Module Definition) Pattern 先判断是否支持 Node.js 的模块(exports)，存在则使用 Node.js 模块模式 再判断是否支持 AMD(define)，存在则使用 AMD 方式加载模块 (function(window, factory) { if (typeof exports === 'object') { module.exports = factory(); } else if (typeof define === 'function' && define.amd) { define(factory); } else { window.eventUtil = factory(); } })(this, function() { //module ... }); Common Design Patterns Classification Creational Patterns Factory Method(工厂方法) | 通过将数据和事件接口化来构建若干个子类。 Abstract Factory(抽象工厂) | 建立若干族类的一个实例，这个实例不需要具体类的细节信息。（抽象类） Builder(建造者) | 将对象的构建方法和其表现形式分离开来，总是构建相同类型的对象。 Prototype(原型) | 一个完全初始化的实例，用于拷贝或者克隆。 Singleton(单例) | 一个类只有唯一的一个实例，这个实例在整个程序中有一个全局的访问点。 Structural Patterns Adapter(适配器) : 将不同类的接口进行匹配，调整，这样尽管内部接口不兼容但是不同的类还是可以协同工作的。 Bridge(桥接模式) : 将对象的接口从其实现中分离出来，这样对象的实现和接口可以独立的变化。 Composite(组合模式) : 通过将简单可组合的对象组合起来，构成一个完整的对象，这个对象的能力将会超过这些组成部分的能力的总和，即会有新的能力产生。 Decorator(装饰器) : 动态给对象增加一些可替换的处理流程。 Facade(外观模式) : 一个类隐藏了内部子系统的复杂度，只暴露出一些简单的接口。 Flyweight(享元模式) : 一个细粒度对象，用于将包含在其它地方的信息 在不同对象之间高效地共享。 Proxy(代理模式) : 一个充当占位符的对象用来代表一个真实的对象。 Behavioral Patterns Interpreter(解释器) : 将语言元素包含在一个应用中的一种方式，用于匹配目标语言的语法。 Template Method(模板方法) : 在一个方法中为某个算法建立一层外壳，将算法的具体步骤交付给子类去做。 Chain of Responsibility(响应链) : 一种将请求在一串对象中传递的方式，寻找可以处理这个请求的对象。 Command(命令) : 封装命令请求为一个对象，从而使记录日志，队列缓存请求，未处理请求进行错误处理 这些功能称为可能。 Iterator(迭代器) : 在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素。 Mediator(中介者模式) : 在类之间定义简化的通信方式，用于避免类之间显式的持有彼此的引用。 Observer(观察者模式) : 用于将变化通知给多个类的方式，可以保证类之间的一致性。 State(状态) : 当对象状态改变时，改变对象的行为。 Strategy(策略) : 将算法封装到类中，将选择和实现分离开来。 Visitor(访问者) : 为类增加新的操作而不改变类本身。 Prototype 关键方法 clone() Bridge 分离抽象和实现/分离对象的两种不同属性 e.g 从 2 个不同维度上扩展对象 Composite 树形结构: 根结点 Component 抽象对象/接口 采用最大宽接口,定义内点和叶点的操作 将内点特有的操作集设为缺省操作集(空实现) 内点 持有父结点和子节点的引用(可使用 Flyweight 模式实现共享) 操作集:内点操作集(可添加/删除组件) 叶点 持有父结点引用 操作集：叶点操作集(不可添加/删除组件) Strategy 改变对象的内核/算法, 一个 Strategy 对象封装一个算法 State 一个 State 对象封装一个与状态相关的行为 Iterator 一个 Iterator 对象封装访问和遍历一个聚集对象中的各个构件的方法 IOC and DI IOC (inversion of control) 控制反转模式；控制反转是将组件间的依赖关系从程序内部提到外部来管理 DI (dependency injection) 依赖注入模式；依赖注入是指将组件的依赖通过外部以参数或其他形式注入 class DbMysql { public function query(){} } class Controller { public $db; public function __construct($dbMysql) { $this->db = $dbMysql; } public function action(){ $this->db->query(); } } $db = new DbMysql(); $c = new Controller($db); $c->action(); With IOC container: class DbMysql { public function __construct($host, $name, $pwd) { // do something } public function query() { echo __METHOD__ . PHP_EOL; } } class DbRedis { public function __construct($host, $name, $pwd) { // do something } public function set() { echo __METHOD__ . PHP_EOL; } } class controller { public $mysql; public $redis; public function __construct($mysql, $redis) { $this->mysql = $mysql; $this->redis = $redis; } public function action() { $this->mysql->query(); $this->redis->set();} } } class Container { public $bindings = []; public function bind($key, Closure $value) { $this->bindings[$key] = $value; } public function make($key) { $new = $this->bindings[$key]; return $new(); } } $app = new Container(); $app->bind('mysql', function () { return new DbMysql('host', 'name', 'pwd'); }); $app->bind('redis', function () { return new DbRedis('host', 'name', 'pwd'); }); $app->bind('controller', function () use ($app) { return new Controller($app->make('mysql'), $app->make('redis')); }); $controller = $app->make('controller'); $controller->action(); /** * 输出： * DbMysql::query * DbRedis::set */ With dependency injection: // dependency provider export interface IProvider { provide(): T; } @injectable() export class NameProvider implements IProvider { provide() { return \"World\"; } } // top module import * as React from \"react\"; import { IProvider } from \"./providers\"; export class Hello extends React.Component { private readonly nameProvider: IProvider; render() { return Hello {this.nameProvider.provide()}!; } } Class Pattern var Person = function(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; this.gender = 'male'; }; // Define a subclass constructor for for \"Superhero\": var Superhero = function(firstName, lastName, powers) { // Invoke the superclass constructor on the new object // then use .call() to invoke the constructor as a method of // the object to be initialized. Person.call(this, firstName, lastName); // Finally, store their powers, a new array of traits not found in a normal \"Person\" this.powers = powers; }; SuperHero.prototype = Object.create(Person.prototype); var superman = new Superhero('Clark', 'Kent', ['flight', 'heat-vision']); console.log(superman); Mix-In Pattern 将多个对象的属性混入同一个对象,达到继承/扩展/组合的效果 不改变原型链 function mix() { var arg, prop, child = {}; for (arg = 0; arg var cake = mix( { eggs: 2, large: true }, { butter: 1, salted: true }, { flour: '3 cups' }, { sugar: 'sure!' } ); 改变原型链 // Extend an existing object with a method from another function mix(receivingClass, givingClass) { // mix-in provide certain methods if (arguments[2]) { for (var i = 2, len = arguments.length; i Singleton Pattern 原型与构造函数指针运作正常 function Universe() { // 缓存实例 var instance; // anti-Self-Defined Function Pattern // 反-自定义函数模式: 先重写,再初始化 Universe = function Universe() { return instance; }; // 保存原型,使其一直保持于同一位置 // (this指针指向不重要) Universe.prototype = this; instance = new Universe(); // 重定向constructor指针 instance.constructor = Universe; // 功能代码 instance.start_time = 0; instance.bang = 'Big'; return instance; } Abstract Factory var AbstractVehicleFactory = (function() { // Storage for our vehicle types var types = {}; function _getVehicle(type, customizations) { var Vehicle = types[type]; return Vehicle ? new Vehicle(customizations) : null; } function _registerVehicle(type, Vehicle) { var proto = Vehicle.prototype; // only register classes that fulfill the vehicle contract if (proto.drive && proto.breakDown) { types[type] = Vehicle; } return AbstractVehicleFactory; } return { getVehicle: _getVehicle, registerVehicle: _registerVehicle }; })(); Factory Method module.exports = (function() { function VehicleFactory() { var publicVehicle = new Object(); // specific factory function Car(options) { this.type = 'car'; this.doors = options.doors || 4; this.state = options.state || 'brand new'; this.color = options.color || 'silver'; this.speed = options.speed || 10; } function Truck(options) { this.type = 'truck'; this.state = options.state || 'used'; this.wheelSize = options.wheelSize || 'large'; this.color = options.color || 'blue'; this.speed = options.speed || 8; } // public features of vehicle , added to __proto__ function _run() { var args = [].slice.call(arguments); if (args.length === 0) { console.log(this.type + ' - run with: ' + this.speed + 'km/s'); } else if (toString.apply(args[0]) === '[object Number]') { this.speed = args[0]; } } function _withColor() { var args = [].slice.call(arguments); if (args.length === 0) { console.log( 'The color of this ' + this.type + ' product is : ' + this.color ); } else if (toString.apply(args[0]) === '[object String]') { this.color = args[0]; } } // provide a function to change other public features function _reform(funcName, newFunc) { if ( typeof this[funcName] === 'function' || typeof this.prototype[funcName] === 'function' ) { delete this[funcName]; this.prototype[funcName] = newFunc; } } // provide a function to add new public features function _addFeature(funcName, newFunc) { if (typeof this[funcName] === 'undefined') { this[funcName] = newFunc; this.prototype[funcName] = newFunc; } } // private features, added to obj // core: create method this.create = function(options) { var vehicleClass = '', newVehicle = {}; if (options.type === 'car') { vehicleClass = Car; } else { vehicleClass = Truck; } // create new vehicle with options, by pre-defined specific constructor newVehicle = new vehicleClass(options); // set up prototype newVehicle.__proto__ = publicVehicle; newVehicle.prototype = publicVehicle; // add public feature newVehicle.prototype.run = _run; newVehicle.prototype.withColor = _withColor; newVehicle.prototype.reform = _reform; newVehicle.prototype.addFeature = _addFeature; // add private(seperately) feature // return new obj return newVehicle; }; } // define more factory return { vehicleFactory: VehicleFactory }; })(); Adapter Pattern 适配器通过内部使用新接口规定的属性/方法, 创建一个外观与旧接口一致 的方法 old.method(); adapter.method(); // 实现此 method 时,使用了新接口规定的属性/方法 // old interface function Shipping() { this.request = function(zipStart, zipEnd, weight) { // ... return '$49.75'; }; } // new interface function AdvancedShipping() { this.login = function(credentials) { /* ... */ }; this.setStart = function(start) { /* ... */ }; this.setDestination = function(destination) { /* ... */ }; this.calculate = function(weight) { return '$39.50'; }; } // adapter interface function AdapterShipping(credentials) { var shipping = new AdvancedShipping(); shipping.login(credentials); return { request: function(zipStart, zipEnd, weight) { shipping.setStart(zipStart); shipping.setDestination(zipEnd); return shipping.calculate(weight); } }; } var shipping = new Shipping(); var adapterShipping = new AdapterShipping(credentials); // original shipping object and interface var cost = shipping.request('78701', '10010', '2 lbs'); log.add('Old cost: ' + cost); // new shipping object with adapted interface cost = adapter.request('78701', '10010', '2 lbs'); Decorator Pattern 重写/重载/扩展对象原有的行为(method),但不改变对象原有属性 可以添加新属性，并围绕新属性扩展对象的原行为 e.g 原对象只会说中文，装饰后同时说中文与英文 避免了通过继承来为类型添加新的职责的形式可取，通过继承的方式容易造成子类的膨胀 保持接口的一致性，动态改变对象的外观/职责 ConcreteDecorator 类: private ClassName component;(拥有一个对象引用) const __decorate = function(decorators, target, key, desc) { const argumentsLength = arguments.length; let descriptorOrTarget; let decorator; if (argumentsLength = 0; i--) { if ((decorator = decorators[i])) { if (argumentsLength 3 && descriptorOrTarget) { Object.defineProperty(target, key, descriptorOrTarget); } return descriptorOrTarget; }; 实现 1(关键 - 实现传递方式) 两种方式: uber 属性获得每次装饰后结果 循环叠加每次装饰后结果 return this.uber.function() // 构造函数 function Sale(price) { this.price = price || 100; } Sale.prototype.getPrice = function() { return this.price; }; // 定义具体装饰器 // 通过uber属性获得上一次装饰后的结果 Sale.decorators = {}; Sale.decorators.fedtax = { getPrice: function() { var price = this.uber.getPrice(); price += (price * 5) / 100; return price; } }; Sale.decorators.quebec = { getPrice: function() { var price = this.uber.getPrice(); price += (price * 7.5) / 100; return price; } }; Sale.decorators.money = { getPrice: function() { return '$' + this.uber.getPrice().toFixed(2); } }; Sale.decorators.cdn = { getPrice: function() { return 'CDN$ ' + this.uber.getPrice().toFixed(2); } }; Sale.prototype.decorate = function(decorator) { var F = function() {}, overrides = this.constructor.decorators[decorator], i, newobj; // 临时代理构造函数 F.prototype = this; newobj = new F(); // 传递实现的关键 // 通过uber属性获得上一次装饰后的结果 newobj.uber = F.prototype; for (i in overrides) { if (overrides.hasOwnProperty(i)) { newobj[i] = overrides[i]; } } return newobj; }; Decorators List // 构造函数 function Sale(price) { this.price = price > 0 || 100; this.decorators_list = []; } Sale.prototype.getPrice = function() { return this.price; }; // 定义具体装饰器 Sale.decorators = {}; Sale.decorators.fedtax = { getPrice: function(price) { return price + (price * 5) / 100; } }; Sale.decorators.quebec = { getPrice: function(price) { return price + (price * 7.5) / 100; } }; Sale.decorators.money = { getPrice: function(price) { return '$' + price.toFixed(2); } }; Sale.prototype.decorate = function(decorator) { this.decorators_list.push(decorator); }; Sale.prototype.getPrice = function() { var price = this.price, i, max = this.decorators_list.length, name; for (i = 0; i 实现 2 // The constructor to decorate function MacBook() { this.cost = function() { return 997; }; this.screenSize = function() { return 11.6; }; } // Decorator 1 function Memory(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 75; }; } // Decorator 2 function Engraving(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 200; }; } // Decorator 3 function Insurance(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 250; }; } var mb = new MacBook(); Memory(mb); Engraving(mb); Insurance(mb); // Outputs: 1522 console.log(mb.cost()); // Outputs: 11.6 console.log(mb.screenSize()); Facade Pattern 将多个复杂的子系统封装+合并，实现一个复杂功能，但只暴露一个简单的接口 - 封装复杂逻辑 var sabertazimi = {}; sabertazimi.addMyEvent = function(el, ev, fn) { if (el.addEventListener) { el.addEventListener(ev, fn, false); } else if (el.attachEvent) { el.attachEvent('on' + ev, fn); } else { el['on' + ev] = fn; } }; Flyweight Pattern 减小内存开销: 内在信息 - 对象中的内部方法所需信息/属性, 一个单独的享元可替代大量具有相同内在信息的对象 外部状态作为方法参数:使之适应不同的外部状态(context)——对象实例差异处 某个类型的对象有大量的实例，对这些实例进行分类，合并相同分类的对象，只创建少量实例(享元) 通过享元工厂来管理一组享元，当所需享元已存在时，返回已存在享元;当所需享元不存在时，创建新享元 function Flyweight(make, model, processor) { this.make = make; this.model = model; this.processor = processor; } var FlyWeightFactory = (function() { var flyweights = {}; return { get: function(make, model, processor) { // 不存在所需享元，新建新享元 if (!flyweights[make + model]) { flyweights[make + model] = new Flyweight(make, model, processor); } return flyweights[make + model]; }, getCount: function() { var count = 0; for (var f in flyweights) count++; return count; } }; })(); var Computer = function(make, model, processor, memory, tag) { this.flyweight = FlyWeightFactory.get(make, model, processor); this.memory = memory; this.tag = tag; this.getMake = function() { return this.flyweight.make; }; // ... }; function ComputerCollection() { var computers = {}; var count = 0; return { add: function(make, model, processor, memory, tag) { computers[tag] = new Computer(make, model, processor, memory, tag); count++; }, get: function(tag) { return computers[tag]; }, getCount: function() { return count; } }; } (function() { var computers = new ComputerCollection(); computers.add('Dell', 'Studio XPS', 'Intel', '5G', 'Y755P'); computers.add('Dell', 'Studio XPS', 'Intel', '6G', 'X997T'); computers.add('Dell', 'Studio XPS', 'Intel', '2G', 'NT777'); computers.add('Dell', 'Studio XPS', 'Intel', '2G', '0J88A'); computers.add('HP', 'Envy', 'Intel', '4G', 'CNU883701'); computers.add('HP', 'Envy', 'Intel', '2G', 'TXU003283'); console.log('Computers: ' + computers.getCount()); console.log('Flyweights: ' + FlyWeightFactory.getCount()); })(); Proxy Pattern 通过一个代理对象，临时存储原对象方法调用产生的一系列结果(新建对象),减少重复对象的产生 function GeoCoder() { this.getLatLng = function(address) { if (address === 'Amsterdam') { return '52.3700° N, 4.8900° E'; } else if (address === 'London') { return '51.5171° N, 0.1062° W'; } else if (address === 'Paris') { return '48.8742° N, 2.3470° E'; } else if (address === 'Berlin') { return '52.5233° N, 13.4127° E'; } else { return ''; } }; } function GeoProxy() { var geocoder = new GeoCoder(); var geocache = {}; return { getLatLng: function(address) { if (!geocache[address]) { geocache[address] = geocoder.getLatLng(address); } log.add(address + ': ' + geocache[address]); return geocache[address]; }, getCount: function() { var count = 0; for (var code in geocache) { count++; } return count; } }; } Command Pattern 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁 (多个对象中的某个随机对象)，也不知道被请求的操作是什么. 此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此的耦合关系 将方法/动作封装成对象, 使得外部通过唯一方法 excute/run 调用内部方法/动作 客户创建命令；调用者执行该命令；接收者在命令执行时执行相应操作 客户通常被包装为一个对象，但是这不是必然的 调用者接过命令并将其保存下来, 它会在某个时候调用该命令对象的 execute 方法 调用者进行 commandObject.execute 这种调用时， 它所调用的方法将转而以 receiver.action() 这种形式调用恰当的方法 client and receiver const SimpleCommand = function(receving) { this.receiving = receving; }; SimpleCommand.prototype.execute = function() { this.receiving.action(); }; module.exports = (function() { var manager = {}; // command to be encapsulted manager.isNull = function(nu) { return toString.apply(nu) === '[object Null]'; }; manager.isArray = function(arr) { return toString.apply(arr) === '[object Array]'; }; manager.isString = function(str) { return toString.apply(str) === '[object String]'; }; // public api function execute(command) { return ( manager[command] && manager[command].apply(manager, [].slice.call(arguments, 1)) ); } function run(command) { return ( manager[command] && manager[command].apply(manager, [].slice.call(arguments, 1)) ); } return { execute: execute, run: run }; })(); command pattern in UI development, bind command to UI components: executor: UI components client and receiver: background tasks or other UI components executor -> client: command.execute() -> receiver: receiver.action() e.g click button -> refresh menu // receiver const MenuBar = { action() { this.refresh(); }, refresh() { console.log('refresh menu pages'); } }; // client: command object // command: object with `action` implemented const Command = receiver => { return function() { receiver.action(); }; }; const RefreshMenuBarCommand = Command(MenuBar); // executor button.setCommand = command => { button.command = command; }; button.setCommand(RefreshMenuBarCommand); button.addEventLister('click', event => { button.command(); }); const MenuCommand = function(action) { this.action = action; }; MenuCommand.prototype.execute = function() { this.action(); }; const fileActions = new FileActions(); const EditActions = new EditActions(); const InsertActions = new InsertActions(); const HelpActions = new HelpActions(); const appMenuBar = new MenuBar(); //----------- const fileMenu = new Menu('File'); const openCommand = new MenuCommand(fileActions.open); const closeCommand = new MenuCommand(fileActions.close); const saveCommand = new MenuCommand(fileActions.save); const saveAsCommand = new MenuCommand(fileActions.saveAs); fileMenu.add(new MenuItem('open', openCommand)); fileMenu.add(new MenuItem('Close', closeCommand)); fileMenu.add(new MenuItem('Save', saveCommand)); fileMenu.add(new MenuItem('Close', saveAsCommand)); appMenuBar.add(fileMenu); //-------------- const editMenu = new Menu('Edit'); const cutCommand = new MenuCommand(EditActions.cut); const copyCommand = new MenuCommand(EditActions.copy); const pasteCommand = new MenuCommand(EditActions.paste); const deleteCommand = new MenuCommand(EditActions.delete); editMenu.add(new MenuItem('Cut', cutCommand)); editMenu.add(new MenuItem('Copy', copyCommand)); editMenu.add(new MenuItem('Paste', pasteCommand)); editMenu.add(new MenuItem('Delete', deleteCommand)); appMenuBar.add(editMenu); //------------ const insertMenu = new Menu('Insert'); const textBlockCommand = new MenuCommand(InsertACtions.textBlock); insertMenu.add(new MenuItem('Text Block', textBlockCommand)); appMenuBar.add(insertMenu); //------------ const helpMenu = new Menu('Help'); const showHelpCommand = new MenuCommand(HelpActions.showHelp()); helpMenu.add(new MenuItem('Show Help', showHelpCommand)); appMenuBar.add(helpMenu); document.getElementsByTagName('body')[0].appendChild(appMenuBar.getElement()); appMenuBar.show(); Command sequences to implement Macro/Batch/Undo command: const Cursor = function(width, height, parent) { this.width = width; this.height = height; this.commandStack = []; this.canvas = document.createElement('canvas'); this.canvas.width = this.width; this.canvas.height = this.height; parent.appendChild(this.canvas); this.ctx = this.canvas.getContext('2d'); this.ctx.fillStyle = '#CCC000'; this.move(0, 0); }; Cursor.prototype = { move: function(x, y) { var _this = this; this.commandStack.push(function() { _this.lineTo(x, y); }); }, lineTo: function(x, y) { this.position.x += x; this.position.y += y; this.ctx.lineTo(this.position.x, this.position.y); }, executeCommands: function() { this.position = { x: this.width / 2, y: this.height / 2 }; this.ctx.clearRect(0, 0, this.width, this.height); this.ctx.beginPath(); this.ctx.moveTo(this.position.x, this.position.y); for (var i = 0; i Mediator Pattern 一个 Mediator 对象封装对象间的协议: 中央集权的控制中心 - 所有观察者共享一个共有的被观察者(所有订阅者订阅同一个节点). Observer Pattern 被观察者(Subject)维护一组观察者列表，每当被观察者状态改变时，调用 notify 函数，此函数中调用观察者(Observer)的 update 函数(可自定义) decouple subject and observer: each depends on Abstraction not Implementation function ObserverList() { this.observerList = []; } ObserverList.prototype.Add = function(obj) { return this.observerList.push(obj); }; ObserverList.prototype.Empty = function() { this.observerList = []; }; ObserverList.prototype.Count = function() { return this.observerList.length; }; ObserverList.prototype.Get = function(index) { if (index > -1 && index Pub-Sub Pattern 观察者模式中主体和观察者是互相感知 发布-订阅模式是借助第三方来实现调度, 发布者和订阅者之间互不感知 Implementation pubsubz.js module.exports = (function(window, doc, undef) { var pubsubz = {}; var topics = {}, subUid = -1; pubsubz.publish = function(topic, args) { // undefined check if (!topics[topic]) { return false; } setTimeout(function() { var subscribers = topics[topic], len = subscribers ? subscribers.length : 0; while (len--) { subscribers[len].func(topic, args); } }, 0); return true; }; pubsubz.subscribe = function(topic, func) { // undefined check if (!topics[topic]) { topics[topic] = []; } // add observer to observerlist(topics) var token = (++subUid).toString(); topics[topic].push({ token: token, func: func }); return token; }; pubsubz.unsubscribe = function(token) { for (var m in topics) { if (topics[m]) { for (var i = 0, j = topics[m].length; i test.js var pubsub = require('./pubsubz.js'); // add observer to observerlist var testFirstSub = pubsub.subscribe('login', function(topic, data) { console.log(topic + ': ' + data); }); // subject broadcast/notify, observer update pubsub.publish('login', 'hello world!'); pubsub.publish('login', ['test', 'a', 'b', 'c']); pubsub.publish('login', [{ color: 'blue' }, { text: 'hello' }]); setTimeout(function() { pubsub.unsubscribe(testFirstSub); }, 0); // permanent subscribe pubsub.subscribe('sum', function(topic, data) { if (toString.apply(data) !== '[object Array]') { console.log('Please input array: * ' + data + ' * is not array!'); } else { var tmp = data.filter(function(item) { return toString.apply(item) === '[object Number]'; }); if (tmp.length) { var sum = tmp.reduce(function(previous, current) { return previous + current; }, 0); console.log('sumof ' + data + ' : ' + sum); } else { console.log( 'Please input number array: * ' + data + ' * is not number array!' ); } } return this; }); pubsub.publish('login', 'hello again!'); pubsub.publish('sum', 'hello again!'); pubsub.publish('sum', [1, 2, 3, 4, 5]); pubsub.publish('sum', ['a', 'b', 'c', 'd', 'e']); in jQuery // Equivalent to subscribe(topicName, callback) $(document).on('topicName', function() { //..perform some behaviour }); // Equivalent to publish(topicName) $(document).trigger('topicName'); // Equivalent to unsubscribe(topicName) $(document).off('topicName'); MicroEvent.js /** * MicroEvent - to make any js object an event emitter (server or browser) * * - pure javascript - server compatible, browser compatible * - dont rely on the browser doms * - super simple - you get it immediatly, no mistery, no magic involved * * - create a MicroEventDebug with goodies to debug * - make it safer to use */ var MicroEvent = function() {}; MicroEvent.prototype = { bind: function(event, fct) { this._events = this._events || {}; this._events[event] = this._events[event] || []; this._events[event].push(fct); }, unbind: function(event, fct) { this._events = this._events || {}; if (event in this._events === false) return; this._events[event].splice(this._events[event].indexOf(fct), 1); }, trigger: function(event /* , args... */) { this._events = this._events || {}; if (event in this._events === false) return; for (var i = 0; i Sample Ajax Callback 当请求返回，并且实际的数据可用的时候，会生成一个通知 如何使用这些事件（或者返回的数据），都是由订阅者自己决定的 可以有多个不同的订阅者，以不同的方式使用返回的数据 Ajax 层: 唯一的责任 - 请求和返回数据，接着将数据发送给所有想要使用数据的地方 (function ($) { // Pre-compile template and \"cache\" it using closure var resultTemplate = _.template($( \"#resultTemplate\" ).html()); // Subscribe to the new search tags topic $.subscribe( \"/search/tags\" , function( tags ) { $( \"#searchResults\" ) .html(\" Searched for:\" + tags + \" \"); }); // Subscribe to the new results topic $.subscribe( \"/search/resultSet\" , function( results ){ $( \"#searchResults\" ).append(resultTemplate( results )); }); // Submit a search query and publish tags on the /search/tags topic $( \"#flickrSearch\" ).submit( function( e ) { e.preventDefault(); var tags = $(this).find( \"#query\").val(); if ( !tags ){ return; } $.publish( \"/search/tags\" , [ $.trim(tags) ]); }); // Subscribe to new tags being published and perform // a search query using them. Once data has returned // publish this data for the rest of the application // to consume $.subscribe(\"/search/tags\", function( tags ) { // Ajax Request $.getJSON( \"http://api.flickr.com/services/feeds/\", { tags: tags, tagmode: \"any\", format: \"json\" }, function( data ){ if( !data.items.length ) { return; } $.publish( \"/search/resultSet\" , data.items ); }); }); }()); MV* Pattern 在 MVC 中，视图位于我们架构的顶部，其背后是控制器. 模型在控制器后面，而因此我们的视图了解得到我们的控制器，而控制器了解得到模型. 这里，我们的视图有对模型的直接访问. 然而将整个模型完全暴露给视图可能会有安全和性能损失, 这取决于我们应用程序的复杂性. MVVM 则尝试去避免这些问题. 在 MVP 中，控制器的角色被代理器所取代，代理器和视图处于同样的地位, 视图和模型的事件都被它侦听着并且接受它的调解. 不同于 MVVM，没有一个将视图绑定到视图模型的机制，因此我们转而依赖于每一个视图都实现一个允许代理器同视图去交互的接口. MVVM 进一步允许我们创建一个模型的特定视图子集，包含了状态和逻辑信息, 避免了将模型完全暴露给视图的必要。 不同于 MVP 的代理器，视图模型并不需要去引用一个视图。 视图可以绑定到视图模型的属性上面，视图模型则去将包含在模型中的数据暴露给视图。 像我们所提到过的，对视图的抽象意味着其背后的代码需要较少的逻辑。 jQuery Pattern Plugin Pattern (function($) { $.extend($.fn, { myplugin: function() { // your plugin logic } }); })(jQuery); // the semi-colon before the function invocation is a safety // net against concatenated scripts and/or other plugins // that are not closed properly. (function($, window, document, undefined) { // undefined is used here as the undefined global // variable in ECMAScript 3 and is mutable (i.e. it can // be changed by someone else). undefined isn't really // being passed in so we can ensure that its value is // truly undefined. In ES5, undefined can no longer be // modified. // window and document are passed through as local // variables rather than as globals, because this (slightly) // quickens the resolution process and can be more // efficiently minified (especially when both are // regularly referenced in our plugin). // Create the defaults once var pluginName = 'defaultPluginName', defaults = { propertyName: 'value' }; // The actual plugin constructor function Plugin(element, options) { this.element = element; // jQuery has an extend method that merges the // contents of two or more objects, storing the // result in the first object. The first object // is generally empty because we don't want to alter // the default options for future instances of the plugin this.options = $.extend({}, defaults, options); this._defaults = defaults; this._name = pluginName; this.init(); } Plugin.prototype.init = function() { // Place initialization logic here // We already have access to the DOM element and // the options via the instance, e.g. this.element // and this.options }; // A really lightweight plugin wrapper around the constructor, // preventing against multiple instantiations $.fn[pluginName] = function(options) { return this.each(function() { if (!$.data(this, 'plugin_' + pluginName)) { $.data(this, 'plugin_' + pluginName, new Plugin(this, options)); } }); }; })(jQuery, window, document); © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/functionalProgramming/functionalProgrammingBasicNotes.html":{"url":"programming/functionalProgramming/functionalProgrammingBasicNotes.html","title":"Functional Programming Basic Notes","keywords":"","body":"Functional Programming Basic Notes Functional Programming Basic Notes Lambda Calculus Lambda-expresion (Lamba-term) Lambda Reduction alpha | α 转换 beta | β 归约 eta | η 归约 Church Numerals Defination for Functionanl Programming Datatype Datatype Binding Built-in Tagged Constructor Type Constructor Pattern Matching Tail Position, Tail expression, Tail Call and Tail Recursion Rules for expressions samples Standard ML functions tuples lists let expressions options boolean operations closure lexical scope vs dynamic scope compose and pipeline curry and uncurry Type inference Lambda Calculus Lambda-expresion (Lamba-term) Variable: x Abstraction: λx.M Application: M N e.g. λx.y λx.(λy.xy) 变量 x 本身就是一个有效的 lambda 项 如果 t 是一个 lambda 项，而 x 是一个变量，则 λx.t 是一个 lambda 项（称为 lambda 抽象） 如果 t 和 s 是 lambda 项，那么 (ts) 是一个 lambda 项（称为应用） Lambda Reduction alpha | α 转换 α: λx.x ≡ λy.y 等价变量替换 beta | β 归约 β: ((λV.E) E′) ≡ E[V := E′] 函数抽象应用(apply)于参数的过程 eta | η 归约 λx.M x ≡ M 用于清除 lambda 表达式中存在的冗余函数抽象 Church Numerals 按照皮亚诺公理可得自然数集合表示为 {0, S(0), S(S(0)), ...}, 于是得到如下定义: S ≡ λn.λf.λx.f (n f x) 0 ≡ λf.λx.x 1 ≡ λf.λx.f x 2 ≡ λf.λx.f (f x) 3 ≡ λf.λx.f (f (f x)) ... 对后继函数 S 和丘奇数的简单验证如下： S 0 ≡ (λn.λf.λx.f (n f x)) λf.λx.x = (λn.λg.λy.g (n g y)) λf.λx.x // alpha = (λf.λx.f (n f x))[n := λf.λx.x] // beta = λg.λy.g ((λf.λx.x) g y) // substitute = λg.λy.g (x[f := g, x := y]) // beta = λg.λy.g y // substitute = λf.λx.f x // alpha ≡ 1 Defination for Functionanl Programming avoid mutation first class functions recursive data structures and recursive functions laziness Datatype Datatype Binding tagged union, every constructor name as tag, fields for different constructors can't exist at the same time Built-in Tagged Constructor NONE SOME i [] x :: xs (infix constructor) () Type Constructor type constructor: datatype bindings with variables datatype 'a mylist = EMPTY | CONS of 'a * 'a mylist mylist isn't a type, int list is a type 'a , 'a equivalent/different 'a, 'b different ''a, ''a equivalent Pattern Matching null/isSome check tag part（variant） hd/tl/valOf check data part (extract data) case e of p1 => e1 | pn => en val p = e (* declare multiple variables once time in p(pattern) *) (* declare multiple callee arguments(hidden to caller) once time in p(pattern) *) fun foo p = e In SML, all functions only take 1 argument, a tuple/record: fun f (x, y, z) = x + y + z seems that takes 3 arguments, but truly owing to pattern matching only takes 1 tuple argument Likewise, fun f () = 0 takes 1 empty tuple argument. Futher more, tuples is syntactic sugar for records. As a whole: all functions only take 1 record argument owing to pattern matching. Tail Position, Tail expression, Tail Call and Tail Recursion recursive defination for Tail Position: if E isn't in tail position, then sub expressions of E aren't in tail position if E is in tail position, then some sub expressions of E are in tail position if eb then e1 else e2 is in tail position, then e1 and e2 are in tail position, not eb f (x, e) is in tail position, then f is in tail position(tail call), not x and e fun factorial n = let fun aux(n, acc) = if n = 0 then acc else aux (n-1, n*acc) in aux (n,1) end Rules for expressions Syntactic: syntax rules Semantic: type checking rules Runtime: evaluation rules samples syntax: if e1 then e2 else e3 type: e1 = bool, e2 = e3 = any evaluation: e1 ? e2 : e3 Standard ML functions syntax: fun name (arg1: type1, .., argn: typen) = body type: name = type1 * ... * typen -> body_type lazy evaluation tuples (* tuples *) syntax: e = (e1, ..., en) type: e1 * ... * en (can become fun's arguments list) evaluation: #1 e, #2 e, ..., #n e lists (* lists *) syntax: l = [e1, ..., en] type: [] = elem_type list; hd(head) l = elem_type, tl(tail) x = elem_type list evaluation: cons = e :: l; null [] = false; > 6 :: [1, 3, 5] let expressions syntax: let b1 b2 ... bn in body end type: whole let type = body_type evaluation: whole let result = body_result options NONE : type = 'a option SOME e: type = e_type option isSome: type = 'a option -> bool valOf : type = 'a option -> 'a boolean operations e1 andalso e2: keyword e1 orelse e2 : keyword not e1 : bool -> bool =(equal) <>(not equal) > >= : require two same type elem closure lexical scope vs dynamic scope lexical scope: function where defined dynamic scope: function where called compose and pipeline fun sqrt_of_abs = Math.sqrt o Real.fromInt o abs infix !> fun x !> f = f x fun sqrt_of_abs i = i !> abs !> Real.fromInt !> Math.sqrt curry and uncurry fun carry f x y = f (x, y) fun uncarry f (x, y) = f x y fun range (i, j) = if i > j then [] else i :: range(i+1, j) fun countup = curry range 1 val arr = countup 7 (* maps to [1, 2, ..., 7] *) Type inference © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/game/gameDesignBasicNotes.html":{"url":"programming/game/gameDesignBasicNotes.html","title":"Game Design Basic Notes","keywords":"","body":"Game Design Basic Notes Game Design Basic Notes 游戏心理学 声音设计(音频制作/声音合成) 角色设计 Ai 技能形式 战斗设计 镜头设计 游戏心理学 代入感/角色扮演 操纵感/打击感 故事性 挑战性 探索性 收集性 个性化与自定义 社交性 声音设计(音频制作/声音合成) 声音包络(ASDR): attack decay sustain release 角色设计 表面模型设计: 2D/3D 模型 风格 动作 属性 逻辑设计: 装备切换显示 动作绑点 碰撞盒 Ai 触发逻辑: 警戒范围 攻击范围 援助逻辑 逃跑逻辑 集群逻辑 刷新逻辑 仇恨列表 技能前摇 技能后摇 技能形式 爆发 冲锋 防御: 霸体 格挡 弹刀 防反 绝对防御 发怒: 受击 援助 空击 保护 战斗设计 打击感: 镜头抖动 镜头特写 镜头位移 镜头慢犯 流畅感: 操作缓存响应 动画插值 表现力: 丰富攻击招式 丰富受击反馈 丰富死亡效果 镜头设计 跟随主角 跟随 Boss 场景空间差值镜头 场景限行差值镜头 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/linux/linuxBasicNotes.html":{"url":"programming/linux/linuxBasicNotes.html","title":"Linux Basic Notes","keywords":"","body":"Linux Basic Notes Linux Basic Notes Linux Boot System Grub Grub Configuration Grub Repair Windows Repair Ubuntu Live Repair 重装 Linux SSH 命令 Key SSHD SSH Config File 密钥文件 远程传输文件 命令优先级 Linux 文件架构 Ubuntu Ubuntu Locale Settings Ubuntu Themes Icon Themes GTK Themes GNOME Shell Extension Arch Linux Basic Arch Linux Setup Pacman AUR 命令操作 基本处理命令 ls cd pwd rm cp mv ln 基本搜索命令 locate type apropos whereis/whatis which find grep Process Command ps top jobs bg fg kill killall shutdown pstree vmstat xload/tload screen I/O Command cat sort uniq wc head/tail tee nl fold fmt pr printf 帮助命令 man help shell 内部命令 info System Info 压缩命令 .zip .gz .bz2 .tar.gz/.tar.bz2 .7z 用户命令 用户管理命令 组操作 创建组 修改组 删除组 查看组 用户操作 增加用户 修改用户 删除用户 查看用户 限制用户 权限管理命令 普通权限 ACL 权限 sudo 权限 SetUID/SetGID 权限 显示器管理命令 xrandr 主机信息管理命令 磁盘管理命令 挂载命令 修复命令 分区命令 fdisk parted 包管理命令 rpm 命令 yum 源码包安装 Applications Management 网络连接命令 wget Certbot GFW 网络管理命令 ufw arp netstat nslookup ping telnet traceroute NetFilter 框架 网络扫描命令 fping hping mtr nmap ncat 脚本运行命令 Systemctl 定时任务 crontab 后台任务 开机任务 历史记录命令 history ctrl-r History Shortcuts Device Command Monitor Info Touchpad Synaptics 并行命令 C/C++ Binary Command ldd nm Plot Command Other Command Time Shell 编程 Warings 文件重定向 Here Document 变量 基本变量 built-in 变量 环境变量 Env Commnad 数值运算 declare 命令 Bash Expansions 流程控制语句 if 语句 case 语句 for 语句 while 语句与 until 语句 do while statement Bash Array Bash Function Bash IO 信号 Bash Debugging Shell Script Best Practices Interactive Shell Script Tips Check Root Validation Bash help option Bash slient option Check Command Validation Get Absolute Path Bash error handle Bash loading progress Terminal Tmux Basic Tmux Command Basic Hotkeys Session management Tmux Windows Hotkeys Tmux Panes Hotkeys Tmux Scroll Configuration Perf Tools uptime Top Command dmesg mpstat pidstat iostat free sar perf Linux Tools FFmpeg FFmpeg Probe FFmpeg Transform FFmpeg Cutting FFmpeg Muxing FFmpeg Screenshot FFmpeg Gif FFmpeg Subtitle FFmpeg Watermark FFmpeg Desktop Recording FFmpeg Live Streaming Nginx Nginx Basic Configuration Docker Docker Installation Docker Uninstallation Docker Basic Usage Build Docker Image Run Docker Image Linux Boot System Grub Grub Configuration /etc/default/grub配置文件, 用于一些基本的修改项, 如默认启动项, Grub 界面等待时长, Grub 主题 etc. More details in info -f grub -n 'Simple configuration' # Default Startup OS GRUB_DEFAULT=0 # Default Timeout GRUB_TIMEOUT=5 # https://github.com/vinceliuice/grub2-themes GRUB_THEME=\"/boot/grub/themes/Tela/theme.txt\" /etc/grub.d/*生成/boot/grub/grub.cfg的执行脚本(update-grub命令), 可以更细致地修改启动项, 如各个启动项的名称、顺序等. Grub Repair Windows Repair easyBCD for non-efi loader with efi loader, run command: # root commander bcdedit /set \"{bootmgr}\" path \\EFI\\ubuntu\\grubx64.efi Ubuntu Live Repair sudo add-apt add-apt-repository ppa:yannubuntu/boot-repair sudo apt update sudo apt install boot-repair boot-repair 重装 Linux 自动挂载项 /etc/fstab etc/rc.local 自定义脚本-新建目录(加入环境变量) 自定义别名 ~/.bashrc SSH 命令 Key ssh-keygen -t rsa ssh-add ~/.ssh/id_rsa SSHD config file in /etc/ssh/sshd_config sudo systemctl reload sshd sudo service restart sshd SSH Config File ~/.ssh/config: Host 别名 HostName 主机名(ip) ssh user@ip Port 可忽略 User 登录用户名 ssh user@ip PreferredAuthentications publickey IdentityFile 密钥文件完整路径 ssh -i file Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Host cs.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/cs Host cloud HostName xx.org User root IdentityFile ~/.ssh/dsl_private_key Host bwg HostName 23.106.150.152 User root Port 29692 git clone git@github.com:user/repo git clone git@cs.github.com:user/repo ssh -qTfnN -D 7070 bwg google-chrome socks5 127.0.0.1 7070 密钥文件 登录远程主机：ssh -i hustlyl root@119.29.140.60 文件传输：sftp -i hustlyl root@119.29.140.60 登录数据库：mysql -h 10.66.135.125 -P 3306 -uroot -p 远程传输文件 rsync -ax -e 'ssh -c blowfish' /root/start_dir root@x.x.x.x:/root/dest_dir sshpass -p \"$DEPLOY_PASSWORD\" \\ scp -o StrictHostKeyChecking=no \\ -P $DEPLOY_PORT \\ -r ./build $DEPLOY_USER@$DEPLOY_ADDR:/var/www/html 命令优先级 包含路径命令 ./vmtools.pl >别名命令 >bash 内部命令 >$PATH 包含目录内的命令 /bin /sbin Linux 文件架构 man hier 通过源码包安装的软件，可以通过 ./configure --prefix=/opt/ /usr/src 是内核源码存放的目录 Ubuntu Ubuntu Locale Settings export LANG=en_US xdg-user-dirs-gtk-update export LANG=zh_CN /var/lib/locales/supported.d/local sudo locale-gen zh_CN.GBK sudo locale-gen zh_CN.GB18030 sudo dpkg-reconfigure locales Ubuntu Themes Icon Themes Nightly build for Numix Circle icon: sudo add-apt-repository ppa:numix/ppa sudo apt update sudo apt install numix-icon-theme-circle GTK Themes GTK/GNOME themes located in /usr/share/themes/ or ~/.themes/: # Vimix Cursors Installation git clone https://github.com/vinceliuice/Vimix-cursors sudo ./Vimix-cursors/install.sh # WhiteSur GNOME theme Installation git clone https://github.com/vinceliuice/WhiteSur-gtk-theme sudo ./WhiteSur-gtk-theme/install.sh -t all -i ubuntu # Tweak for Firefox sudo ./WhiteSur-gtk-theme/tweaks.sh -f # Tweak for Snap Apps sudo ./WhiteSur-gtk-theme/tweaks.sh -s # Tweak for GDM sudo ./WhiteSur-gtk-theme/tweaks.sh -g -i ubuntu # Tweak Help Docs sudo ./WhiteSur-gtk-theme/tweaks.sh -h Repair for not detected HDMI problem: sudo dpkg-reconfigure gdm3 sudo apt install --reinstall gdm3 lightdm ubuntu-desktop GNOME Shell Extension Install GNOME shell extension for browser. Install local binding app: sudo apt install chrome-gnome-shell. Visit extensions.gnome.org to install extensions. Arch Linux Basic Arch Linux Setup less /usr/share/aif/docs/official_installation_guide_en pacman -S lynx arch-wiki-docs arch-wiki-lite lynx /usr/share/doc/arch-wiki/html/index.html systemctl enable dhcpcd reboot pacman -S --needed base-devel git wget jshon expac yajl zsh vim makepkg curl -L -O https://aur.archlinux.org/cgit/aur.git/snapshot/package_name.tar.gz cd package_name less PKGBUILD less package_name.install makepkg -si # -s sync deps # -i install # -r rm deps # -c clean up Pacman /etc/pacman.conf /etc/pacman.d/mirrorlist AUR yaourt # packages' list wget https://aur.archlinux.org/packages.gz 命令操作 基本处理命令 ls -lh(long human) -ld(long directory) -i inode(ID 号) --color==auto 权限(user/group/other) 引用计数 user group 文件大小 文件修改时间 文件名 cd -上次目录 ..上级目录 pwd print working directory rm –r delete directory –f delete forcely -i 显示确认信息 cp -r copy directory -p copy property -d copy link -a --all(-pdr) -i 显示确认信息 mv 无需参数(改名+移动) -i 显示确认信息 ln link 命令 .bak/.hard(硬链接) .soft(软链接：创建链接时填写绝对路径) ln -s(创建软链接) [原文件][目标文件] 基本搜索命令 locate 结合 updatedb 命令(该命令一般自动 1 天/次) type indicate how a command name is interpreted apropos display a list of appropriate commands whereis/whatis which find find [搜索路径] [可选参数] [文件名](可加\"\"): -name -iname 不区分大小写 -user user_name 按照所有者搜索 -nouser 搜索没有所有者的文件 -atime(文件访问时间)/-ctime(改变文件属性)/-mtime(改变文件内容) -10(十天内)/10(十天当天)/+10(十天前) -size(文件大小) -25k(小于 25k)/25M(25M)/+25G(大于 25G) -inum inode_number -a / -o 逻辑与/逻辑或(左右两端搜索条件) -exec/-ok `system_command_list {} \\;对搜索结果执行操作 grep grep [可选参数] “字符串” 文件名: -I 不区分大小写 -v 排除指定字符串 Process Command ps report a snapshot of current processes top display tasks jobs list active jobs bg place a job in the background fg place a job in the foreground kill send a signal to a process killall kill processes by name shutdown shutdown or reboot the system pstree outputs a process list arranged in a tree-like pattern vmstat outputs a snapshot of system resource usage: including memory, swap and disk I/O xload/tload draws a graph showing system load over time screen screen -S screenName screen -ls screen -r Ctrl+d // detach window Ctrl+k // kill window I/O Command cat concatenate files sort sort lines of text uniq report or omit repeated lines wc print newline, word, and byte counts for each file head/tail output the first/last part of a file head -n 5 filename tail -f filename tee read from standard input and write to standard output and files [me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip bunzip2 bzip2 .... nl number lines fold wrap each line to a specified length fmt a simple text formatter pr prepare text for printing printf format and print data 帮助命令 man -f 显示操作等级 -k 包含匹配 -1/2/.../9 显示命令不同操作等级的帮助 Commands (Programs) Those commands that can be executed by the user from within a shell. System calls Those functions which must be performed by the kernel. Library calls Most of the libc functions. Special files (devices) Files found in /dev. File formats and conventions The format for /etc/passwd and other human-readable files. Games Conventions and miscellaneous Overviews of various topics, conventions and protocols, character set standards, and miscellaneous other things. System management commands Commands like mount(8), many of which only root can execute. help shell 内部命令 显示 shell 内部命令帮助，如 cd 命令(shell 内部命令) info 显示大型帮助文档 - enter 进入 u 返回 p 上一节 n 下一节 q 退出 System Info sudo add-apt-repository ppa:dawidd0811/neofetch sudo apt-get update sudo apt-get install neofetch sudo apt-get install screenfetch 压缩命令 .zip zip -r(目录) 压缩文件 源文件/源目录 unzip 源文件 -d 指定路径 .gz gzip 源文件 gzip –c 源文件 > 压缩文件 gzip -r 源目录 将源目录下所有子文件分别单独压缩 gzip –d(解压缩) 文件 gunzip 压缩文件 .bz2 不可压缩目录 bzip2 –k(保留源文件) 源文件 bzip2 –d(解压缩) –k(保留压缩文件) 压缩文件 bunzip2 –k(保留压缩文件) 压缩文件 .tar.gz/.tar.bz2 tar [可选参数] 压缩文件(可指定压缩路径) [-c 解压缩路径]源文件/源目录 -z 将.tar 压缩为.tar.gz -j 将.tar 压缩为.tar.bz2 -c 打包 -x 解打包 -t 查看压缩文件 -v 显示过程 -f 指定压缩文件名 -C 指定解压缩路径 -zcvf/-zxvf/-ztcf -jcvf/-jxvf/-jtvf .7z 7z x manager.7z -r -o /home/xx 7z a -t7z -r manager.7z /home/manager/* a: add x: extract -r: recursive -o: specific path -t: type 用户命令 w/who 查看用户详细信息 last 显示所有用户登陆信息(/var/log/wtmp) lastlog 显示所有用户最后一次登陆时间(/var/log/lastlog) 用户管理命令 组操作 创建组 groupadd test 修改组 groupmod -n test2 test -g 删除组 groupdel test2 查看组 groups someuser cat /etc/group cat /etc/passwd | awk -F [:] ‘{print $4}’ \\ |sort|uniq | getent group |awk -F [:] ‘{print $1}’ 用户操作 增加用户 useradd [options] LOGIN Options: -b, --base-dir BASE_DIR 设置基本路径作为用户的登录目录 -c, --comment COMMENT 对用户的注释 -d, --home-dir HOME_DIR 设置用户的登录目录 -D, --defaults 改变设置 -e, --expiredate EXPIRE_DATE 设置用户的有效期 -f, --inactive INACTIVE 用户过期后，让密码无效 -g, --gid GROUP 使用户只属于某个组 -G, --groups GROUPS 使用户加入某个组(附设组) -h, --help 帮助 -k, --skel SKEL_DIR 指定其他的 skel 目录 -K, --key KEY=VALUE 覆盖 /etc/login.defs 配置文件 -m, --create-home 自动创建登录目录 -l, 不把用户加入到 lastlog 文件中 -M, 不自动创建登录目录 -r, 建立系统账号 -o, --non-unique 允许用户拥有相同的 UID -p, --password PASSWORD 为新用户使用加密密码 -s, --shell SHELL 登录时候的 shell -u, --uid UID 为新用户指定一个 UID -Z, --selinux-user SEUSER use a specific SEUSER for the SELinux user mapping useradd -s bash -m testuser passwd testuser # modify `/etc/passwd`, then add to `/etc/sudoers` adduser is a perl script which uses useradd binary in back-end, adduser is more user friendly and interactive. 修改用户 usermod -d /home/test -G test2 test -l 新用户名 旧用户名 修改用户名 -g 新用户组 目标用户 改变用户所属组 gpasswd -a test test2 将用户 test 加入到 test2 组(附设组) gpasswd -d test test2 将用户 test 从 test2 组中移出 usermod -aG sudo 删除用户 userdel test -r 同时删除用户登录目录(/home/xxx) 查看用户 w/who 查看当前登录的所有用户 whoami 查看当前登录用户名 finger apacheuser 查看单个用户信息 限制用户 passwd -l 用户名 锁定用户 passwd -u 用户名 解锁用户 passwd -d 用户名 清除用户密码 权限管理命令 普通权限 chown 用户名：组名 文件名 chgrp 组名 文件名 umask 存储位置 ——/etc/profile 文件默认权限 = 文件默认最大权限 rw-(666) 减去 umask 值(如----w--w-)(022) 目录默认权限 = 目录默认最大权限 rwx(777) 减去 umask 值 id ACL 权限 查看分区 ACL 权限是否开启 dumpe2fs -h 设备分区名 临时开启分区 ACL 权限 mount -o remount,acl 设备分区名 永久开启分区 ACL 权限 /etc/fstab setfacl -m (d:默认权限) u/g:用户名/组名:权限(rwx) 文件名 getfacl 文件名——查看文件 ACL 权限 sudo 权限 /etc/sudoers.tmp SetUID/SetGID 权限 可执行程序/目录+普通用户临时获得 root 权限 （rws）: chmod 0xxx 取消双权限 chmod 2xxx 设置 SetGID 权限 chmod 4xxx 设置 SetUID 权限 chmod 6xxx 设置双权限 显示器管理命令 xrandr xrandr -s 1920x1800 # set resolution 主机信息管理命令 #!/bin/bash # Simple print cpu topology # Author: kodango # numactl --hardware # ls /sys/devices/system/node/node0 # lscpu function get_nr_processor() { grep '^processor' /proc/cpuinfo | wc -l } function get_nr_socket() { grep 'physical id' /proc/cpuinfo | awk -F: '{ print $2 | \"sort -un\"}' | wc -l } function get_nr_siblings() { grep 'siblings' /proc/cpuinfo | awk -F: '{ print $2 | \"sort -un\"}' } function get_nr_cores_of_socket() { grep 'cpu cores' /proc/cpuinfo | awk -F: '{ print $2 | \"sort -un\"}' } echo '===== CPU Topology Table =====' echo echo '+--------------+---------+-----------+' echo '| Processor ID | Core ID | Socket ID |' echo '+--------------+---------+-----------+' while read line; do if [ -z \"$line\" ]; then printf '| %-12s | %-7s | %-9s |\\n' $p_id $c_id $s_id echo '+--------------+---------+-----------+' continue fi if echo \"$line\" | grep -q \"^processor\"; then p_id=`echo \"$line\" | awk -F: '{print $2}' | tr -d ' '` fi if echo \"$line\" | grep -q \"^core id\"; then c_id=`echo \"$line\" | awk -F: '{print $2}' | tr -d ' '` fi if echo \"$line\" | grep -q \"^physical id\"; then s_id=`echo \"$line\" | awk -F: '{print $2}' | tr -d ' '` fi done 磁盘管理命令 主分区(primary)与延伸分区(extended) 延伸分区可以继续划分成逻辑分区(logical) 挂载命令 mount [-t 文件系统][-o 特殊选项] 设备文件名 挂载点(挂载目录/media /misc /mnt) 无参数 显示当前挂载设备 -a 依据/etc/fstab 文件配置,自动挂载 umount 设备文件名/挂载点 fdisk –l 修复命令 sudo debugfs /dev/sda9 > debugfs: lsdel 分区命令 fdisk 分区表类型 MBR n p e l 新 主 逻辑 扩展 分区 w 激活 parted 分区表类型 MBR/GPT mklabel 选择分区表类型 print 打印分区信息 mkpart 新建分区 rm 删除分区 unit 选择单位 quit 结束分区 包管理命令 rpm 命令 安装和卸载时同时存在依赖性(包依赖、库依赖) rpm 查询: -q 包名 查询已安装的包 //必备参数 -a 查询所有已安装的包 -i 查询软件信息 -l list -f 查询系统文件属于哪个软件包 -R 查询软件包的依赖性 -p 查询未安装包 //普适参数 rpm 校验(查看 Cracker 信息): -V 校验已安装包 相应信息不是.号便是被修改项 可用于找回丢失的系统命令 yum 源配置文件:/etc/yum.repos.d cd /etc/yum.repos.d mv CentOS-Base.repo CentOS-Base.repo.bk wget http://mirrors.163.com/.help/CentOS7-Base-163.repo yum makecache yum list yum search 'keyword' yum -y(自动回答 yes) install 包名 yum -y update 包名 yum -y remove 包名 yum grouplist yum groupinstall 软件组名 yum groupremove 软件组名 源码包安装 指定位置: /usr/local/软件名/ /usr/local/src/软件名/ (如上述脚本出错，执行 make clean） make install e.g apche /var/www/html/index.html /usr/local/apache/htdocs/index.html Applications Management desktop shortcut: /usr/share/applications startup apps: gnome-session-properties or gnome-tweaks 网络连接命令 wget 下载全站资料 -P 表示下载到哪个目录 -r 表示递归下载 -np 表示不下载旁站连接. -k 表示将下载的网页里的链接修改为本地链接. -p 获得所有显示网页所需的元素 wget -r -p -np -k -P ~/tmp/ http://java-er.com Certbot Certbot for SSL certificates. GFW Hosts RSS ChinaDNS Sshuttle ProxyChains OpenVPN VPNGate DockerVPN yum install python-setuptools && easy_install pip pip install shadowsocks echo \"nohup sslocal -c /etc/shadowsocks.json /dev/null 2>&1 &\" /etc/rc.local nohup ssserver -c /etc/shadowsocks.json -d start /dev/null 2>&1 & 网络管理命令 用途 net-tool(被淘汰) iproute2 地址和链路配置 ifconfig ip addr, ip link 路由表 route ip route 邻居 arp ip neigh VLAN vconfig ip link 隧道 iptunnel ip tunnel 组播 ipmaddr ip maddr 统计 netstat ss ip link show ip address show ip route show # add commands to /etc/init.d/local.sh rm -fr /etc/udev/rules.d/70-persistent-net.rules # start up network adapter ip link set eth0 up # add/delete static ip ip address add 192.168.1.1/24 dev eth0 ip address del 192.168.1.1/24 dev eth0 # add/delete static route ip route add 192.168.1.0/24 dev eth0 ip route del 192.168.1.0/24 dev eth0 ip route add default via 192.168.0.196 # watch packets watch -n 1 \"ifconfig eth0\" watch -n 1 \"ifconfig eth1\" watch -n 1 \"ifconfig eth2\" ufw ufw status ufw enable ufw allow ssh ufw allow http ufw allow https arp arp -a显示地址解析协议(IP 地址—网卡地址): 网际互联层：IP 协议(网际)、IGMP 协议(互联网组管理)、ICMP 协议(互联网控制报文) 传输层：TCP 协议(传输控制)、UDP 协议(用户数据报) netstat netstat -an查看本机启用的端口: (-a 查看所有连接和监听端口 -n 显示 IP 地址和端口号) -t tcp 协议端口 -u udp 协议端口 -l 监听状态服务 nslookup nslookup domain_name查看 DNS 解析器: /etc/network/interfaces 主机名: /etc/hostname /etc/sysconfig/network /etc/resolv.conf ping ping -c ip/domain探测网络状况 telnet telnet [ip/domain] [端口]远程管理与端口探测命令 traceroute traceroute [-n IP] domain路由跟踪命令 traceroute -n -I -T -p路由扫描 NetFilter 框架 nftables 命令行工具：nft 网络扫描命令 预防策略——SYN 攻击、DDOS 攻击 fping fping -a -u -g -f [target]批量扫描主机地址 hping hping -p -S -a可伪造IP地址 mtr 路由扫描 nmap 批量主机服务扫描: -P ICMP -sS TCP SYN -sT TCP connect() -sU UDP ncat 批量主机服务扫描: -w 设置超时时间 -v 显示命令执行过程 -z 一个输入输出模式 -u UDP 协议 脚本运行命令 exec 1>>output.log exec 2>>error.log Systemctl systemctl enable local in /etc/init.d/local #!/bin/bash ### BEGIN INIT INFO # Provides: local # Required-Start: $all # Required-Stop: # Default-Start: 3 4 5 # Default-Stop: # Short-Description: Personal start script sslocal -c shadowsocks.json -d start 定时任务 crontab /etc/crontab Crontab Quick Tutorial Crontab Generator crontab -l(list) crontab -e(establish) m,n —— 分隔多个时间 m-n —— 表示时间范围 /n —— 表示每隔 n 时间 天数 与 星期 设置 之间 是 “或”关系 /var/spool/cron/user_name/ /var/log/con /etc/cron.*ly 时间表 /etc/anacrontab: 异步时间表 后台任务 jobs —— 所有作业 atq —— 延时作业队列 at -M(不使用邮件发送运行结果) -f filename deltatime atrm 作业号/名 bg/fg 作业号/名 nohup 脚本 & —— 脱离控制台并后台运行脚本 19 ~ -20 （-20 优先级最高） nice -n number 作业号/名 renice number -p PID 开机任务 /etc/rc.local —— 系统开机任务 /etc/profile/ /etc/bash.bashrc —— bash 启动任务/远程登陆任务 /etc/bash.bashrc —— SSH 连接任务 历史记录命令 history -c 清除历史命令 -w (~/.bash_history) 保存历史命令 /etc/profile 中修改 HISTSIZE !n/!!/!字符串 重复执行第 n 条/上一条/指定开头的历史命令 # repeat history command !number ctrl-r press ctrl-r 提示符改变，显示我们正在执行反向增量搜索。 搜索过程是”反向的”，因为我们按照从”现在”到过去 某个时间段的顺序来搜寻。 下一步，我们开始输入要查找的文本搜索返回我们需要的结果。 (enter to execute, ctrl-j to copy) History Shortcuts command function Ctrl-p 移动到上一个历史条目 Ctrl-n 移动到下一个历史条目 Alt- 移动到历史列表开头 Alt-> 移动到历史列表结尾 Ctrl-r 反向增量搜索 Alt-p 反向搜索，非增量搜索 Alt-n 向前搜索，非增量 Ctrl-o 执行历史列表中的当前项，并移到下一个 Device Command Monitor Info sudo apt-get install read-edid sudo get-edid | parse-edid Touchpad Synaptics synclient TouchpadOff=0 并行命令 命令间插入符 command1;command2 顺序执行，相当于 C 语言中语句结束符 command1&&command2 命令同时执行(当 1 正确时)或同时不执行(当 1 出错时) command1 || command2 只执行一个命令(正确命令) command1 | command2 前一正确命令的输出结果作为后一命令的输入结果 e.g ls && echo yes >> .log || echo no >> .log C/C++ Binary Command ldd ldd ./lib.sio nm nm -Ca ./lib.so Plot Command chart.gp #!/usr/bin/env gnuplot set term wxt enhanced set xtics set view set multiplot set size set origin fit plot 'data.dat' using 1:2, 'data.dat' using 1:3 #!/usr/bin/gnuplot -c set terminal png enhanced set output ARG1.\".png\" set style data linespoints show timestamp set title ARG1 set xlabel \"time (seconds)\" set ylabel \"Segments (cwnd, ssthresh)\" plot ARG1 using 1:7 title \"snd_cwnd\", \\ ARG1 using 1:($8>=2147483647 ? 0 : $8) title \"snd_ssthresh\" Other Command Time date change ntp (Network Time Protocol) time sudo apt-get install ntpdate sudo iptables -A OUTPUT -p udp --dport 123 -j ACCEPT sudo iptables -A INPUT -p udp --sport 123 -j ACCEPT sudo ntpdate time.windows.com sudo hwclock --localtime --systohc use local time (not UTC time) sudo timedatectl set-local-rtc 1 Shell 编程 Warings = 左右无空格 () [] 内部最好有空格 数值运算用 (()) 或 $(()) 文件重定向 > 文件名/输出设备名 覆盖标准输出重定向 >> 文件名/输出设备名 追加标准输出重定向 2>(右端无空格)文件名/输出设备名 覆盖错误输出重定向 2>>(右端无空格)文件名/输出设备名 追加错误输出重定向 >/>> 文件 2>&1 &>/&>>文件 覆盖/追加正确输出与错误输出同时重定向 文件名/输入设备名 覆盖/追加标准输入重定向 Here Document commnad #!/bin/bash gnuplot -persist =2147483647 ? 0 : \\$8) title \"snd_ssthresh\" EOF 变量 基本变量 = : 左右两端不可有空格 ' ': 完全标准字符串 \" \": 格式化字符串 调用变量值：$变量名 set/unset——设置/取消变量 built-in 变量 $*/$@: argv[1], ..., argv[n] $0/$1/../$n: argv[0], ..., argv[n] $#: argc $?: exit code of last command if [ \"$?\" -ne \"0\" ];then echo \"sorry, command execution failed!\" fi 每次 shift 命令执行的时候，变量 $2 的值会移动到变量 $1 中，变量 $3 的值会移动到变量 $2 中. 变量 $# 的值也会相应的减 1 #!/bin/bash # posit-param2: script to display all arguments count=1 while [[ $# -gt 0 ]]; do echo \"Argument $count = $1\" count=$((count + 1)) shift done usage () { echo \"$PROGNAME: usage: $PROGNAME [-f file | -i]\" return } # process command line options interactive= filename= while [[ -n $1 ]]; do case $1 in -f | --file) shift filename=$1 ;; -i | --interactive) interactive=1 ;; -h | --help) usage exit ;; *) usage >&2 exit 1 ;; esac shift done 环境变量 /etc/profile.d/*.sh ~/.bash_profile ~/.bashrc /etc/profile /etc/bash.bashrc /etc/issue——shell 登录信息 PS1 环境变量——shell 头行打印信息 PATH 环境变量 Env Commnad env——查看环境变量 export 变量名=变量值——设置环境变量 printenv 数值运算 declare 命令 Bash Expansions $(()) or $[]: arithmetic expansion 一般地, 将数值运算用 (()) [[]] 或 $(()) 括起, 可以确保变量不会被识别为 string read x read y echo $((x + y)) echo $((a b)) then echo \"a > b\" fi if [[ a -gt b ]] then echo \"a > b\" fi if [ \"$a\" -gt \"$b\" ] then echo \"a > b\" fi [[ xxx ]]: condition (( xxx )): arithemetic condition operator function ! EXPRESSION The EXPRESSION is false -n STRING The length of STRING is greater than zero -z STRING The lengh of STRING is zero (ie it is empty) STRING1 == STRING2 STRING1 is equal to STRING2 STRING1 != STRING2 STRING1 is not equal to STRING2 STRING1 > STRING2 STRING1 sorts after STRING2 STRING1 STRING1 sorts before STRING2 INTEGER1 -eq INTEGER2 INTEGER1 is numerically equal to INTEGER2 INTEGER1 -gt INTEGER2 INTEGER1 is numerically greater than INTEGER2 INTEGER1 -lt INTEGER2 INTEGER1 is numerically less than INTEGER2 -d FILE FILE exists and is a directory -e FILE FILE exists -r FILE FILE exists and the read permission is granted -s FILE FILE exists and it's size is greater than zero -w FILE FILE exists and the write permission is granted -x FILE FILE exists and the execute permission is granted AND -a && `OR -o ` NOT ! ! {}: group regexp echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b ${}: string expansion ${parameter:-word}: 若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。 若 parameter 不为空，则展开结果是 parameter 的值 ${parameter:+word}: 若 parameter 没有设置或为空，展开结果为空。 若 parameter 不为空， 展开结果是 word 的值会替换掉 parameter 的值 ${parameter:=word}: 若 parameter 没有设置或为空，展开结果是 word 的值。 另外，word 的值会赋值给 parameter。 若 parameter 不为空，展开结果是 parameter 的值 ${parameter:?word}: 若 parameter 没有设置或为空，这种展开导致脚本带有错误退出， 并且 word 的内容会发送到标准错误。 若 parameter 不为空， 展开结果是 parameter 的值 ${!prefix*} ${!prefix@}: 这种展开会返回以 prefix 开头的已有变量名 ${#parameter}: 展开成由 parameter 所包含的字符串的长度 ${parameter:offset} ${parameter:offset:length}: 提取一部分字符 ${parameter,,} 把 parameter 的值全部展开成小写字母 ${parameter,} 仅仅把 parameter 的第一个字符展开成小写字母 ${parameter^^} 把 parameter 的值全部转换成大写字母 ${parameter^} 仅仅把 parameter 的第一个字符转换成大写字母 ${parameter#pattern} ${parameter##pattern}, ${parameter%pattern} ${parameter%%pattern}: 从 paramter 所包含的字符串中清除开头/末尾一部分文本 ${parameter/pattern/string}, ${parameter//pattern/string}, ${parameter/#pattern/string}, ${parameter/%pattern/string}: replace foo=file.txt.zip echo ${foo#*.} txt.zip echo ${foo##*.} zip foo=file.txt.zip echo ${foo%.*} file.txt echo ${foo%%.*} file foo=JPG.JPG echo ${foo/JPG/jpg} jpg.JPG echo ${foo//JPG/jpg} jpg.jpg echo ${foo/#JPG/jpg} jpg.JPG echo ${foo/%JPG/jpg} JPG.jpg $(): command result \"\": allow expansions string '': disallow expansions string 流程控制语句 if 语句 if [[ 条件判断式 ]] ; then 程序 fi if [[ 条件判断式 ]] then 程序 else 程序 fi if [[ 条件判断式1 ]] then 程序1 elif [[ 条件判断式2 ]] then 程序2 …… else 程序n fi case 语句 case $变量名 in “值1”) 程序 ;; “值2”) 程序 ;; *) 程序 ;; esac case pattern function a) word equals \"a\" [[:alpha:]]) word is a single alphabetic character ???) word is exactly three characters long \\*.txt) word ends with the characters “.txt” *) any value of word #!/bin/bash # case-menu: a menu driven system information program clear echo \" Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit \" read -p \"Enter selection [0-3] > \" case $REPLY in 0) echo \"Program terminated.\" exit ;; 1) echo \"Hostname: $HOSTNAME\" uptime ;; 2) df -h ;; 3) if [[ $(id -u) -eq 0 ]]; then echo \"Home Space Utilization (All Users)\" du -sh /home/* else echo \"Home Space Utilization ($USER)\" du -sh $HOME fi ;; *) echo \"Invalid entry\" >&2 exit 1 ;; esac or case pattern #!/bin/bash # case-menu: a menu driven system information program clear echo \" Please Select: A. Display System Information B. Display Disk Space C. Display Home Space Utilization Q. Quit \" read -p \"Enter selection [A, B, C or Q] > \" case $REPLY in q|Q) echo \"Program terminated.\" exit ;; a|A) echo \"Hostname: $HOSTNAME\" uptime ;; b|B) df -h ;; c|C) if [[ $(id -u) -eq 0 ]]; then echo \"Home Space Utilization (All Users)\" du -sh /home/* else echo \"Home Space Utilization ($USER)\" du -sh $HOME fi ;; *) echo \"Invalid entry\" >&2 exit 1 ;; esac fall through case pattern (;;&) #!/bin/bash # case4-2: test a character read -n 1 -p \"Type a character > \" echo case $REPLY in [[:upper:]]) echo \"'$REPLY' is upper case.\" ;;& [[:lower:]]) echo \"'$REPLY' is lower case.\" ;;& [[:alpha:]]) echo \"'$REPLY' is alphabetic.\" ;;& [[:digit:]]) echo \"'$REPLY' is a digit.\" ;;& [[:graph:]]) echo \"'$REPLY' is a visible character.\" ;;& [[:punct:]]) echo \"'$REPLY' is a punctuation symbol.\" ;;& [[:space:]]) echo \"'$REPLY' is a whitespace character.\" ;;& [[:xdigit:]]) echo \"'$REPLY' is a hexadecimal digit.\" ;;& esac for 语句 for 变量 in 值1 值2 值3 …… 值n do 程序 done $(seq 1 50) # 1 2 ... 50 {1..50} # 1 2 ... 50 {0..10..2} # 0 2 4 6 8 10 for (( 初始值;循环控制条件;变量变化 )); do 程序 done while 语句与 until 语句 while [[ 条件判断式 ]] do 程序 done until [[ 条件判断式 ]] do 程序 done (( expression1 )) while (( expression2 )); do commands (( expression3 )) done #!/bin/bash # while-menu: a menu driven system information program DELAY=3 # Number of seconds to display results while [[ $REPLY != 0 ]]; do clear cat \" if [[ $REPLY =~ ^[0-3]$ ]]; then if [[ $REPLY == 1 ]]; then echo \"Hostname: $HOSTNAME\" uptime sleep $DELAY fi if [[ $REPLY == 2 ]]; then df -h sleep $DELAY fi if [[ $REPLY == 3 ]]; then if [[ $(id -u) -eq 0 ]]; then echo \"Home Space Utilization (All Users)\" du -sh /home/* else echo \"Home Space Utilization ($USER)\" du -sh $HOME fi sleep $DELAY fi else echo \"Invalid entry.\" sleep $DELAY fi done echo \"Program terminated.\" #!/bin/bash # while-read: read lines from a file while read distro version release; do printf \"Distro: %s\\tVersion: %s\\tReleased: %s\\n\" \\ $distro \\ $version \\ $release done do while statement while : ; do actions [[ current_time Bash Array Array Reference Bash Function 函数局部变量 local + 变量名 函数参数 : $ + #/？/@/n 引用函数库文件 —— source sh 文件名 / . sh 文件名 可修改~/.bashrc 文件 Bash IO #!/bin/bash # read-validate: validate input invalid_input () { echo \"Invalid input '$REPLY'\" >&2 exit 1 } read -p \"Enter a single item > \" # input is empty (invalid) [[ -z $REPLY ]] && invalid_input # input is multiple items (invalid) (( $(echo $REPLY | wc -w) > 1 )) && invalid_input # is input a valid filename? if [[ $REPLY =~ ^[-[:alnum:]\\._]+$ ]]; then echo \"'$REPLY' is a valid filename.\" if [[ -e $REPLY ]]; then echo \"And file '$REPLY' exists.\" else echo \"However, file '$REPLY' does not exist.\" fi # is input a floating point number? if [[ $REPLY =~ ^-?[[:digit:]]*\\.[[:digit:]]+$ ]]; then echo \"'$REPLY' is a floating point number.\" else echo \"'$REPLY' is not a floating point number.\" fi # is input an integer? if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then echo \"'$REPLY' is an integer.\" else echo \"'$REPLY' is not an integer.\" fi else echo \"The string '$REPLY' is not a valid filename.\" fi #!/bin/bash # read-menu: a menu driven system information program clear echo \" Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit \" read -p \"Enter selection [0-3] > \" if [[ $REPLY =~ ^[0-3]$ ]]; then if [[ $REPLY == 0 ]]; then echo \"Program terminated.\" exit fi if [[ $REPLY == 1 ]]; then echo \"Hostname: $HOSTNAME\" uptime exit fi if [[ $REPLY == 2 ]]; then df -h exit fi if [[ $REPLY == 3 ]]; then if [[ $(id -u) -eq 0 ]]; then echo \"Home Space Utilization (All Users)\" du -sh /home/* else echo \"Home Space Utilization ($USER)\" du -sh $HOME fi exit fi else echo \"Invalid entry.\" >&2 exit 1 fi # interactive mode if [[ -n $interactive ]]; then while true; do read -p \"Enter name of output file: \" filename if [[ -e $filename ]]; then read -p \"'$filename' exists. Overwrite? [y/n/q] > \" case $REPLY in Y|y) break ;; Q|q) echo \"Program terminated.\" exit ;; *) continue ;; esac elif [[ -z $filename ]]; then continue else break fi done fi 信号 man 7 signal —— 传递信号给进程 CTRL + C —— SIGINT CTRL + Z —— SIGSTP kill/killall —— SIGINT trap SIG*/EXIT —— 捕捉信号(后 + 忽略信号/默认处理信号/自定义处理信号) trap – SIG*/EXIT —— 移除信号 Bash Debugging -x option #!/bin/bash -x # trouble: script to demonstrate common errors number=1 if [ $number = 1 ]; then echo \"Number is equal to 1.\" else echo \"Number is not equal to 1.\" fi #!/bin/bash # trouble: script to demonstrate common errors number=1 echo \"number=$number\" # DEBUG set -x # Turn on tracing if [ $number = 1 ]; then echo \"Number is equal to 1.\" else echo \"Number is not equal to 1.\" fi set +x # Turn off tracing Shell Script Best Practices Google Shell Style Guide 指定默认解释器cat /etc/shells 设置bash strict mode 条件判断使用[[ ]] 使用变量时用双引号把变量包起来 cp -r \"$src_dir\" \"$dest_dir\" 使用$()获取表达式的值 使用${arr[@]}进行列表循环 #!/usr/bin/env bash # 设置命令回显 set -x # 遇到未声明的变量则报错停止 set -u # 遇到执行错误则停止 set -e # 管道命令其中一步失败则中止 set -o pipefail Interactive Shell Script Tips Check Root Validation if (( $EUID != 0 )); then echo \"Please run as root!\" exit fi # run as root directly sudo chown root sudo chmod +s Bash help option #!/bin/sh if [[ ${#@} -ne 0 ]] && [[ \"${@#\"--help\"}\" = \"\" ]]; then printf -- '...help...\\n'; exit 0; fi; Bash slient option #!/bin/sh if [[ ${#@} -ne 0 ]] && [[ \"${@#\"--silent\"}\" = \"\" ]]; then stty -echo; fi; # ... # before point of intended output: stty +echo && printf -- 'intended output\\n'; # silence it again till end of script stty -echo; # ... stty +echo; exit 0; Check Command Validation #!/bin/sh _=$(command -v docker); if [[ \"$?\" != \"0\" ]]; then printf -- 'You don\\'t seem to have Docker installed.\\n'; printf -- 'Get it: https://www.docker.com/community-edition\\n'; printf -- 'Exiting with code 127...\\n'; exit 127; fi; Get Absolute Path #!/bin/sh CURR_DIR=\"$(dirname $0);\" printf -- 'moving application to /opt/app.jar'; mv \"${CURR_DIR}/application.jar\" /opt/app.jar; Bash error handle #!/bin/sh error_handle() { stty echo; } if [[ ${#@} -ne 0 ]] && [[ \"${@#\"--silent\"}\" = \"\" ]]; then stty -echo; trap error_handle INT; trap error_handle TERM; trap error_handle KILL; trap error_handle EXIT; fi; # ... Bash loading progress #!/bin/sh printf -- 'Performing asynchronous action..'; ./trigger-action; DONE=0; while [ $DONE -eq 0 ]; do ./async-checker; if [ \"$?\" = \"0\" ]; then DONE=1; fi; printf -- '.'; sleep 1; done; printf -- ' DONE!\\n'; Terminal sudo update-alternatives --install /usr/bin/x-terminal-emulator \\ x-terminal-emulator /opt/Hyper/hyper 50 sudo update-alternatives --config x-terminal-emulator Tmux Basic Tmux Command tmux ls tmux new -s sessionID tmux a -t sessionID # attach tmux show -g >> current.tmux.conf # export configuration Basic Hotkeys ? # 快捷键帮助列表 Session management :new # 创建新的 Session，其中 : 是进入 Tmux 命令行的快捷键 s list sessions $ rename the current session d detach from the current session Tmux Windows Hotkeys c create a new window , rename the current window w list windows % split horizontally \" split vertically n change to the next window p change to the previous window 0 to 9 select windows 0 through 9 Tmux Panes Hotkeys % create a horizontal pane \" create a vertical pane # 切换 Pane 布局 h move to the left pane. * j move to the pane below * l move to the right pane * k move to the pane above * q show pane numbers o toggle between panes } swap with next pane { swap with previous pane ! break the pane out of the window x kill the current pane t # 显示一个时钟 Tmux Scroll C-a + [ to into scoll mode, q to quit scoll mode copy mode can scoll too set -g mouse on for enabling mouse scolling Configuration # C-b is not acceptable -- Vim uses it set-option -g prefix C-a bind-key C-a last-window # Start numbering at 1 set -g base-index 1 # Allows for faster key repetition set -s escape-time 0 # Set status bar set -g status-bg black set -g status-fg white set -g status-left \"\" set -g status-right \"#[fg=green]#H\" # Enable scroll mouse set -g mouse on # Rather than constraining window size to the maximum size of any client # connected to the *session*, constrain window size to the maximum size of any # client connected to *that window*. Much more reasonable. setw -g aggressive-resize on # Allows us to use C-a a to send commands to a TMUX session inside # another TMUX session bind-key a send-prefix # Reload configuration bind r source-file ~/.tmux.conf \\; display-message \"Config reloaded\" # Escape to enter copy mode, v to selection, y to yank, p to paste bind Escape copy-mode bind-key -T copy-mode-vi 'v' send -X begin-selection bind-key -T copy-mode-vi 'y' send -X copy-selection-and-cancel # bind-key -t vi-copy v begin-selection # bind-key -t vi-copy y copy-pipe \"reattach-to-user-namespace pbcopy\" unbind p bind p pasteb setw -g mode-keys vi # Vi # Highlight active window set-window-option -g window-status-current-bg red Perf Tools uptime Top Command top dmesg dmesg | tail mpstat mpstat -P ALL 1 pidstat pidstat 1 iostat iostat -xz 1 free free -m sar `sar -n DEV 1` `sar -n TCP,ETCP 1` perf Perf Examples perf list # events perf stat perf stat -e perf record -e -a perf report Linux Tools FFmpeg # https://www.yanxurui.cc/posts/tool/2017-10-07-use-ffmpeg-to-edit-video ffmpeg -global_options -input_1_options -i input_1 -input_2_options -i input_2 \\ -output_1_options output_1 ... FFmpeg Probe ffprobe input.mp4 ffmpeg -hide_banner -i input.mkv FFmpeg Transform MP4: H264Video + ACCAudio WebM: VP8Video + VorbisAudio OGG: TheoraVideo + VorbisAudio # code decoder information ffmpeg -codecs # mkv to mp4 ffmpeg -i input.mkv -codec copy output.mp4 # compress ffmpeg -i input.mkv -c copy -c:v libx264 -vf scale=-2:720 output.mkv # make mkv with video and subtitle ffmpeg -i input.avi -i input.srt \\ -map 0:0 -map 0:1 -map 1:0 -c:v libx264 -c:a aac -c:s srt output.mkv # flac to mp3 ffmpeg -i \"Michael Jackson - Billie Jean.flac\" \\ -ab 320k \"Michael Jackson - Billie Jean.mp3\" ffmpeg -i music_flac.flac \\ -acodec libmp3lame \\ -ar 44100 \\ -ab 320k \\ -ac 2 music_flac_mp3.mp3 # - acodec: Audio Coder Decoder 音频编码解码器 # - libmp3lame: MP3 解码器 # - ar: audio rate 音频采样率, 默认用原音频的采样率 # - ab: audio bit rate 音频比特率, 默认 128K # - ac: aduio channels 音频声道, 默认采用源音频的声道数 # mp4 to avi ffmpeg -i video.mp4 \\ -s 1920x1080 \\ -pix_fmt yuv420p \\ -vcodec libx264 \\ -preset medium \\ -profile:v high \\ -level:v 4.1 \\ -crf 23 \\ -r 30 \\ -acodec aac \\ -ar 44100 \\ -ac 2 \\ -b:a 128k video_avi.avi # - s: 缩放视频新尺寸 (size) # - pix_fmt：pixel format, 设置视频颜色空间 # - vcodec: Video Coder Decoder, 视频编码解码器 # - preset: 编码器预设 # - profile:v: 编码器配置, 与压缩比有关. 实时通讯-baseline, 流媒体-main, 超清视频-high # - level:v: 对编码器设置的具体规范和限制, 权衡压缩比和画质 # - crf: 设置码率控制模式, constant rate factor恒定速率因子模式, 范围 0~51, 数值越小, 画质越高 # - r:设置视频帧率 # - b:a: 音频比特率, 大多数网站限制音频比特率 128k, 129k FFmpeg Cutting # audio only ffmpeg -i cut.mp4 -vn output.mp3 ffmpeg -i video.mp4 -vn -acodec copy video_novideo.m4a # video only ffmpeg -i video.mp4 -vcodec copy -an video_silent.mp4 # from to cutting ffmpeg -i music.mp3 -ss 00:00:30 -to 00:02:00 -acodec copy music_cutout.mp3 ffmpeg -i in.mp4 -ss 00:01:00 -to 00:01:10 -c copy out.mp4 ffmpeg -ss 00:01:00 -i in.mp4 -to 00:01:10 -c copy -copyts out.mp4 # 30s duration cutting ffmpeg -ss 00:02:00.0 -i input.mkv -t 30 -c copy output.mkv ffmpeg -i input.mkv -ss 00:02:00.0 -t 30 -c copy output.mkv ffmpeg -ss 00:01:30.0 -i input.mkv -ss 00:00:30.0 -t 30 output.mkv FFmpeg Muxing # replace audio ffmpeg -i input.mkv -i input.mp3 -map 0:v -map 1:a -c copy -shortest output.mp4 # merge audio and video ffmpeg -i video_novideo.m4a -i video_silent.mp4 -c copy video_merge.mp4 ffmpeg -i \"concat:01.mp4|02.mp4|03.mp4\" -c copy out.mp4 ffmpeg -i input.mkv -i output.aac \\ -filter_complex \"[0:a][1:a]amerge=inputs=2[a]\" -map 0:v -map \"[a]\" \\ -c:v copy -c:a aac -ac 2 -shortest output.mp4 FFmpeg Screenshot # -vf -> -filter:v ffmpeg -ss 00:30:14.435 -i input.mkv -vframes 1 out.png ffmpeg -i input.mkv -vf fps=1/60 -strftime 1 out_%Y%m%d%H%M%S.jpg FFmpeg Gif ffmpeg -i video.mp4 -ss 7.5 -to 8.5 -s 640x320 -r 15 video_gif.gif palette=\"/tmp/palette.png\" filters=\"fps=10,scale=-1:144:flags=lanczos\" ffmpeg -ss 30 -t 5 -i input.mp4 -vf \"$filters,palettegen\" -y $palette ffmpeg -ss 30 -t 5 -i input.mp4 -i $palette \\ -filter_complex \"$filters [x]; [x][1:v] paletteuse\" -y output.gif FFmpeg Subtitle ffmpeg -i input.mkv -vf subtitles=input.srt output.mp4 ffmpeg -i input.mkv -vf ass=input.ass output.mp4 FFmpeg Watermark ffmpeg -i input.mkv -i input.png \\ -filter_complex \"overlay=W-w-5:5\" -c copy -c:v libx264 output.mkv FFmpeg Desktop Recording # windows ffmpeg -f gdigrab -i desktop rec.mp4 # linux sudo ffmpeg -f fbdev -framerate 10 -i /dev/fb0 rec.mp4 FFmpeg Live Streaming ffmpeg -re i rec.mp4 按照网站要求编码 -f flv \"你的rtmp地址/你的直播码\" Nginx /etc/nginx/sites-available: sites config nginx -t # check config syntax Nginx Basic Configuration 泛域名路径分离: xxx.test.dev -> /usr/local/html/xxx server { listen 80; server_name ~^([\\w-]+)\\.test\\.dev$; root /usr/local/html/$1; } server { # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # root /var/www/html/; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name example.tld www.example.tld; # Cache static assets location ~* \\.(?:jpg|jpeg|gif|png|ico|svg)$ { expires 7d; add_header Cache-Control \"public\"; } location ^~ /assets/ { gzip_static on; expires 12h; add_header Cache-Control \"public\"; } # Cache css and js bundle location ~* \\.(?:css|js)$ { add_header Cache-Control \"no-cache, public, must-revalidate, proxy-revalidate\"; } location / { include /etc/nginx/mime.types; try_files $uri $uri/ /index.html; # try_files $uri $uri/ =404; # proxy_http_version 1.1; # proxy_cache_bypass $http_upgrade; # proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection 'upgrade'; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-Forwarded-Proto $scheme; # proxy_pass http://localhost:3000; } } Docker Docker Installation sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io curl -fsSL https://get.docker.com -o get-docker.sh sudo DRY_RUN=1 sh get-docker.sh sudo systemctl status docker sudo usermod -aG docker $USER Docker Uninstallation docker container stop $(docker container ls -aq) docker system prune -a --volumes sudo apt purge docker-ce docker-ce-cli containerd.io sudo apt autoremove sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd Docker Basic Usage Build Docker Image docker build . -t image-name # use Dockerfile at the root of the repository docker build -t image-name Run Docker Image # docker run -dp : [docker-image] docker run -d -p 80:80 --name app-name docker/getting-started docker run -d -p 80:80/tcp -p 80:80/udp --name app-name docker/getting-started © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/server/messageQueueBasicNotes.html":{"url":"programming/server/messageQueueBasicNotes.html","title":"Message Queue Basic Notes","keywords":"","body":"Message Queue Basic Notes Intro to Message Queue Pros: 解耦: 客户端和服务端解耦, 都只需操作消息队列 广播: 发布-订阅模式, 生产者-消费者模式 提速: 跨系统异步通信, 系统内同步变异步 削峰: 服务端无需一次性处理大量请求, 可以匀速地从消息队列中取出消息进行处理 Cons: 系统复杂度提升 造成系统的暂时不一致性 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/tools/buildTools/CmakeBasicNotes.html":{"url":"programming/tools/buildTools/CmakeBasicNotes.html","title":"Cmake Basic Notes","keywords":"","body":"Cmake Basic Notes Cmake Basic Notes Basic Build System Basic Options Flow Control if control foreach control while control function control Basic Usage of Function Parse Arguments of Function Useful Command Checking Command Testing Command Option Command Math Command List Command Package Command Install Command install binaries install normal files install scripts install directories Install Demo find packages Basic Usage of Find Find.cmake Full Find Demo Useful Tools Config Command Version Config Project Config Environment Config Library for Clients Usage Test Setting Generator Expression Submodule and Dependencies CMake Patterns Modern CMake Interface vs Private Nice Patterns Anti Patterns Reference Basic Build System build for executable cmake_minimum_required(VERSION 2.8.9) project(directory_test) add_definitions(-DUSEXX) add_compile_options(-std=c++11 -Wall -Wextra) # Bring the headers, such as Student.h into the project include_directories(include) # Can manually add the sources using the set command as follows: # set(SOURCES src/mainapp.cpp src/Student.cpp) # However, the file(GLOB...) allows for wildcard additions: file(GLOB SOURCES \"src/*.cpp\") message(STATUS \"CMake demo: build for executable\") add_executable(testStudent ${SOURCES}) build for library cmake_minimum_required(VERSION 2.8.9) project(directory_test) set(CMAKE_BUILD_TYPE Release) # Bring the headers, such as Student.h into the project include_directories(include) # However, the file(GLOB...) allows for wildcard additions: file(GLOB SOURCES \"src/*.cpp\") # Generate the shared library from the sources # flag: SHARED, STATIC, MODULE add_library(testStudent SHARED ${SOURCES}) message(STATUS \"CMake demo: build for library\") # Set the location for library installation -- i.e., /usr/lib in this case # not really necessary in this example. Use \"sudo make install\" to apply install(TARGETS testStudent DESTINATION /usr/lib) use a shared or static library cmake_minimum_required(VERSION 2.8.9) project(TestLibrary) # For the shared library: set(PROJECT_LINK_LIBS libtestStudent.so) link_directories(~/exploringBB/extras/cmake/studentlib_shared/build) # For the static library: # set (PROJECT_LINK_LIBS libtestStudent.a) # link_directories(~/exploringBB/extras/cmake/studentlib_static/build) include_directories(~/exploringBB/extras/cmake/studentlib_shared/include) add_executable(libtest libtest.cpp) target_link_libraries(libtest ${PROJECT_LINK_LIBS} ) message(STATUS \"CMake demo: use library\") set output of library # 指定lib输出目录 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin) # 指定版本 set(DEMO5_VERSION_MAJOR 1) set(DEMO5_VERSION_MINOR 1) set(DEMO5_VERSION_PATCH 1) set(DEMO5_VERSION ${DEMO5_VERSION_MAJOR}.${DEMO5_VERSION_MINOR}.${DEMO5_VERSION_PATCH}) aux_source_directory(. SRC_LIST) add_library(demo5 SHARED ${SRC_LIST}) set_target_properties( demo5 PROPERTIES VERSION ${DEMO5_VERSION} SOVERSION ${DEMO5_VERSION_MAJOR} ) build for library and executable cmake_minimum_required(VERSION 3.5) project(MiniSat VERSION 2.2 LANGUAGES CXX) add_library(libminisat STATIC minisat/core/Solver.cc minisat/utils/Options.cc minisat/utils/System.cc minisat/simp/SimpSolver.cc ) target_compile_features(libminisat PUBLIC cxx_attributes cxx_defaulted_functions cxx_deleted_functions cxx_final ) target_include_directories(libminisat PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) target_compile_definitions(libminisat PUBLIC __STDC_LIMIT_MACROS __STDC_FORMAT_MACROS) # Also build the two MiniSat executables add_executable(minisat minisat/core/Main.cc) target_link_libraries(minisat libminisat) add_executable(minisat-simp minisat/simp/Main.cc) target_link_libraries(minisat-simp libminisat) Basic Options make VERBOSE=1 Standard options: -DCMAKE_BUILD_TYPE= Pick from Release, RelWithDebInfo, Debug, or sometimes more -DCMAKE_INSTALL_PREFIX= /usr/local (the default), ~/.local -D BUILD_SHARED_LIBS= --trace print every line of CMake Flow Control if control Unary: NOT, TARGET, EXISTS (file), DEFINED Binary: STREQUAL, AND, OR, MATCHES(regular expression), VERSION_LESS, VERSION_LESS_EQUAL if(WIN32) message(\"This is win32 platform\") else() message(\"This is not win32 platform\") endif() foreach control set(FOR_LIST demo1.cpp demo2.cpp demo3.cpp) foreach(f ${FOR_LIST}) message(\"now is file: \" ${f}) endforeach () while control set(A \"1\") set(B \"1\") while(A LESS \"1000000\") message(\"${A}\") # Print A math(EXPR T \"${A} + ${B}\") # Add values of A and B; store result in T set(A \"${B}\") # Assign the value of B to A set(B \"${T}\") # Assign the value of T to B endwhile() function control Basic Usage of Function function(doubleIt VALUE) math(EXPR RESULT \"${VALUE} * 2\") message(\"${RESULT}\") endfunction() doubleIt(\"4\") # Prints: 8 function(doubleIt VARNAME VALUE) math(EXPR RESULT \"${VALUE} * 2\") set(${VARNAME} \"${RESULT}\" PARENT_SCOPE) endfunction() doubleIt(RESULT \"4\") # Tell the function to set the variable named RESULT message(\"${RESULT}\") # Prints: 8 function(doubleEach) foreach(ARG ${ARGN}) # Iterate over each argument math(EXPR N \"${ARG} * 2\") # Double ARG's numeric value message(\"${N}\") # Print N endforeach() endfunction() doubleEach(5 6 7 8) # Prints 10, 12, 14, 16 on separate lines Parse Arguments of Function function(COMPLEX) cmake_parse_arguments( COMPLEX_PREFIX \"SINGLE;ANOTHER\" \"ONE_VALUE;ALSO_ONE_VALUE\" \"MULTI_VALUES\" ${ARGN} ) endfunction() complex(SINGLE ONE_VALUE value MULTI_VALUES some other values) Inside the function after this call, you'll find: COMPLEX_PREFIX_SINGLE = TRUE COMPLEX_PREFIX_ANOTHER = FALSE COMPLEX_PREFIX_ONE_VALUE = \"value\" COMPLEX_PREFIX_ALSO_ONE_VALUE = COMPLEX_PREFIX_MULTI_VALUES = \"some;other;values\" Useful Command Checking Command # does this system provide the log and exp functions? include(CheckFunctionExists) check_function_exists(log HAVE_LOG) check_function_exists(exp HAVE_EXP) Testing Command #define a macro to simplify adding tests, then use it macro(do_test arg result) add_test(TutorialComp${arg} Tutorial ${arg}) set_tests_properties(TutorialComp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro(do_test) # do a bunch of result based tests do_test(25 \"25 is 5\") do_test(-25 \"-25 is 0\") include(CTest) # does the application run add_test (TutorialRuns Tutorial 25) # does it sqrt of 25 add_test (TutorialComp25 Tutorial 25) set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION \"25 is 5\") # does it handle negative numbers add_test (TutorialNegative Tutorial -25) set_tests_properties ( TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION \"-25 is 0\" ) # does it handle small numbers add_test (TutorialSmall Tutorial 0.0001) set_tests_properties ( TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION \"0.0001 is 0.01\" ) # does the usage message work? add_test (TutorialUsage Tutorial) set_tests_properties ( TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\" ) Option Command # 是否使用我们自己的函数？ option(USE_MYMATH \"Use tutorial provided math implementation\" ON) # add the MathFunctions library? if(USE_MYMATH) include_directories(\"${PROJECT_SOURCE_DIR}/MathFunctions\") add_subdirectory(MathFunctions) set(EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) endif(USE_MYMATH) # add the executable add_executable(Tutorial tutorial.cxx) target_link_libraries(Tutorial ${EXTRA_LIBS}) Math Command set(ARGS \"EXPR;T;1 + 1\") math(${ARGS}) # Equivalent to calling math(EXPR T \"1 + 1\") List Command set(MY_LIST These are separate arguments) list(REMOVE_ITEM MY_LIST \"separate\") # Removes \"separate\" from the list message(\"${MY_LIST}\") # Prints: These;are;argumentsk Package Command # build a CPack driven installer package include(InstallRequiredSystemLibraries) set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/License.txt\") set(CPACK_PACKAGE_VERSION_MAJOR \"${Tutorial_VERSION_MAJOR}\") set(CPACK_PACKAGE_VERSION_MINOR \"${Tutorial_VERSION_MINOR}\") include(CPack) cpack --config CPackConfig.cmake cpack --config CPackSourceConfig.cmake Install Command install binaries INSTALL(TARGETS targets... [[ARCHIVE|LIBRARY|RUNTIME] [DESTINATION ] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [OPTIONAL] ] [...]) INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic） install normal files INSTALL(FILES files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL]) INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2) install scripts INSTALL(PROGRAMS files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL]) INSTALL(PROGRAMS runhello.sh DESTINATION bin) install directories INSTALL(DIRECTORY dirs... DESTINATION [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...] [USE_SOURCE_PERMISSIONS] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [[PATTERN | REGEX ] [EXCLUDE] [PERMISSIONS permissions...]] [...]) INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj PATTERN \"CVS\" EXCLUDE PATTERN \"scripts/*\" PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ) Install Demo find_package(Bar 2.0 REQUIRED) add_library(Foo ...) target_link_libraries(Foo PRIVATE Bar::Bar) install(TARGETS Foo EXPORT FooTargets LIBRARY DESTINATION lib ARCHIVE DESTINATION lib RUNTIME DESTINATION bin INCLUDES DESTINATION include ) install(EXPORT FooTargets FILE FooTargets.cmake NAMESPACE Foo:: DESTINATION lib/cmake/Foo ) find packages find modules cmake –-help-module-list ls /usr/share/cmake/Modules/ cmake --help-module FindBZip2 Basic Usage of Find project(helloworld) add_executable(helloworld hello.c) find_package (BZip2) if (BZIP2_FOUND) include_directories(${BZIP_INCLUDE_DIRS}) target_link_libraries(helloworld ${BZIP2_LIBRARIES}) endif (BZIP2_FOUND) find_path(Foo_INCLUDE_DIR foo.h) find_library(Foo_LIBRARY foo) mark_as_advanced(Foo_INCLUDE_DIR Foo_LIBRARY) include(FindPackageHandleStandardArgs) find_package_handle_standard_args(Foo REQUIRED_VARS Foo_LIBRARY Foo_INCLUDE_DIR ) if(Foo_FOUND AND NOT TARGET Foo::Foo) add_library(Foo::Foo UNKNOWN IMPORTED) set_target_properties(Foo::Foo PROPERTIES IMPORTED_LINK_INTERFACE_LANGUAGES \"CXX\" IMPORTED_LOCATION \"${Foo_LIBRARY}\" INTERFACE_INCLUDE_DIRECTORIES \"${Foo_INCLUDE_DIR}\" ) endif() Find.cmake add find module for project # cmake/FindDEMO9LIB.cmake # 辅助输出信息 message(\"now using FindDEMO9LIB.cmake find demo9 lib\") # 将demo9.h文件路径赋值给DEMO9LIB_INCLUDE_DIR FIND_PATH(DEMO9LIB_INCLUDE_DIR demo9.h /usr/include/demo9/ /usr/local/demo9/include/) message(\"./h dir ${DEMO9LIB_INCLUDE_DIR}\") # 将libdemo9_lib.a文件路径赋值给DEMO9LIB_LIBRARY FIND_LIBRARY(DEMO9LIB_LIBRARY libdemo9_lib.a /usr/local/demo9/lib/) message(\"lib dir: ${DEMO9LIB_LIBRARY}\") if(DEMO9LIB_INCLUDE_DIR AND DEMO9LIB_LIBRARY) # 设置变量结果 set(DEMO9LIB_FOUND TRUE) endif(DEMO9LIB_INCLUDE_DIR AND DEMO9LIB_LIBRARY) Full Find Demo # CMakeLists.txt cmake_minimum_required(VERSION 3.5) project(demo9) # create libdemo9_lib.a set(SRC_LIB demo9.cpp) add_library(demo9_lib STATIC ${SRC_LIB}) # install it install(TARGETS demo9_lib DESTINATION demo9/lib) install(FILES demo9.h DESTINATION demo9/include) # create demo9_main exectuable set(SRC_EXE demo9_main.cpp) # set demo9_lib cmake module path set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) message(\"cmake_module_path: ${CMAKE_MODULE_PATH}\") find_package(DEMO9LIB) if(DEMO9LIB_FOUND) add_executable(demo9_main ${SRC_EXE}) message(\"found demo9 ${DEMO9LIB_INCLUDE_DIR} ${DEMO9LIB_LIBRARY}\") include_directories(${DEMO9LIB_INCLUDE_DIR}) target_link_libraries(demo9_main ${DEMO9LIB_LIBRARY}) else() message(\"not found DEMO9LIB_FOUND\") endif(DEMO9LIB_FOUND) Useful Tools ldd and ar ldd library.so ar -t library.a Makefile # ----------------------------------------------------------------------------- # CMake project wrapper Makefile ---------------------------------------------- # ----------------------------------------------------------------------------- SHELL := /bin/bash RM := rm -rf MKDIR := mkdir -p all: ./build/Makefile @ $(MAKE) -C build ./build/Makefile: @ ($(MKDIR) build > /dev/null) @ (cd build > /dev/null 2>&1 && cmake ..) clean: @ ($(MKDIR) build > /dev/null) @ (cd build > /dev/null 2>&1 && cmake .. > /dev/null 2>&1) @- $(MAKE) --silent -C build clean || true @- $(RM) ./build/Makefile @- $(RM) ./build/src @- $(RM) ./build/test @- $(RM) ./build/CMake* @- $(RM) ./build/cmake.* @- $(RM) ./build/*.cmake @- $(RM) ./build/*.txt ifeq ($(findstring clean,$(MAKECMDGOALS)),) $(MAKECMDGOALS): ./build/Makefile @ $(MAKE) -C build $(MAKECMDGOALS) endif Config Command Version Config cmake_minimum_required(VERSION 3.1) if(${CMAKE_VERSION} VERSION_LESS 3.13) cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}) else() cmake_policy(VERSION 3.13) endif() Project Config project(MyProject VERSION 1.0 DESCRIPTION \"Very nice project\" LANGUAGES CXX) Environment Config set(ENV{variable_name} value) and get $ENV{variable_name} environment variables Library for Clients Usage include(CMakePackageConfigHelpers) write_basic_package_version_file(\"FooConfigVersion.cmake\" VERSION ${Foo_VERSION} COMPATIBILITY SameMajorVersion ) install(FILES \"FooConfig.cmake\" \"FooConfigVersion.cmake\" DESTINATION lib/cmake/Foo ) include(CMakeFindDependencyMacro) find_dependency(Bar 2.0) include(\"${CMAKE_CURRENT_LIST_DIR}/FooTargets.cmake\") Test Setting set(CTEST_SOURCE_DIRECTORY \"/source\") set(CTEST_BINARY_DIRECTORY \"/binary\") set(ENV{CXXFLAGS} \"--coverage\") set(CTEST_CMAKE_GENERATOR \"Ninja\") set(CTEST_USE_LAUNCHERS 1) set(CTEST_COVERAGE_COMMAND \"gcov\") set(CTEST_MEMORYCHECK_COMMAND \"valgrind\") #set(CTEST_MEMORYCHECK_TYPE \"ThreadSanitizer\") ctest_start(\"Continuous\") ctest_configure() ctest_build() ctest_test() ctest_coverage() ctest_memcheck() ctest_submit() macro(package_add_test TESTNAME) add_executable(${TESTNAME} ${ARGN}) target_link_libraries(${TESTNAME} gtest gmock gtest_main) add_test(${TESTNAME} COMMAND ${TESTNAME}) set_target_properties(${TESTNAME} PROPERTIES FOLDER tests) endmacro() package_add_test(test1 test1.cpp) Generator Expression Most CMake commands happen at configure time, include the if statements seen above. Generator expressions were added at runtime. They are evaluated in target properties: If you want to put a compile flag only for the DEBUG configuration Limiting an item to a certain language only, such as CXX Accessing configuration dependent properties, like target file location Giving a different location for build and install directories target_include_directories(MyTarget PUBLIC $ $ ) Submodule and Dependencies find_package(Git QUIET) if(GIT_FOUND AND EXISTS \"${PROJECT_SOURCE_DIR}/.git\") execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} RESULT_VARIABLE GIT_SUBMOD_RESULT ) if(NOT GIT_SUBMOD_RESULT EQUAL \"0\") message(FATAL_ERROR \"git submodule update --init failed with ${GIT_SUBMOD_RESULT}\") endif() endif() CMake Patterns Modern CMake Modern CMake is all about targets and properties. Constructors of Targets: add_executable() add_library() Member variables of Targets: Target properties Member functions: get_target_property() set_target_properties() get_property(TARGET) set_property(TARGET) target_compile_definitions() target_compile_features() target_compile_options() target_include_directories() target_link_libraries() target_sources() Interface vs Private interface properties model usage requirements, whereas private properties model build requirements of targets. Nice Patterns Think in targets (Object-Oriented) Export your interface: You should be able to run from build or install Write a Config.cmake file: This is what a library author should do to support clients Make ALIAS targets to keep usage consistent Combine common functionality into clearly documented functions Use lowercase function names Upper case is for variables Use cmake_policy and/or range of versions Anti Patterns Do not use global functions: e.g link_directories, include_libraries Don't add unneeded PUBLIC requirements e.g -Wall Don't GLOB files Link to built files directly: Always link to targets if available Never skip PUBLIC/PRIVATE when linking Reference Offical Reference Cmake Practice CGold CMake Modern CMake © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/tools/buildTools/makefileBasicNotes.html":{"url":"programming/tools/buildTools/makefileBasicNotes.html","title":"Makefile Basic Notes","keywords":"","body":"Makfile Basic Notes Makfile Basic Notes Macro Awesome Built-in Macro Awesome Built-in Variable 隐含规则 C C++ Asm Object Linking Function Awesome Tips Reference Macro foo := a.o b.o c.o bar := $(foo:.o=.c) first_second = Hello a = first b = second all = $($a_$b) 这里的$a_$b 组成了 first_second, 于是, $(all)的值就是“Hello”。 Awesome Built-in Macro AR: 函数库打包程序。默认命令是“ar” AS: 汇编语言编译程序。默认命令是“as” CC: C 语言编译程序。默认命令是“cc” CXX: C++语言编译程序。默认命令是“g++” CO: 从 RCS 文件中扩展文件程序。默认命令是“co” CPP: C 程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E” FC: Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77” GET: 从 SCCS 文件中扩展文件的程序。默认命令是“get”。 LEX: Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是“lex” PC: Pascal 语言编译程序。默认命令是“pc” YACC: Yacc 文法分析器（针对于 C 程序）。默认命令是“yacc” YACCR: Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是“yacc –r” MAKEINFO: 转换 Texinfo 源文件（.texi）到 Info 文件程序。默认命令是“makeinfo” TEX: 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是“tex” TEXI2DVI: 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是“texi2dvi” WEAVE: 转换 Web 到 TeX 的程序。默认命令是“weave” CWEAVE: 转换 C Web 到 TeX 的程序。默认命令是“cweave” TANGLE: 转换 Web 到 Pascal 语言的程序。默认命令是“tangle” CTANGLE: 转换 C Web 到 C。默认命令是“ctangle” RM: 删除文件命令。默认命令是“rm –f” ARFLAGS: 函数库打包程序 AR 命令的参数。默认值是“rv” ASFLAGS: 汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时） CFLAGS: C 语言编译器参数 CXXFLAGS: C++语言编译器参数 COFLAGS: RCS 命令参数 CPPFLAGS: C 预处理器参数。（ C 和 Fortran 编译器也会用到） FFLAGS: Fortran 语言编译器参数 GFLAGS: SCCS “get”程序参数 LDFLAGS: 链接器参数。（如：“ld”) LFLAGS: Lex 文法分析器参数 PFLAGS: Pascal 语言编译器参数 RFLAGS: Ratfor 程序的 Fortran 编译器参数 YFLAGS: Yacc 文法分析器参数 Awesome Built-in Variable $@: 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，\"$@\"就是匹配于目标中模式定义的集合 $%: 仅当目标是函数库文件中，表示规则中的目标成员名。 例如，如果一个目标是\"foo.a(bar.o)\"，那么，\"$%\"就是\"bar.o\"，\"$@\"就是\"foo.a\"。 如果目标不是函数库文件（Unix 下是[.a]，Windows 下是[.lib]），那么，其值为空 $ $?: 所有比目标新的依赖目标的集合。以空格分隔 $^: 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份 $+: 这个变量很像\"$^\"，也是所有依赖目标的集合。只是它不去除重复的依赖目标 $* : 这个变量表示目标模式中\"%\"及其之前的部分。如果目标是\"dir/a.foo.b\"， 并且目标的模式是a.%.b，那么， $*的值就是dir/a.foo。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么$*也就不能被推导出， 但是，如果目标文件的后缀是 make 所识别的，那么$*就是除了后缀的那一部分。例如：如果目标是foo.c， 因为\".c\"是 make 所能识别的后缀名，所以，$*的值就是\"foo\"。这个特性是 GNU make 的， 很有可能不兼容于其它版本的 make， 所以，你应该尽量避免使用$*， 除非是在隐含规则或是静态模式中。 如果目标中的后缀是 make 所不能识别的，那么$*就是空值 $(@D): 表示\"$@\"的目录部分（不以斜杠作为结尾）， 如果\"$@\"值是\"dir/foo.o\"，那么\"$(@D)\"就是\"dir\"， 而如果\"$@\"中没有包含斜杠的话，其值就是\".\"（当前目录） $(@F): 表示\"$@\"的文件部分，如果\"$@\"值是\"dir/foo.o\"，那么\"$(@F)\"就是\"foo.o\"， \"$(@F)\"相当于函数\"$(notdir $@)\" $(*D)\"/\"$(*F): 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，$(*D)返回\"dir\"，而$(*F)返回\"foo\" \"$(%D)\"/\"$(%F)\": 分别表示了函数包文件成员的目录部分和文件部分。 这对于形同\"archive(member)\"形式的目标中的\"member\"中包含了不同的目录很有用。 \"$( \"$(^D)\"/\"$(^F)\": 分别表示所有依赖文件的目录部分和文件部分。（无相同的） \"$(+D)\"/\"$(+F)\": 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） \"$(?D)\"/\"$(?F)\": 分别表示被更新的依赖文件的目录部分和文件部分。 隐含规则 C .o的目标的依赖目标会自动推导为.c，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)” C++ .o的目标的依赖目标会自动推导为.cc或是.C, 并且其生成命令是$(CXX) –c $(CPPFLAGS) \\$(CFLAGS) (建议使用.cc作为 C++源文件的后缀，而不是.C). Asm .o 的目标的依赖目标会自动推导为.s，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。 .s 的目标的依赖目标会自动推导为.S，默认使用 C 预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。 Object Linking 目标依赖于.o，通过运行 C 的编译器来运行链接程序生成（一般是“ld”），其生成命令是： $(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS) 这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。例如如下规则： x : y.o z.o 并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令： cc -c x.c -o x.o cc -c y.c -o y.o cc -c z.c -o z.o cc x.o y.o z.o -o x rm -f x.o rm -f y.o rm -f z.o Function filter shell subst wildcard Awesome Tips $(filter %.o,$(files)): %.o: %.c $(filter %.elc,$(files)): %.elc: %.el $(CC) -c $(CFLAGS) $ (%.o) : %.c $(CC) $(CFLAGS) $(CPPFLAGS) -c $ %.d: %.c @set -e; rm -f $@; / $(CC) -M $(CPPFLAGS) $ $@.$$$$; / sed 's,/($*/)/.o[ :]*,/1.o $@ : ,g' $@; / $(RM) -f $@.$$$$ Reference CSDN Blog © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/tools/git/gitBasicNotes.html":{"url":"programming/tools/git/gitBasicNotes.html","title":"Git Basic Notes","keywords":"","body":"Git Basic Note Git Basic Note Basic Config Basic Configuration Proxy Configuration List and Help File State Git Ignore File Diff Add Commit Commit Style Guide Message Subject Type Values Scope Values Message Body Message Footer Stash Revert Remove Move Log Pretty Format Log Options Reflog Show Remote Tag Alias Merge Rebase Branch Basic Workflow Commands Basic Branch Remote Branch Advanced Branch Workflow Master Branch and Develop Branch Feature Branch Release Branch Hotfix Branch Issues Branch Trials Branch BasedOn Branch Work Branch Git Inside Add Inside Commit Inside Checkout Inside Merge Inside Fetch Inside Clone Inside Push Inside HEAD Branch Inside Git Objects GitHub LICENSE Popular LICENSE Unique LICENSE Teamwork Pull Request Work Flow GitHub CLI Tool CLI Installation GH Issue Usage GH PR Usage GH Repo Usage Wiki Wiki Git Access Shorten GitHub URL Git Tools Diff and Patch Semantic Git Commit Message Changelog Generator Purge Tool Commands List Basic Commands git config git help git init git clone git add git status git diff git difftool git commit git reset git rm git mv git clean git branch git checkout git merge git mergetool git log git stash git tag git fetch git pull git push git remote git archive git submodule 检查与比较 git show git shortlog git describe 调试 git bisect git blame git grep 补丁 git cherry-pick git rebase git revert 邮件 git apply git am git format-patch git imap-send git send-email git request-pull 外部系统 git svn git fast-import 管理 git gc git fsck git reflog git filter-branch git-note Basic Config /etc/gitconfig ~/.gitconfig 或 ~/.config/git/config repo/.git/config Basic Configuration git config --global user.name \"sabertazimi\" git config --global user.email sabertazimi@gmail.com git config --global core.editor vim git config --global credential.helper store git config --global color.ui true git config --global commit.template $HOME/.gitmsg.md git config --global push.default simple git config --global pull.rebase true git config --global rebase.autoStash true Proxy Configuration github.com.cnpmjs.org hub.fastgit.org raw.fastgit.org # speed up by cnpmjs # git clone/push/pull works git config --global url.\"https://github.com.cnpmjs.org/\".insteadOf \"https://github.com/\" # post buffer config git config --global http.postbuffer 524288000 git config --global http.postbuffer 1048576000 # proxy git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' List and Help git config --list git --help man git- git help git help config File State Untracked Unmodified(Stable State) Modified Staged Git Ignore File 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略 可以使用标准的 glob 模式(简化正则表达式)匹配 匹配模式可以以（ / ）开头防止递归 匹配模式可以以（ / ）结尾指定目录 要跟踪指定模式以外的文件或目录，可以在模式前加上惊叹号（ ! ）取反 GitHub gitignore Style # no .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf Diff 查看未暂存(un-staged)差异 git diff 查看已暂存(staged)差异 git diff --staged 显示空白字符错误(space/tab/return) git diff --check Add 交互式的选择 add 特定部分 git add -p Commit -a: 跳过暂存阶段(git add) -v: 显示详细 diff 信息 git commit -a -v 重新提交 git commit --amend -a -v Commit Style Guide firstline - (): (emptyline) (emptyline) Message Subject no more than 50 characters Type Values (production code change) feat (new feature for the user) fix (bug fix for the user) docs (changes to the documentation) refactor (refactoring production code, e.g. renaming a variable) (no production code change) style (formatting, missing semi colons) test (adding missing tests, refactoring tests) chore (updating grunt tasks etc) Scope Values init runner watcher config web-server proxy empty Message Body uses the imperative, present tense: “change” not “changed” nor “changes” includes motivation for the change and contrasts with previous behavior Message Footer referencing issues e.g. close #666, #888 breaking changes 碎片式更改(特别是用户端) e.g.port-runner command line option has changed to runner-port, so that it is consistent with the configuration file syntax. To migrate your project, change all the commands, where you use --port-runner to --runner-port. Stash git stash: 备份当前的工作区的内容，将当前的工作区内容保存到 Git 栈 git stash apply/pop: 从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容 git stash branch : 新建分支，并在该分支上恢复储藏内容 git stash list: 显示 Git 栈内的所有备份 git stash clear: 清空 Git 栈 # git stash unapply git stash show -p stash@{0} | git apply -R Pop a single file: git restore -s stash@{0} -- git checkout stash@{0} -- Revert 重新提交前 n 次的 commit git revert -n Remove 完全删除文件 git rm filename --cached: 保留磁盘文件(仅从 git 库移除文件) git rm --cached filename Move git mv old_path new_path Log -p: 打印 diff 差异信息 -n: n 为十进制数字,显示最近 n 次信息 --stat: 打印简略统计信息 --graph: 显示分支合并历史 --pretty=: 设置日志格式 --author=: 指定作者 --committer=: 指定提交者 --after=/--since=: 限制日志时间 --before=/--until=: 限制日志时间 \"2008-01-15\" \"2 years 1 day 3 minutes ago\" --decorate: 查看各个分支当前所指的对象(commit object) --help git log -p --stat --graph --pretty=format:\"%h - %an, %ar : %s\" --since=2.weeks path_name Pretty Format 选项 说明 %H 提交对象(commit)的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象(tree)的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象(parent)的完整哈希字串 %p 父对象的简短哈希字串 %an 作者(author)的名字 %ae 作者的电子邮件地址 %ad 作者修订日期(可以用\\ -date=\\ 选项定制格式) %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期,按多久以前的方式显示 %s 提交说明 Log Options 选项 说明 -p 打印 diff 差异信息 -n n 为十进制数字,显示最近 n 次信息 --stat 打印简略统计信息 --graph 显示分支合并历史 --pretty= 设置日志格式 --author= 指定作者 --committer= 指定提交者 --after=/--since= 限制日志时间 --before=/--until= 限制日志时间 \"2008-01-15\" \"2 years 1 day 3 minutes ago\" --help Reflog git reflog show is an alias for git log -g --abbrev-commit --pretty=oneline. git reflog git reset HEAD@{index} Show 查看其他分支 或 提交点的文件状态 git show branchName/commitHash:fileName Remote 添加与删除远程仓库源 git remote add git remote rm 拉取和推送变更 git pull [remote-name] git push [remote-name] [local-branch-name]:[remote-branch-name] 显示仓库信息 git remote show [remote-name] 重命名仓库缩写名 git remote rename 从本地操作,删除远程仓库的分支 git push origin --delete [remote-branch-name] 保存推送密码 git config --global credential.helper store Tag 列出标记及其信息 git tag git tag -l \"v1.8-\" git show 创建标签: 不加-m 会调用 core.editor) 省略 commit 序列,标签添加至最新提交 创建附注(annotated)标签 git tag -a [commit序列] 创建轻量(lightweight)标签 git tag [commit序列] 共享标签至远程库 git push [remote-name] git push [remote-name] --tags git push --follow-tags Alias !: 执行外部命令 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status git config --global alias.unstage 'reset HEAD --' git config --global alias.last 'log -1 HEAD' git config --global alias.visual '!gitk' Merge 合并的结果是生成一个新的快照(并提交)(新的提交对象) Rebase 切换到工作分支,编码开发新特性 git checkout feature-branch 新特性开发完毕,变基操作以简洁提交历史 git rebase master git rebase [basebranch] [topicbranch] 切换到主分支,合并特性分支 git checkout master git merge feature-branch pull with auto reabse and auto stash git pull --rebase --autostash Branch Basic Workflow Commands Basic Branch 创建新分支 git branch 删除分支 git branch -d git push origin --delete 切换分支 git checkout 切换到新分支 git checkout -b 打印分支信息 git branch -v(详细信息) -vv(详细远程信息) --merged(显示合并至当前分支的分支) --no-merged(显示未合并至当前分支的分支) Remote Branch 本地分支跟踪远程分支(在此本地分支上运行 git pull 自动抓取),2 种方式: 设置当前所在本地分支跟踪某一远程分支 git branch -u [remotename]/[branch] 创建并切换至新的本地分支(跟踪某一远程分支) --track: 本地分支由 git 自动命名 -b: 本地分支由创建者命名 git checkout --track [new-local-branch] git checkout -b [new-local-branch] [remotename]/[branch] Delete remote branch git push origin --delete [remote-branch-name] Advanced Branch Workflow Git Flow Extension: master 类型分支，名为?|master 或 master，其中?为开发代号 develop 类型分支，名为?|develop 或 develop，其中?为开发代号 feature 类型分支，名为 feature/或?|feature/，其中*为特征描述 release 类型分支，名为 release-或?|release-，其中*为要发布的版本号 hotfix 类型分支，名为 hotfix-或?|hotfix-，其中*为要发布的版本号 issues 类型分支，名为 issues/或?|issues/，其中*为问题描述 trials 类型分支，名为？%trials.，？为此分支的父分支，为描述的名称（或直接为？%trials） basedOn 类型分支，名为 basedOn 或?|basedOn，?为其来源的 master 分支的开发代号 work 类型分支，名为 work./basedOn-?-，*代表此描述此 work 的名称, ?为其所基于的分支的开发代号，最后一个*代表其在？|basedOn 上所基于的分支的版本号或状态名 下面介绍模型中的约定，并定义 gg-*这样的抽象动作来完成约定中的行为 Master Branch and Develop Branch 多长期分支模式: master 分支与 develop 分支都是长期分支,区别在于分支的稳定性等级 - master > develop e.g master/develop/next 每一次的提交都必须有意义 git 在每次提交的时候要求输入对此提交的概括，这个概括不能为空。 正确的提交概括：更新了程序 doc 错误的提交概括：updates 开发型任务中的 master 类型与 develop 类型分支必须成对出现, master 分支的推进只能来源与 release 分支和 hotfix 分支的合并，禁止在 master 分支上直接提交 master 分支上只有我们推送上去的稳定版本的程序，develop 分支上的程序一直处于开发状态，不稳定。 在开发型任务中使用 gg-init 进行版本控制的初始化，建立配套的 master ～ develop 分支对。 在使用型任务中使用 gg-work-init 进行版本控制的初始化, 拉取需要使用的稳定版本程序的 master 分支，并初始化对应的 basedOn 分支（见 9）. Feature Branch 只能从 develop 类型分支上创建 最终必须合并到 develop 类型分支 最终分支被删除 每当有新特性需要加入的时候，我们应该从 develop 类型分支上新建一个 feature 类型分支，完成新特性的开发和测试后将特性合并到 develop 类型分支上。 在 develop 类型分支上使用 gg-feature-open featureName 建立并转向一个名为 feature/featureName 的新分支 在一个 feature 类型分支上使用 gg-feature-close 把这个分支的工作合并到 develop 类型分支上，删除此分支，完成一个特性的开发 Release Branch 只能从 develop 类型分支上创建 最终必须同时合并到 master 类型分支(发布新的版本)和 develop 类型分支(基于新版本的进一步开发) 最终分支被删除 每当工作进入到一个较为稳定阶段的时候，可以使用 gg-release-open versionNum 建立一个名为 release-versionNum 的临时分支, 在这个分支上允许进行小的改动（比如修改一下 readme 文件中的版本号）, 然后使用 gg-release-close 将此版本合并（发布）到 master 类型分支上，同时合并到 develop 类型分支上，然后删除此分支. Hotfix Branch 只能从 master 类型分支上创建 最终必须同时合并到 master 类型分支(发布新的热补丁版本)和 develop 类型分支(基于新版本的进一步开发) 最终分支被删除 当新版本发布后发现必须马上解决的严重 bug 时，使用 gg-hotfix-open versionNum 建立名为 hotfix-versionNum 的临时分支, 在这个分支上完成 bug 的修复，然后使用 gg-hotfix-close 将此版本合并（发布）到 master 类型分支上，同时合并到 develop 类型分支上，然后删除此分支. Issues Branch 只能从 develop 类型分支上创建 最终必须合并到 develop 类型分支 最终分支被删除 注解：每当有（比较复杂的）问题需要解决的时候，应该从 develop 类型分支上新建一个 issues 类型分支，完成问题的调试后合并到 develop 类型分支上。 在 develop 类型分支上使用 gg-issues-open featureName 建立并转向一个名为 issues/issuesName 的新分支 在一个 issues 类型分支上使用 gg-issues-close 把这个分支的工作合并到 develop 类型分支上，然后删除此分支，解决了一个复杂的问题 issues 类型和 feature 类型的实现方式一模一样，仅仅有名字上面的差别。 Trials Branch 可以从除了 release 类型分支以外的任何类型分支上创建 在这个分支上请发挥想象力大胆实验 接受实验结果，把实验过程并入父分支，称为 good-close 实验结果不理想，放弃实验结果，从实验开始前重新来过，称为 bad-close 最终分支被删除 在满足条件的分支 A 上工作，时不时会冒出一些大胆的想法 这个时候使用 gg-trials-open trialsName 创建并转向一个名为 A/trials.trialsName 的实验分支，在这个分支上进行疯狂的实验 BasedOn Branch 从 name|master 建立并初始化为 name|basedOn 只能从对应的 master 分支 fork 到此分支 禁止在这个分支上提交 这个分支是一个为了使工作流程更为清晰的缓存分支， 分支上只有从 master 稳定分支上挑选出来的自己在工作中将要（尝试）使用的稳定版本。 在 basedOn 类型分支上使用 gg-select 版本号 从对应的 master 分支上选出一个稳定版本或使用 gg-select-the-latest 从对应的 master 分支上选择最新的版本， fork 到这个分支，并加上 inUse-versionNum 的标签 从 master 到此分支的行为是 fork， 即有可能此分支的 log 为 (init)v1.0===>v0.9=====>v0.8======>v1.3, 这个分支上的 commit 来源于 master，但是其分支提交历史与 master 分支无关 Work Branch 只能从 basedOn 类型分支上创建 可以借助 basedOn 分支升级 Git Inside Add Inside create blob objects: contains content of files add files to index list (.git/index) Commit Inside create tree objects: each object represent a directory, contains blob object refs in this directory create commit object: contains root tree object hash number and parent commit object hash number Checkout Inside git checkout get commit object by commit hash id get root tree object in commit object write file entries by root tree object (tree graph) write .git/index set HEAD to that commit (detached HEAD state) Merge Inside git merge / write giver commit hash to .git/MERGE_HEAD find base commit (the most recent common ancestor commit) diff and apply according to base commit, giver commit, receiver commit do what git checkout do remove .git/MERGE_HEAD Fetch Inside get hash of remote commit and its root tree object copy all diff objects in tree graph into .git/objects update .git/refs/remotes/origin/, set .git/FETCH_HEAD to it Clone Inside git init + git remote add origin + git pull origin Push Inside apply commit to remote repo update remote repo .git/refs/heads/ to new commit update local repo .git/refs/remotes/origin/ to new commit HEAD Branch Inside HEAD -> refs/heads/master -> commit object branches are just refs, refs are just files (contain commit hash id) Git Objects .git/objects is immutable, .git/refs is mutable blob持有文件的内容,树对象是一个包含blob对象和子树对象的目录列表. 提交对象是工作目录的一个快照, 包含了一些像时间或提交信息这样的元数据. 分支是提交对象的命名引用. 工作目录是一个目录, 有着相应的仓库, 暂存区(索引)为下一个提交对象持有对应的树对象, 而仓库就是一个提交对象的集合. git hash-object 创建blob对象 git cat-file -t git cat-file -p git update-index --add --cache-info 将文件添加至暂存区 git write-tree 创建tree对象 git commit-tree 创建commit对象 # -w for write into codebase, # --stdin for reading from stdin not file echo 'test content' | git hash-object -w --stdin git cat-file -p #!/bin/bash function seperator() { for i in {1..20} do printf \"-\" done printf $1 for i in {1..20} do printf \"-\" done printf \"\\n\" } function git_object_type() { printf \"type => \" git cat-file -t $1 for i in {1..40} do printf \"-\" done printf \"\\n\" } function git_object_content() { git cat-file -p $1 } function print_git_objects() { files=$(git rev-list --parents --objects HEAD | awk '{print $1}') index=0 for file in $files do len=$(expr length \"$file\") if [ $len -gt 30 ] then index=$(expr $index + 1) seperator $index echo $file git_object_type $file git_object_content $file fi done } print_git_objects GitHub LICENSE Popular LICENSE Unique LICENSE CC BY-NC-SA 3.0 License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \\*\\* ** May you do good and not evil. ** May you find forgiveness for yourself and forgive others. ** May you share freely, never taking more than you give. ** \\*\\* DBAD : DON'T BE A DICK PUBLIC LICENSE: Do whatever you like with the original work, just don't be a dick. Being a dick includes - but is not limited to - the following instances: 1a. Outright copyright infringement - Don't just copy this and change the name. 1b. Selling the unmodified original with no work done what-so-ever, that's REALLY being a dick. 1c. Modifying the original work to contain hidden harmful content. That would make you a PROPER dick. If you become rich through modifications, related worksrvices, or supporting the original work, share the love. Only a dick would make loads off this work and not buy the original works creator(s) a pint.Code is provided with no warranty. Using somebody else's code and bitching when it goes wrong makes you a DONKEY dick. Fix the problem yourself. A non-dick would submit the fix back. Homework Public License(HPL) Copyright (c) 2016 Yilong Liu This is for your reference only,not for your cheating - Just don't be a dick. Being a dick includes - but is not limited to - the following instances: 1a. Outright copyright infringement - Don't just copy this and change the name. 1b. Reserve a copy of this project and tell your teacher that it is your own homework - Plagiarism is shame. If you become rich through modifications, related worksrvices, or supporting the original work, share the love. Only a dick would make loads off this work and not buy the original works creator(s) a pint.Code is provided with no warranty. Using somebody else's code and bitching when it goes wrong makes you a DONKEY dick. Fix the problem yourself. A non-dick would submit the fix back. The Star And Thank Author License (SATA) Copyright (c) 2016 sabertazimi(sabertazimi@gmail.com) Project Url: https://github.com/sabertazimi/Awesome-Notes Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. And wait, the most important, you shall star/+1/like the project(s) in project url section above first, and then thank the author(s) in Copyright section. Here are some suggested ways: - Email the authors a thank-you letter, and make friends with him/her/them. - Report bugs or issues. - Tell friends what a wonderful project this is. - And, sure, you can just express thanks in your mind without telling the world. Contributors of this project by forking have the option to add his/her name and forked project url at copyright and project url sections, but shall not delete or modify anything else in these two sections. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Teamwork 如果在组织的托管空间创建版本库，一定要要为版本库指派一个拥有 Push 权限的团队，以免以“Fork + Pull”模式工作时，Pull Request 没有人响应。 Pull Request Work Flow Fork it. Create your feature branch (git checkout -b my-new-feature). Ensure tests are passing. Commit changes (git commit -am 'Add some feature'). Push to the branch (git push origin my-new-feature). Create new Pull Request. GitHub CLI Tool CLI Installation Install gh by apt, according of official introduction. gh auth login GH Issue Usage gh issue create gh issue close gh issue status gh issue list GH PR Usage gh pr checkout gh pr create gh pr close gh pr merge gh pr status gh pr list GH Repo Usage Clone repo: gh repo clone cli/cli # fastest way to clone authorized user repos gh alias set rc 'repo clone' gh rc dragon Create repo: # create a repository under your account using the current directory name $ git init my-project $ cd my-project $ gh repo create # create a repository with a specific name $ gh repo create my-project # create a repository in an organization $ gh repo create cli/my-project # disable issues and wiki $ gh repo create --enable-issues=false --enable-wiki=false Push repo: git init echo \"# RepoName\" >> README.md git add README.md git commit -m \"Initial commit\" git remote add origin git@github.com:username/RepoName.git git push -u origin master List repo: gh repo list sabertazimi Wiki Wiki Git Access git clone git@github.com:user/repo.wiki.git Shorten GitHub URL curl -i http://git.io -F \"url=https://github.com/technoweenie\" -F \"code=t\" Git Tools Diff and Patch diff -u diff -Nur patch -p[num] diff -Nur program_1.0 program_2.0 > program_2.0.patch patch -p1 Semantic Git Commit Message cz-cli cz-conventional-changelog commitlint Changelog Generator standard-version Purge Tool git rev-list --objects --all \\ | grep \"$(git verify-pack -v .git/objects/pack/*.idx \\ | sort -k 3 -n | tail -5 | awk '{print$1}')\" git filter-branch -f --prune-empty --index-filter \\ 'git rm -rf --cached --ignore-unmatch your-file-name' \\ --tag-name-filter cat -- --all Commands List Basic Commands git config git help git init git clone clone specific branch git clone -b branch_name repo_url git add git status git diff git difftool 外置 diff 工具 git commit git reset git reset $(git merge-base master $(git rev-parse --abbrev-ref HEAD)) git rev-parse --abbrev-rev HEAD will return the name of the branch currently on git merge-base master $(name of your branch) will find the best common ancestor between master and current branch git reset $(hash of the branch creation) will undo all the commits, merges, rebases (preserving changes to the code) git rm git mv git clean 从工作区中移除不想要的文件。可以是编译的临时文件或者合并冲突的文件。 git branch git checkout git merge git mergetool 外置 merge 工具 git log git stash 临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。 git tag git fetch git fetch git pull git pull --rebase git pull --allow-unrelated-histories git push git remote git archive 创建项目一个指定快照的归档文件 git submodule 管理一个仓库的其他外部仓库。 它可以被用在库或者其他类型的共 享资源上.submodule 命令有几个子命令, 如（ add 、 update 、 sync 等等）用来管理这些 资源. add submodule git submodule add git://github.com/chneukirchen/rack.git ./lib/rack cat .gitmodules get submodule git submodule init git submodule update sync submodule git pull origin/master --rebase git submodule update git submodule update --init --force --remote 检查与比较 git show git shortlog 创建一个漂亮的 changelog 文件 git describe 接受任何可以解析成一个提交的东西，然后生成一个人类可读的字符串且不可变。 这是一种获得一个提交的描述的方式，它跟一个提交的 SHA-1 值一样是无歧义，但是更具可读性。 调试 git bisect 通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。 git blame git grep 查找任何字符串或者正则表达式 补丁 git cherry-pick 获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上 git rebase git revert 邮件 git apply 应用一个通过 git diff 或者甚至使用 GNU diff 命令创建的补丁 git am 应用来自邮箱的补丁 git format-patch mbox 的格式来生成一系列的补丁以便你可以发送到一个邮件列表中 git imap-send 将一个由 git format-patch 生成的邮箱上传至 IMAP 草稿文件夹 git send-email 通过邮件发送那些使用 git format-patch 生成的补丁 git request-pull 外部系统 git svn git fast-import 对于其他版本控制系统或者从其他任何的格式导入，你可以使用 git fast-import 快速地将其他格式映射到 Git 可以轻松记录的格式 管理 git gc 在你的仓库中执行 ``garbage collection'' ，删除数据库中不需要的文件和将其他文件打包成一种更有效的格式 git fsck 检查内部数据库的问题或者不一致性 git reflog 分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交 git filter-branch 根据某些规则来重写大量的提交记录，例如从任何地方删除文件，或者通过过滤一个仓库中的一个单独的子目录以提取出一个项目 git-note 为特定 commit 添加 note,一个 commit 只能有一个 note © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/tools/vim/vimBasicNotes.html":{"url":"programming/tools/vim/vimBasicNotes.html","title":"Vim Basic Notes","keywords":"","body":"Vim Basic Notes Vim Basic Notes Normal 模式命令 重复命令 撤销命令 复合命令 插入 编辑命令 Operator + {motion} 精神 插入编辑命令 register 删除 复制 粘贴 选择 跳转 基本域 标记 拼写检查 查找 字符 /pattern ?pattern 原字符 Flags 替换 缩进 >{motion} ={motion} 注释 \\{motion} 历史记录 Insert 模式命令 模式转换 I 插入 特殊字符 I 删除 I 粘贴 可视模式 (Visual Mode) 底行模式 补全 自动补全 粘贴补全 补全历史记录 Range 撤销/重复 Shell Range 替换 Range 替换原字符 Range 替换 Flags 替换域中的特殊字符 global 文件与缓冲区 File Search 缓冲区 保存文件 窗口 标签 文件管理器 宏 Tools Vundle airline/CtrlP/colorschemes YouCompleteMe ctags make 内置补全 git Documentation Error Swap Backup File Error Encoding Normal 模式命令 重复命令 . 微型宏: 重复上一次(插入命令 至 )录制动作 ; 重复 t/T/f/F @ 命令 作用 @{register} 重复寄存器中的宏命令 @: 重复任意 Ex 命令 @@ 重复@命令 :& 重复:substitute 撤销命令 目的 操作 重复 回退 做出一个修改 {edit} . u 在行内查找下一指定字符 f{char}/t{char} ; , 在行内查找上一指定字符 F{char}/T{char} ; , 在文档中查找下一处匹配项 /pattern n N 在文档中查找上一处匹配项 ?pattern n N 执行替换 :s/target/replacement & u 执行一系列修改 qx{changes}q @x u 复合命令 插入 复合命令 等效的长命令 C c$ s cl S ^c I ^i A $a o A O ko 编辑命令 Operator + {motion} 精神 操作符命令 + 动作命令(范围) :h operator :h :map-operator 操作符命令: 基本编辑命令 命令 作用 c 修改 d 删除 y 复制到寄存器 g~ 反转大小写 gu 转换为小写 gU 转换为大写 > 增加缩进 减小缩进 = 自动缩进 ! 使用外部程序过滤{motion}所跨越的行 动作命令(a(all)/i(in)/t(til)) e.g $/2l/aw/ap 或 /patterns 模式串: /patterns 0/$: 行首/尾 文本对象: i/a 分隔符文本对象(seperator text objects) 分隔符文本对象 选择区域 a) 或 ab 一对圆括号(parentheses) i) 或 ib 圆括号(parentheses) 内部 a} 或 aB 一对花括号{braces} i} 或 iB 花括号{braces} 内部 a] 一对方括号[brackets] i] 方括号[brackets] 内部 a> 一对尖括号 i> 尖括号 内部 a' 一对单引号'single quotes' i' 单引号'single quotes' 内部 a\" 一对双引号\"double quotes\" i\" 双引号\"double quotes\" 内部 a` 一对反引号`backticks` i` 反引号`backticks` 内部 at 一对 XML 标签tags it XML 标签内部 范围文本对象(range text objects) 范围文本对象 选择范围 iw 当前单词 aw 当前单词及一个空格 iW 当前字串 aW 当前字串及一个空格 is 当前句子 as 当前句子及一个空格 ip 当前段落 ap 当前段落及一个空行 插入编辑命令 复合命令 等效的长命令 C c$ s cl S ^c I ^i A $a o A O ko register {register}{operator}{motion} / {register} 寄存器符号 作用 使用范例 \"\" 无名寄存器 e.g yiw / diw \"a ~ \"z 有名寄存器 e.g \"ayiw \"0 复制专用寄存器 e.g yiw + diw + \"0p \"_ 黑洞寄存器/有去无回寄存器 e.g \"_diw \"+ 系统剪贴板寄存器 e.g \"+p / InsertMode + \"* 上次高亮文本寄存器 e.g \"+p / InsertMode * \"= 表达式寄存器 e.g \"+p / InsertMode = \"% 当前文件名 \"# 轮换文件名 \". 上次插入的文本 \": 上次执行的 Ex 命令 \"/ 上次查找的模式 :reg {register} 显示寄存器内容 删除 {number}{register}d/s/x{motion} 复制 {number}{register}y{motion} 粘贴 {number}{register}p{motion} 选择 * 选中包含光标处字符的单词 跳转 基本域 命令 光标动作 % 跳转至下一个配对的范围符号 j 向下移动一个实际行 gj 向下移动一个屏幕行 k 向上移动一个实际行 gk 向上移动一个屏幕行 w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾 0 移动到实际行的行首 g0 移动到屏幕行的行首 $ 移动到实际行的行尾 g$ 移动到屏幕行的行尾 ^ 移动到实际行的第一个非空白字符 g^ 移动到屏幕行的第一个非空白字符 _ first char of line g_ last char of line H jump to top of screen M jump to middle of screen L jump to bottom of screen zt current line to top of screen zz current line to middle of screen zb current line to bottom of screen / 翻半页 / 翻半页 gd jump to defination gi jump to last insert position # jump to previous same word * jump to next same word :set path? 查看'path'值 命令 作用 [count]G 跳转到指定的行号 /pattern/?pattern/n/N 跳转到下一个/上一个模式出现之处 % 跳转到匹配的括号所在之处 (/) 跳转到上一句/下一句的开头 {/} 跳转到上一段/下一段的开头 gf 跳转到光标下的文件名 gg 文首 G 文尾 gg jump to line % jump to percent of file 跳转到光标下关键字的定义之处 `{mark} 跳转到一个位置标记 标记 m{alpha} 标记当前光标处,标记名为 alpha 位置标记 跳转到 `{alpha} 自定义标记处 `` 当前文件中上次跳转动作之前的位置 `. 上次修改的地方 `^ 上次插入的地方 `[ 上次修改或复制的起始位置 `] 上次修改或复制的结束位置 ` 上次高亮选区的起始位置 `> 上次高亮选区的结束位置 拼写检查 命令 作用 ]s 跳到下一处拼写错误 [s 跳到上一处拼写错误 z= 为当前单词提供更正建议 zg 把当前单词添加到拼写文件中 zw 把当前单词从拼写文件中删除 zug 撤销针对当前单词的 zg 或 zw 命令 查找 字符 命令 光标动作 w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾 ; 重复/f/F/t/T , 撤销/f/F/t/T /: 查找数字,递增/减数字 /pattern ?pattern 原字符 原字符 作用 范例 \\c 忽略大小写 \\C 大小写敏感 \\v 开启 very magic 模式(可省略转义符) \\v 模式下的单词定界符 %( 与 ) 分组符 `/\\v%(And D)rew` \\V 开启原义模式(可省略转义符): \\w 匹配单词类字符(alpha,number,\"_\") \\W 匹配非单词字符 \\x 匹配十六进制数[0-9a-fA-F] \\_s 匹配空白符/换行符 \\zs 界定一个匹配的开始 \\ze 界定一个匹配的结束 Flags 置于 patterns 末尾 Flags 作用 /g 全局 /e 光标至匹配词末尾 /c 确认或拒绝每一处修改 /n 会抑制正常的替换行为,只报告本次 substitute 命令匹配的个数 /e 屏蔽错误提示 /& 重复上次 flags 替换 :h gU gU{motion} 小写转大写 e.gUaw r{char} 替换光标所在字符 gr{char} R/gR 进入替换模式 缩进 >{motion} e.g >G: 缩进全文 ={motion} gg=G 自动缩进全文 注释 \\{motion} vim-commentary 插件 \\\\ 注释行 \\ap 注释段落 历史记录 u: 回退命令 : 前进命令 Insert 模式命令 模式转换 - 进入临时 normal 模式 I 插入 特殊字符 :h digraphs-default :h digraph-table :digraphs 命令 作用 {123} 以十进制字符编码插入字符 u{1234} 以十六进制字符编码插入字符 {nondigit} 按原义插入非数字字符 {char1}{char2} 插入以二合字母{char1}{char2}表示的字符 I 删除 命令 作用 删除前一个字符(同退格键) 删除前一个单词 删至行首 I 粘贴 {register} 粘贴 {register} 智能粘贴 寄存器 作用 0 普通寄存器 = 算术寄存器: 在下方输入表达式后,自动粘贴运算结果 可视模式 (Visual Mode) 命令 作用 v 激活面向字符的可视模式 V 激活面向行的可视模式 激活面向列块的可视模式 gv 重选上次的高亮选区 shift-v select current line gq split selected line into multiple lines o 切换高亮选区的活动端 底行模式 :h ex-cmd-index 黑魔法列表: :normal 将 Ex 命令与 Normal 指令结合在一起的黑魔法 :args 文件列表 :argdo {Excommands} 对存于文件列表的所有文件执行 Ex 命令 :global 对 patterns 执行 EX 命令 命令 作用 :edit/:write 读写文件 :tabnew 创建新标签页 :split 分割窗口 :prev/:next 前/后标签页 :bprev/:bnext 前/后缓冲区列表 :copy 命令对快速复制一行非常好用 :[range]delete [x] 删除范围内的行[到寄存器 x 中] :[range]yank [x] 复制范围的行[到寄存器 x 中] :[line]put [x] 在行后粘贴寄存器 x 中的内容 :[range]copy/t/co{address} 行拷贝到{address} 行之下 :[range]move/m {address} 行移动到{address} 行之下 :[range]join 连接指定范围内的行 :[range]normal {commands} 每一行执行命令{commands} :[range]substitute/{pattern}/{string}/[flags] {pattern}替换为{string} :[range]global/{pattern}/[cmd] 对指定范围内匹配 :shell 打开内置 shell :!{commands} 执行外部命令 :args {arglist} 文件列表 :argdo {Excommands} 对文件列表中的文件执行命令 :grep :vimgrep :make cnoremap %% getcmdtype( ) == ':' ? expand('%:h').'/' : '%%' 补全 自动补全 粘贴补全 : 将光标所在单词粘贴至命令行 补全历史记录 q/ 或 q: 弹出历史记录窗口 Range {start},{end} number 表示行号,.表示当前行,$表示最后一行,%表示所有行 /start_pattern/,/end_pattern/ 符号 地址 1 文件的第一行 $ 文件的最后一行 0 虚拟行,位于文件第一行上方 . 光标所在行 'm 包含位置标记 m 的行 ' 高亮选区的起始行 '> 高亮选区的结束行 % 整个文件(:1,$ 的简写形式) e.g 1 第 1 行 % 所有行 2,$ 第 2 行 - 最后一行 //,// 标签 html 所有行 撤销/重复 @: 重复命令 撤销命令 Shell 命令 作用 :shell 启动一个 shell (输入 exit 返回 Vim) :!{cmd} 在 shell 中执行{cmd} :read !{cmd} 在 shell 中执行{cmd} ,并把其标准输出插入到光标下方 :[range]write !{cmd} 在 shell 中执行{cmd} ,以[range] 作为其标准输入 :[range]!{filter} 使用外部程序{filter} 过滤指定的[range] Range 替换 Abolish.vim:超级 substitute 命令 :[range]s[ubstitute]/{pattern}/{string}/[flags] Range 替换原字符 原字符 作用 \\c 忽略大小写 \\C 大小写敏感 \\v 开启 very magic 模式(可省略转义符) \\v 模式下的单词定界符 %( 与 ) 分组符 \\V 开启原义模式(可省略转义符) \\w 匹配单词类字符(alpha,number,\"_\") \\W 匹配非单词字符 \\x 匹配十六进制数[0-9a-fA-F] _s 匹配空白符/换行符 \\zs 界定一个匹配的开始 \\ze 界定一个匹配的结束 Range 替换 Flags 置于 patterns 末尾 Flags 作用 /g 全局 /e 光标至匹配词末尾 /c 确认或拒绝每一处修改 /n 会抑制正常的替换行为,只报告本次 substitute 命令匹配的个数 /e 屏蔽错误提示 /& 重复上次 flags /c 后选项 作用 y 替换此处匹配 n 忽略此处匹配 q 退出替换过程 l “last” —— 替换此处匹配后退出 a “all” —— 替换此处与之后所有的匹配 向上滚动屏幕 向下滚动屏幕 替换域中的特殊字符 符号 作用 |:---------------|:--------------------------------------------------| |\\r|插入一个换行符| |\\t|插入一个制表符| |\\|插入一个反斜杠| |\\1|插入第 1 个子匹配| |\\2|插入第 2 个子匹配(以此类推,最多到\\9)| |\\0|插入匹配模式的所有内容| |&|插入匹配模式的所有内容| |~|使用上一次调用:substitute 时的{string}| |\\={Vim script}|执行{Vim Script} 表达式;并将返回的结果作为替换{string}| global :[range] global[!] /{pattern}/[ExCommands] :g/{start}/ .,{finish} [cmd] ':g/re/d' 删除所有的匹配行 ':v/re/d' 只保留匹配行 追加存储 TODO 项至 a 寄存器 :g/TODO/yank A > :reg a 文件与缓冲区 File Search built-in fuzzy file search :find or :tabnew set nocompatible set number syntax on filetype plugin indent on \" :find filepath \" :tabnew filepath \" :tabp :tabn \" :b partOfFilepath \" :ls set path+=** set wildmenu set wildmode=list:longest,full :ls to list opened file, :b to jump to specific file 缓冲区 命令 作用 :b{bufferNumber/bufferName} 跳转至指定缓冲区 :bd{bufferNumber/bufferName} 删除指定缓冲区 保存文件 命令 作用 :w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区(即回滚所做修改) :qa[ll]! 关闭所有窗口,摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 窗口 创建窗口 命令 作用 s 水平切分当前窗口,新窗口仍显示当前缓冲区 v 垂直切分当前窗口,新窗口仍显示当前缓冲区 :sp[lit] {file} 水平切分当前窗口,并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口,并在新窗口中载入{file} 切换窗口 命令 作用 w/ 在窗口间循环切换 h 切换到左边的窗口 j 切换到下边的窗口 k 切换到上边的窗口 l 切换到右边的窗口 自定义窗口 :h window-moving 命令 作用 = 使所有窗口等宽、等高 _ 最大化活动窗口的高度 \\ 最大化活动窗口的宽度 [N]_ 把活动窗口的高度设为[N]行 [N]\\ 把活动窗口的宽度设为[N]列 :windo lcd {path} 设置当前标签页的所有窗口的工作目录 关闭窗口 Ex 命令 Normal 命令 作用 :clo[se] c 关闭活动窗口 :on[ly] o 只保留活动窗口,关闭其他所有窗口 标签 新建/关闭标签页 命令 作用 :tabe[dit] {filename} 在新标签页中打开{filename} T 把当前窗口移到一个新标签页 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页,关闭所有其他标签页 切换标签页 Ex 命令 Normal 命令 作用 :tabn[ext] {N} {N}gt 切换到编号为{N} 的标签页 :tabn[ext] gt 切换到下一标签页 :tabp[revious] gT 切换到上一标签页 -重排标签页 :tabmove [N] - N 为 0 时,当前标签页移至首;N 省略时,至尾 文件管理器 Ex 命令 作用 :edit ./:e. 打开文件管理器,并显示当前工作目录 :Explore/:E 打开文件管理器,并显示活动缓冲区所在的目录 宏 命令 作用 q{register} 开始录制宏,并将其保存到指定寄存器,再次按 q 结束录制 {number}@{register} 命令执行指定寄存器的内容 @@ 重复@命令 register 为小写时,覆盖录制宏;register 为大写时,追加录制宏 Tools Vundle git clone https://github.com/VundleVim/Vundle.vim ~/.vim/bundle/Vundle.vim :PluginInstall airline/CtrlP/colorschemes built-in fuzzy file search :find need config :AirlineTheme {theme} :colorscheme {theme} set nocompatible set number syntax on filetype plugin indent on set shiftwidth=4 set softtabstop=4 set spell spelllang=en_us scriptencoding utf-8 set mouse=a set mousehide set ignorecase set smartcase \" :find filepath \" :tabnew filepath \" :tabp :tabn \" :b partOfFilepath \" :ls set path+=** set wildmenu set wildmode=list:longest,full \" NERDtree like setup for netrw let g:netrw_banner = 0 let g:netrw_liststyle = 3 let g:netrw_browse_split = 4 let g:netrw_altv = 1 let g:netrw_winsize = 25 \" let g:netrw_list_hide=netrw_gitignore#Hide() \" let g:netrw_list_hide.=',\\(^\\|\\s\\s\\)\\zs\\.\\S\\+' augroup ProjectDrawer autocmd! autocmd VimEnter * :Vexplore augroup END \" ctags setup command! MakeTags !ctags -R . \" colorschemes config colorscheme Monokai \" airline config \" set laststatus=2 let g:airline#extensions#tabline#enabled = 1 let g:airline#extensions#tabline#left_sep = ' ' let g:airline#extensions#tabline#left_alt_sep = '|' \" CtrlP config let g:ctrlp_map = '' let g:ctrlp_cmd = 'CtrlP' let g:ctrlp_working_path_mode = 'ra' let g:ctrlp_user_command = 'find %s -type f' YouCompleteMe need compile and config sudo apt-get install build-essential cmake python-dev python3-dev cd ~/.vim/bundle/YouCompleteMe ./install.py --clang-completer let g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py' ctags \" ^] jump \" g^] for ambiguous tags \" ^t jump back command! MakeTags !ctags -R . 命令 作用 跳转到匹配当前光标所在关键字的第一处标签 g 跳转至匹配当前光标所在的关键字 :tag {keyword} 跳转到匹配{keyword}的第一处标签 :tjump {keyword} 提示用户从匹配{keyword}的多处标签中指定一处进行跳转 :pop 或 反向遍历标签历史 :tag 正向遍历标签历史 :tnext 跳转到下一处匹配的标签 :tprev 跳转到上一处匹配的标签 :tfirst 跳转到第一处匹配的标签 :tlast 跳转到最后一处匹配的标签 :tselect 提示用户从标签匹配列表中选择一项进行跳转 make QuickFix 命令 作用 :cnext 跳转到下一项 :cprev 跳转到上一项 :cfirst 跳转到第一项 :clast 跳转到最后一项 :cnfile 跳转到下一个文件中的第一项 :cpfile 跳转到上一个文件中的最后一项 :cc N 跳转到第 n 项 :copen 打开 quickfix 窗口 :cclose 关闭 quickfix 窗口 内置补全 In insert mode 命令 补全类型 普通关键字 当前缓冲区关键字 包含文件关键字 tag 关键字 字典查找 整行补全 文件名补全 全能（Omni）补全 可供弹出式菜单使用的命令 按键操作 作用 使用来自补全列表的下一个匹配项(next 匹配项) 使用来自补全列表的上一个匹配项(previous 匹配项) 选择来自补全列表的下一个匹配项 选择来自补全列表的上一个匹配项 确认使用当前选中的匹配项(yes) 还原最早输入的文本(从自动补全中 exit) (与) 从当前匹配项中删除一个字符 从当前匹配项中增加一个字符 {char} 中止自动补全并插入字符{char} git Gblame + key o Glog + [q/]q/[Q/]Q Gdiff Gcommit/Gstatus Gpull/Gpush Documentation :help: :help ^n: docs in normal mode :help i_^n: docs in insert mode :help c_^n: docs in commandline mode :helpgrep command: search docs includes command Error Swap Backup File can't open swap or backup file: create :set directory? directory chown of directory to ${whoami} Error Encoding set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set fileformats=unix,dos,mac set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 set termencoding=utf-8 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/angular/angularBasicNotes.html":{"url":"programming/web/angular/angularBasicNotes.html","title":"Angular Basic Notes","keywords":"","body":"Angular Basic Notes Angular Basic Notes Basic CLI Module Component Props Event Attributes Reference Pipe Pure Pipe Impure Pipe Async Pipe Service Injection Provider RxJS Basis RxJS Pipe Helper Operator Creation Operator Transformation Operator Filter Operator Combination Operator Multicast Operator Error Handling Operator Utils Operator Router Form Event Binding Directives Structural Directives ngFor ngIf Attribute Directives ngClass Styles CSS Class Binding Basic Installation Basic Tutorial CLI CLI Commands npm install -g @angular/cli ng new my-app ng add ng serve --open ng lint ng test ng e2e production build: suffix / is required ng build --prod true --outputPath ./build --baseHref https://sabertazimi.github.io/hust-web/angular/learn/ ng generate --help Module Angular 需要知道如何把应用程序的各个部分组合到一起, 以及该应用需要哪些其它文件和库, 这些信息被称为元数据（metadata. 有些元数据位于@Component装饰器中, 你会把它加到组件类上. 另一些关键性的元数据位于@NgModule装饰器中. NgModule 为其中的组件提供了一个编译上下文环境. 根模块总会有一个根组件, 并在引导期间创建它. 任何模块都能包含任意数量的其它组件, 这些组件可以通过路由器加载, 也可以通过模板创建. 那些属于这个 NgModule 的组件会共享同一个编译上下文环境. Component Props import { Input } from '@angular/core'; ... { @Input() hero: Hero; } private props import { HeroService } from '../hero.service'; constructor(private heroService: HeroService) { } Event parent import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-root', template: `` }) export class AppComponent implements OnInit { ngOnInit() {} displayCounter(count) { console.log(count); } } child import { Component, Input, EventEmitter, Output } from '@angular/core'; @Component({ selector: 'app-child', template: `Click me` }) export class AppChildComponent { @Output() valueChange: EventEmitter = new EventEmitter(); counter = 0; handleClick() { this.counter += 1; this.valueChange.emit(this.counter); } } Attributes Angular 只会绑定到组件的公共属性 import { MessageService } from '../message.service'; ... { constructor(public messageService: MessageService) {} } Messages Clear {{message}} Reference # refer to DOM Hero name: add Pipe Pure Pipe Angular 只有在它检测到输入值发生了纯变更时才会执行纯管道. 纯变更是指对原始类型值 (String、Number、Boolean、Symbol) 的更改, 或者对对象引用 (Date、Array、Function、Object) 的更改. Higher performance. Impure Pipe Angular 会在每个组件的变更检测周期中执行非纯管道. 非纯管道可能会被调用很多次, 和每个按键或每次鼠标移动一样频繁. Async Pipe {{hero.name}} Service Injection Provider @Injectable({ providedIn: 'root', }) RxJS RxJS 管理所有输入的 input -> consumer/redux action 的调度过程 条件变更之后的自动重新计算 (Reactive) 同步与异步的统一 获取和订阅的统一 现在与未来的统一 可组合的数据变更过程 数据与视图的精确绑定 UI 变化很复杂时，用 component 归一化处理 state 变化很复杂时，用 action/state 归一化处理 data-input 很复杂时，用 RxJS/observable 归一化处理 reactive.how Basis 可观察对象可以发送多个任意类型的值 —— 字面量、消息、事件. 无论这些值是同步发送的还是异步发送的, 接收这些值的 API 都是一样的. 由于准备（setup）和清场（teardown）的逻辑都是由可观察对象自己处理的, 因此应用代码只管订阅并消费这些值就可以了, 做完之后, 取消订阅. 无论这个流是击键流、HTTP 响应流还是定时器, 对这些值进行监听和停止监听的接口都是一样的. Observer（观察者）是 Observable（可观察对象）推送数据的消费者. 在 RxJS 中, Observer 是一个由回调函数组成的对象, 键名分别为 next, error, complete, 以此接受 Observable 推送的不同类型的通知 (data input). Subscription 是一个代表可以终止资源的对象, 表示一个 Observable 的执行过程. Subscription 有一个重要的方法: unsubscribe. 这个方法不需要传入参数, 调用后便会终止相应的资源. Observable 当有数据产生时才会推送给订阅者, 所以它可能会无限次向订阅者推送数据. 因此在 Angular 里面创建组件的时候务必要取消订阅操作, 以避免内存泄漏. Subject 既是可观察对象的数据源, 本身也是 Observable. 可以像订阅任何 Observable 一样订阅 Subject. 还可以通过调用它的 next(value) 方法往 Observable 中推送一些值. // Create simple observable that emits three values const myObservable = of(1, 2, 3); // Create observer object const myObserver = { next: x => console.log('Observer got a next value: ' + x), error: err => console.error('Observer got an error: ' + err), complete: () => console.log('Observer got a complete notification') }; // Execute with the observer object const subscription = myObservable.subscribe(myObserver); // Logs: // Observer got a next value: 1 // Observer got a next value: 2 // Observer got a next value: 3 // Observer got a complete notification ... { search(term: string): void { this.searchTerms.next(term); } ngOnInit(): void { this.heroes$ = this.searchTerms.pipe( // wait 300ms after each keystroke before considering the term debounceTime(300), // ignore new term if same as previous term distinctUntilChanged(), // switch to new search observable each time the term changes // return another Observable switchMap((term: string) => this.heroService.searchHeroes(term)), ); } } RxJS Pipe Helper RxJS 提供了 pipe 辅助函数, 它存在于 Observable 上, 它缓解了操作符不在原型上所带来的问题. import { take, map } from 'rxjs/operators'; import { of } from 'rxjs/observable/of'; map.call(take.call(of(1, 2, 3), 2), val => val + 2); // to import { take, map } from 'rxjs/operators'; import { of } from 'rxjs/observable/of'; of(1, 2, 3).pipe( take(2), map(val => val + 2) ); Operator Creation Operator 单值: of, empty, never 多值: from 定时: interval, timer 从事件创建: fromEvent/fromEventPattern 从 Promise 创建: fromPromise 自定义创建: create Transformation Operator map mapTo mergeMap/flatMap pluck reduce scan groupBy switch swtichMap: 在每次发出时, 会取消前一个内部 Observable (所提供函数的 retun value) 的订阅, 然后订阅一个新的 observable. 即当有新的输入时便不再关心之前请求的响应结果. 借助switchMap操作符, 每个有效的击键事件都会触发一次HttpClient.get()方法调用. 即使在每个请求之间都有至少 300ms 的间隔, 仍然可能会同时存在多个尚未返回的 HTTP 请求. switchMap()会记住原始的请求顺序, 只会返回最近一次 HTTP 方法调用的结果, 以前的那些请求都会被取消和舍弃. Filter Operator audit auditTime filter skip first last take takeWhile takeUntil throttle throttleTime debounce debounceTime distinctUntilChanged: 只有当当前值与之前最后一个值 !== 时才将其发出 bufferTime subscribeOn ObserveOn Combination Operator concat: 保持原来的序列顺序连接两个数据流 merge: 合并序列 race: 预设条件为其中一个数据流完成 forkJoin: 预设条件为所有数据流都完成 zip: 取各来源数据流最后一个值合并为对象 combineLatest: 取各来源数据流最后一个值合并为数组 Multicast Operator multicast publish share Error Handling Operator throw catch/catchError retry retryWhen finally Utils Operator do/tap delay delayWhen timeout toPromise Router 会告诉路由器要在哪里显示路由的视图. import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { HeroesComponent } from './heroes/heroes.component'; const routes: Routes = [ { path: 'heroes', component: HeroesComponent } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} Form [(ngModel)] (ngSubmit) Event Binding () template syntax for event binding Directives Structural Directives ngFor {{hero.name}} ngIf Selected Attribute Directives ngClass same to [ngStyle] This div is initially saveable, unchanged, and special currentClasses: {}; setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { 'saveable': this.canSave, 'modified': !this.isUnchanged, 'special': this.isSpecial }; } Styles CSS Class Binding The class binding is special This one is not so special © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/css/bootstrapBasicNotes.html":{"url":"programming/web/css/bootstrapBasicNotes.html","title":"Bootstrap Basic Notes","keywords":"","body":"Bootstrap Notes Bootstrap Notes Grid System Basic row Nav NavBar Class Structure BreadCrumb ScrollSpy Tabs and Pills Tab Pane Tab Pane JS API Tab Pane JS Events Collapse Accordion Text Form Form Basic CheckBox and Select Form Alerts and Prompts Table Table Basic Class Card Panel Well Images Img Class Thumbnail Media Embed Alerts and Prompts Labels Badges Alerts Progress Bars Tooltip Popover Modal Button Jumbotron Icon-Fonts Carousel(Slide Show) Common Class color size state aniatmion Boostrap 4 Bootstrap Card Custom Bootstrap Theme Webpack Setup Bootstrap Reboot Tips Useful Custom Functions Custom Global Options Custom Colors Custom Spacing Custom Layout Custom Borders Custom Navbar and Navigation Custom Dropdown Custom Listgroup Custom Card Custom Breadcrumb Custom Form Grid System Basic 设置宽度: col-xs/sm/md/lg-num 设置偏移量: col-xs/sm/md/lg-pull/push/offset-num row row row-header/row-content/row-footer Nav NavBar Class navbar navbar-default navbar-inverse(color) navbar-fixed-top navbar-form nav-tabs nav-pills navbar-left/right Structure navbar > container > nav/navbar-header/navbar-nav/navbar-form > li/a Toggle navigation Brand Link (current) Link Dropdown Action Another action Something else here Separated link One more separated link Submit Link Dropdown Action Another action Something else here Separated link body { padding: 50px 0px 0px 0px; z-index: 0; } .navbar-inverse { background: #303f9f; } .navbar-inverse .navbar-nav > .active > a, .navbar-inverse .navbar-nav > .active > a:hover, .navbar-inverse .navbar-nav > .active > a:focus { color: #fff; background: #1a237e; } .navbar-inverse .navbar-nav > .open > a, .navbar-inverse .navbar-nav > .open > a:hover, .navbar-inverse .navbar-nav > .open > a:focus { color: #fff; background: #1a237e; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a, .navbar-inverse .navbar-nav .open .dropdown-menu { background-color: #303f9f; color: #eeeeee; } .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover { color: #000000; } BreadCrumb 路径导航栏 - Home -> Library -> Data Home Library Data ScrollSpy body { position: relative; } .affix { top: 100px; } Our History Corporate Facts ... ... ... Tabs and Pills nav-tabs/nav-pills nav-justified/nav-stacked link - active/disabled Home Messages Dropdown ... Tab Pane Home Profile Messages Settings ... ... ... ... Tab Pane JS API $('#myTabs a').click(function(e) { e.preventDefault(); $(this).tab('show'); }); $('#myTabs a[href=\"#profile\"]').tab('show'); // Select tab by name $('#myTabs a:first').tab('show'); // Select first tab $('#myTabs a:last').tab('show'); // Select last tab $('#myTabs li:eq(2) a').tab('show'); // Select third tab (0-indexed) Tab Pane JS Events hide.bs.tab (on the current active tab) show.bs.tab (on the to-be-shown tab) hidden.bs.tab (on the previous active tab, the same one as for the hide.bs.tab event) shown.bs.tab (on the newly-active just-shown tab, the same one as for the show.bs.tab event) $('a[data-toggle=\"tab\"]').on('shown.bs.tab', function(e) { e.target; // newly activated tab e.relatedTarget; // previous active tab }); Collapse href/data-target -> id Link with href Button with data-target ... Accordion panel-body/list-group Collapsible Group Item #1 Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. Collapsible Group Item #2 Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. Collapsible Group Item #3 Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. Text text-center/left/right text-primary/info/success/danger Form required pattern=”[0-9a-zA-z]{5/13-16}” min=”(number)” max=”(number)” step=”(步长:指定输入数字必须倍数关系)” /> Form Basic First Name Last Name Contact Tel. ( ) Email May we contact you? Tel. Email Your Feedback Send Feedback Email address Password File input Example block-level help text here. Check me out Submit Action Action Another action Something else here Separated link CheckBox and Select May we contact you? Tel. Email Form Alerts and Prompts has-color has-feedback form-control-feedback(icon) control-label/form-control/help-block Input with success (success) Input with warning (warning) Input with error (error) Input group with success @ (success) Table Table Basic Class table-striped table-bordered table-hover table-condensed table-responsive &nbsp; 2013 2014 2015 Employees 15 30 40 Guests Served 15000 45000 100,000 Special Events 3 20 45 Annual Turnover $251,325 $1,250,375 ~$3,000,000 Card Panel Facts At a Glance Started 3 Feb. 2013 Major Stake Holder HK Fine Foods Inc. Last Year's Turnover $1,250,375 Employees 40 Well well/well-xs/well-sm paragraph Yogi Berra,The Wit and Wisdom of Yogi Berra, 2014 Images Img Class img-responsive img-rounded img-circle img-thumbnail Thumbnail Thumbnail label ... Button Button Media media media-list(ul) media-object media-body media-heading media-left/right media-top/middle/bottom Media heading ... Embed embed-responsive embed-responsive-item targets: , , , Alerts and Prompts Labels target: span label label-color label-size Default Primary Success Info Warning Danger Badges Messages 4 Alerts alert alert-color alert-dismissible alert-link &times; Warning! Better check yourself, you're not looking too good. ... Progress Bars progress-bar width/aria-valuemin/aria-valuemax progress-bar-color progress-bar-striped stacked: put multi-progress-bar into same .progress 40% Complete (success) 20% Complete 60% Complete (warning) 80% Complete (danger) Tooltip data-toggle=\"tooltip\" data-placement=\"left\" title=\"Tooltip on left\" // manually initialization $(function() { $('[data-toggle=\"tooltip\"]').tooltip(); }); Tooltip on left Tooltip on top Tooltip on bottom Tooltip on right Popover data-container=\"body\" data-toggle=\"popover\" data-trigger=\"focus\" data-placement=\"left\" title=\"left\" data-content=\"Vivamus sagittis lacus vel augue laoreet rutrum faucibus.\" // manually initialization $(function() { $('[data-toggle=\"popover\"]').popover(); }); Popover on left Popover on top Popover on bottom Popover on right Modal data-dismiss =\"modal\" 修饰.modal-dialog、.modal-content $().modal(''); Launch demo modal &times; Modal title ... Close Save changes Open modal for @mdo Open modal for @fat Open modal for @getbootstrap &times; New message Recipient: Message: Close Send message Button targets: a/input/button base: btn color: btn-primary btn-success btn-warning btn-danger btn-info size: btn-xs/sm/lg display: btn-block/btn-main group: btn-toolbar/btn-group/btn-group-vertical/btn-group-lg 左 中 右 上 中 下 other: btn-social-icon Jumbotron We are Broadway Get started Icon-Fonts Carousel(Slide Show) ... ... ... Previous Next .carousel(options) Initializes the carousel with an optional options object and starts cycling through items. Copy $('.carousel').carousel({ interval: 2000 }) .carousel('cycle') Cycles through the carousel items from left to right. .carousel('pause') Stops the carousel from cycling through items. .carousel(number) Cycles the carousel to a particular frame (0 based, similar to an array). .carousel('prev') Cycles to the previous item. .carousel('next') Cycles to the next item. Common Class color default/primary/info/warnings/danger size xs/sm/md/lg state active disabled aniatmion collapse fade in Boostrap 4 Bootstrap Card .well: .card.bg-light .panel: .card .thumbnail: .card + .card-img/.card-img-top Custom Bootstrap Theme Webpack Setup { \"scripts\": { \"start\": \"npm run dev\", \"dev\": \"cross-env NODE_ENV=development \\ webpack-dev-server --port 2333 --mode development --open\", \"build\": \"cross-env NODE_ENV=production webpack --mode production\", \"lint\": \"stylelint ./src/**/*.scss ./src/**/*.css && \\ eslint --ext .js --ext .jsx ./src\" }, \"devDependencies\": { \"@babel/cli\": \"^7.2.3\", \"@babel/core\": \"^7.3.3\", \"@babel/plugin-proposal-class-properties\": \"^7.3.3\", \"@babel/plugin-proposal-object-rest-spread\": \"^7.3.2\", \"@babel/preset-env\": \"^7.3.1\", \"autoprefixer\": \"^8.6.2\", \"babel-eslint\": \"^10.0.1\", \"babel-loader\": \"^8.0.5\", \"clean-webpack-plugin\": \"^0.1.19\", \"cross-env\": \"^5.2.0\", \"css-loader\": \"^0.28.11\", \"eslint\": \"^4.19.1\", \"eslint-config-airbnb\": \"^17.0.0\", \"eslint-loader\": \"^2.1.0\", \"eslint-plugin-import\": \"^2.13.0\", \"eslint-plugin-jsx-a11y\": \"^6.1.1\", \"eslint-plugin-react\": \"^7.10.0\", \"html-loader\": \"^0.5.5\", \"html-webpack-plugin\": \"^3.2.0\", \"mini-css-extract-plugin\": \"^0.4.0\", \"node-sass\": \"^4.11.0\", \"postcss-loader\": \"^2.1.5\", \"precss\": \"^4.0.0\", \"sass-loader\": \"^7.0.3\", \"style-loader\": \"^0.21.0\", \"stylelint\": \"^9.10.1\", \"stylelint-config-mass\": \"^1.0.2\", \"stylelint-webpack-plugin\": \"^0.10.5\", \"webpack\": \"^4.12.0\", \"webpack-cli\": \"^3.0.6\", \"webpack-dev-server\": \"^3.2.0\" }, \"dependencies\": { \"bootstrap\": \"^4.3.1\", \"jquery\": \"^3.3.1\", \"popper.js\": \"^1.14.7\" } } const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const StyleLintPlugin = require('stylelint-webpack-plugin'); const packageJson = require('./package.json'); const devMode = process.env.NODE_ENV !== 'production'; const useSass = !!packageJson.devDependencies['node-sass']; const styleLoader = [ devMode ? 'style-loader' : MiniCssExtractPlugin.loader, { loader: 'css-loader', options: { minimize: !devMode } }, 'postcss-loader' ]; if (useSass) { styleLoader.push('sass-loader'); } module.exports = { entry: { main: './src/index.js' }, output: { filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'build') }, module: { rules: [ { test: /\\.(js|jsx)$/, exclude: /node_modules/, use: ['babel-loader', 'eslint-loader'] }, { test: /\\.html$/, use: [ { loader: 'html-loader', options: { minimize: !devMode } } ] }, { test: /\\.(css|scss)$/, use: [...styleLoader] } ] }, plugins: [ new CleanWebpackPlugin('build'), new HtmlWebpackPlugin({ hash: true, template: './src/index.html', filename: './index.html' }), new MiniCssExtractPlugin({ filename: devMode ? '[name].css' : '[name].[hash].css', chunkFilename: devMode ? '[id].css' : '[id].[hash].css' }), new StyleLintPlugin() ], resolve: { extensions: ['.js', '.jsx'] }, devtool: 'source-map' }; Advanced Webpack Configuration Bootstrap Reboot Tips @import '~bootstrap/scss/reboot; Some useful best practices: body font-size: 1rem for scalable component spacing. avoid margin-top as vertical margins collapse (only use margin-bottom for headings h1/.../h6, lists ul/ol/dl/dd, ) block use rems for margin for easier scaling across device sizes using inherit whenever possible for font- property box-sizing: border-box is globally set on every element including *::before and *::after body sets a global font-family, line-height and text-align body sets background-color: #fff for safety legend/fieldset have no borders/padding/margin label are set to display: inline-block to allow margin textarea are modified to only be resizable vertically resize: vertical as horizontal resizing often “breaks” page layout summary are set to cursor: pointer Useful Custom Functions @import '~bootstrap/scss/functions'; @import '~bootstrap/scss/mixins'; @function color($key: 'blue') { @return map-get($colors, $key); } @function theme-color($key: 'primary') { @return map-get($theme-colors, $key); } @function gray($key: '100') { @return map-get($grays, $key); } @function theme-color-level($color-name: 'primary', $level: 0) { $color: theme-color($color-name); $color-base: if($level > 0, #000, #fff); $level: abs($level); @return mix($color-base, $color, $level * $theme-color-interval); } /* color contrast: color-yiq(color) */ .custom-element { background-color: color-yiq(#000); color: color-yiq(theme-color('dark')); } Custom Global Options $enable-caret: true !default; $enable-rounded: true !default; $enable-shadows: false !default; $enable-gradients: false !default; $enable-transitions: true !default; $enable-prefers-reduced-motion-media-query: true !default; $enable-grid-classes: true !default; $enable-pointer-cursor-for-buttons: true !default; $enable-print-styles: true !default; $enable-responsive-font-sizes: false !default; $enable-validation-icons: true !default; $enable-deprecation-messages: true !default; Custom Colors @import '~bootstrap/scss/variables'; $theme-colors: ( 'primary': #0074d9, 'danger': #ff4136 'secondary': #495057, 'success': #37b24d, 'info': #1c7ed6, 'warning': #f59f00, 'danger': #f03e3e ); $colors: ( 'blue': $blue, 'indigo': $indigo, 'purple': $purple, 'pink': $pink, 'red': $red, 'orange': $orange, 'yellow': $yellow, 'green': $green, 'teal': $teal, 'cyan': $cyan, 'white': $white, 'gray': $gray-600, 'gray-dark': $gray-800 ) !default; Custom Spacing key variable - $spacer: t - for classes that set margin-top or padding-top b - for classes that set margin-bottom or padding-bottom l - for classes that set margin-left or padding-left r - for classes that set margin-right or padding-right x - for classes that set both xxx-left and xxx-right y - for classes that set both xxx-top and xxx-bottom blank - for classes that set a margin or padding on all 4 sides of the element 0 - for classes that eliminate the margin or padding by setting it to 0 1 - (by default) for classes that set the margin or padding to $spacer * .25 2 - (by default) for classes that set the margin or padding to $spacer * .5 3 - (by default) for classes that set the margin or padding to $spacer 4 - (by default) for classes that set the margin or padding to $spacer * 1.5 5 - (by default) for classes that set the margin or padding to $spacer * 3 auto - for classes that set the margin to auto .mt-0 { margin-top: 0 !important; } .ml-1 { margin-left: ($spacer * 0.25) !important; } .px-2 { padding-right: ($spacer * 0.5) !important; padding-left: ($spacer * 0.5) !important; } .p-3 { padding: $spacer !important; } .mt-n1 { margin-top: -0.25rem !important; } Custom Layout $grid-columns: 12 !default; $grid-gutter-width: 30px !default; Custom Borders $border-width: 1px !default; $border-color: $gray-300 !default; $border-radius: 0.25rem !default; $border-radius-lg: 0.3rem !default; $border-radius-sm: 0.2rem !default; Custom Navbar and Navigation /* $nav-link-padding-x: 1.5rem; */ $navbar-nav-link-padding-x: 1.5rem; $nav-link-padding-y: 1rem; $navbar-light-color: $violet-4; $navbar-light-hover-color: $violet-6; $navbar-light-active-color: $violet-9; $navbar-light-toggler-border-color: $violet-2; $navbar-dark-color: $violet-3; $navbar-dark-hover-color: $violet-5; $navbar-dark-active-color: $violet-1; $navbar-dark-toggler-border-color: $violet-1; $nav-tabs-border-color: $primary; $nav-tabs-link-hover-border-color: $violet-5; $nav-tabs-link-active-color: $violet-9; $nav-tabs-link-active-bg: $violet-3; $nav-tabs-link-active-border-color: $violet-1; $nav-pills-link-active-color: $white; $nav-pills-link-active-bg: $primary; Custom Dropdown custom $dropdown- variables $dropdown-padding-y: 1rem; $dropdown-spacer: 0.5rem; $dropdown-bg: $white; $dropdown-border-color: $primary; $dropdown-border-width: $border-width * 3; $dropdown-link-color: $primary; $dropdown-item-padding-y: 0.5rem; $dropdown-item-padding-x: 3rem; Custom Listgroup $list-group-border-color: $primary; Custom Card $card-border-color: $primary; $card-color: $primary; $card-bg: $violet-0; Custom Breadcrumb $breadcrumb-bg: $violet-0; $breadcrumb-divider-color: $gray-600 !default; $breadcrumb-active-color: $violet-3; $breadcrumb-divider: quote('>'); Custom Form $input-btn-padding-y: 0.75rem; $input-btn-padding-x: 1.5rem; $input-btn-focus-width: 0; /* remove focus box-shadow */ $custom-control-indicator-checked-color: $primary; © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/css/cssAdvancedNotes.html":{"url":"programming/web/css/cssAdvancedNotes.html","title":"Css Advanced Notes","keywords":"","body":"CSS Advanced Notes CSS Advanced Notes Typography Principles font-size and spacing font-size spacing vertical rhythms Table Grid System Form Design Principles Buttons Placement Principles Graceful Degration CSS Houdini CSS Performance Basic Perf Tips CSS Selectors CSS Triggers reset.css will-change contain window.requestAnimationFrame CSS Loading Tips Animation Best Practice DevTools for Animation Animation Internal CSS Hacks Design Principles 费茨定律 米勒定律 席克定律 泰斯勒定律 content -> centering -> font family -> spacing -> color&contrast -> balance(position) -> primary/secondary color -> custom font -> images/links Typography Principles The typeface (font-family) Type (modular) scale Responsiveness of the text (size unit and breakpoints) Spacing and vertical rhythm Colors (theming) refer to: font-family, font-size, spacing, color reference Praticel Typography font-size and spacing set a base-size multiples of base-size use rem for most font-size, use em for some spacing (needing responsive design) $xs: $base / $ratio / $ratio; $sm: $base / $ratio; $md: $base; $lg: $base * $ratio; $xl: $base * $ratio * ratio; font-size rem is better em for responsive layout (etc. layer2 font based-on layer1 font in dropdown menu) make text legible: at least 16px spacing make text breathe: margin/padding: at least 15px line-height: 1.4 word-spacing letter-spacing 60-100 characters per line vertical rhythms keep vertical spaces between elements on a page consistent (and relative) to each other: Set the vertical white space between elements to a multiple of base-size Set the line-height of all text elements to a multiple of base-size Table remove fills, gridlines, border and bolding left-align text, right-align numbers and align headings with data put white space to work to group and separate Grid System Must have different traits at different sizes Must be fluid between breakpoints Must have enough control to decide which columns will transform and at which point Classes should ideally still make sense at all breakpoints Form Design Principles Buttons Placement Principles Align the primary button to the left edge of the inputs Put the back button above the form Put tangentially related actions above the form Place extra buttons based on what they do In some single field forms put the button next to the input (e.g search button) Put buttons on multi select forms above the form https://adamsilver.io/articles/where-to-put-buttons-in-forms Graceful Degration write old browser css code, then write modern browser css code .grid { display: flex; } /* old browser dosen't support this rule */ /* old browser will ignore this rule */ .grid { display: grid; } CSS Houdini Draft Implementaion Status CSS Houdini bring many API: css properties and values api: custom properties (--var, var(--var)), custom function (--darken(--var)) css layout api (layoutWorklet): layout below (display: flex/grid), layout above (css-sizing: min-content/max-content/fit-content) css paint api (paintWorklet): background, background-color, background-image css composite api (compositeWorklet) to let developers enhance css without any browser updates CSS Performance Basic Perf Tips use audits panel to diagnose use CSS shorthand and color shortcuts eliminate unneeded zeros and units remove unused CSS by coverage panel of Devtools link is parallel, @import isn't parallel CSS Selectors 减少选择器的复杂性，与构造样式本身的其他工作相比， 选择器复杂性可以占用计算元素样式所需时间的 50%以上 CSS Triggers CSS Triggers JS DOM API Triggers avoid to frequently change css property or call JS DOM API triggering layout stage (reflow) reset.css * selector has poor performance will-change 告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作 { will-change: auto; will-change: scroll-position; will-change: contents; will-change: transform; /* Example of */ will-change: opacity; /* Example of */ will-change: left, top; /* Example of two */ will-change: unset; will-change: initial; will-change: inherit; } contain CSS Containment contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。 这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面 /* 无布局包含*/ contain: none; /* 布局包含 layout、style、paint 和 size*/ contain: strict; /* 布局包含layout、style 和 paint */ contain: content; /* 布局包含 size */ contain: size; /* 布局包含 layout */ contain: layout; /* 布局包含 style */ contain: style; /* 布局包含 paint */ contain: paint; size: 声明这个元素的尺寸会变化，不需要去检查它依赖关系中的尺寸变化 style: 声明那些同时会影响这个元素和其子孙元素的属性，都在这个元素的包含范围内 layout: 声明没有外部元素可以影响它内部的布局，反之亦然 paint: 声明这个元素的子孙节点不会在它边缘外显示。如果一个元素在视窗外或因其他原因导致不可见，则同样保证它的子孙节点不会被显示 window.requestAnimationFrame reflow: javascript -> style -> layout -> paint -> composite repaint: paint -> composite 告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用 若想要在下次重绘时产生另一个动画画面，callback 必须调用 requestAnimationFrame const start = null; const element = document.getElementById('SomeElementYouWantToAnimate'); element.style.position = 'absolute'; function step(timestamp) { if (!start) { start = timestamp; } const progress = timestamp - start; element.style.left = Math.min(progress / 10, 200) + 'px'; if (progress CSS Loading Tips Lazyload any CSS not needed for Start Render: This could be Critical CSS; or splitting your CSS into Media Queries. Avoid @import: In your HTML; but in CSS especially; and beware of oddities with the Preload Scanner. Be wary of synchronous CSS and JavaScript order: JavaScript defined after CSS won’t run until CSSOM is completed; so if your JavaScript doesn’t depend on your CSS; load it before your CSS; but if it does depend on your CSS: load it after your CSS. Load CSS as the DOM needs it: This unblocks Start Render and allows progressive rendering. Animation Best Practice High Performance Tips all animation: keyframe animation or transitions is best js-based animation: requestAnimationFrame is better than setTimeout/setInterval position animation:transform: translate(npx, npx) is better than top/right/bottom/left scale animation: transform: scale(n) better than width/height rotation animation: transform: rotate(ndeg) is better opacity/visibility animation: opacity: 0...1 is better DevTools for Animation DevTools for Animation Performance slower CPU simulation in performance panel enable paint instrumentation in performance panel FPS meter in rendering panel paint flashing in rendering panel layers panel Animation Internal width/height/margin/left/top in Layout stage box-shadow/border-radius/background/outline/color in Paint stage cursor/z-index/transform/opacity in Composite Layers stage top/left has very large time to paint each frame CSS Hacks Browser Hacks /* stylelint-disable */ /***** Selector Hacks ******/ /* IE6 and below */ * html #uno { color: red; } /* IE7 */ *:first-child + html #dos { color: red; } /* IE7, FF, Saf, Opera */ html > body #tres { color: red; } /* IE8, FF, Saf, Opera (Everything but IE 6,7) */ html>/**/body #cuatro { color: red; } /* Opera 9.27 and below, safari 2 */ html:first-child #cinco { color: red; } /* Safari 2-3 */ html[xmlns*=''] body:last-child #seis { color: red; } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:nth-of-type(1) #siete { color: red; } /* safari 3+, chrome 1+, opera9+, ff 3.5+ */ body:first-of-type #ocho { color: red; } /* saf3+, chrome1+ */ @media screen and (-webkit-min-device-pixel-ratio: 0) { #diez { color: red; } } /* iPhone / mobile webkit */ @media screen and (max-device-width: 480px) { #veintiseis { color: red; } } /* Safari 2 - 3.1 */ html[xmlns*='']:root #trece { color: red; } /* Safari 2 - 3.1, Opera 9.25 */ *|html[xmlns*=''] #catorce { color: red; } /* Everything but IE6-8 */ :root * > #quince { color: red; } /* IE7 */ * + html #dieciocho { color: red; } /* Firefox only. 1+ */ #veinticuatro, x:-moz-any-link { color: red; } /* Firefox 3.0+ */ #veinticinco, x:-moz-any-link, x:default { color: red; } /***** Attribute Hacks ******/ /* IE6 */ #once { _color: blue; } /* IE6, IE7 */ #doce { *color: blue; /* or #color: blue */ } /* Everything but IE6 */ #diecisiete { color/**/: blue; } /* IE6, IE7, IE8 */ #diecinueve { color: blue\\9; } /* IE7, IE8 */ #veinte { color/*\\**/: blue\\9; } /* IE6, IE7 -- acts as an !important */ #veintesiete { color: blue !ie; } /* string after ! can be anything */ /* stylelint-enable */ Design Principles 费茨定律 人机交互和人体工程学中人类活动的模型, 它预测了从任意位置快速移动到一个目标位置所需的时间, 由 2 个位置的距离（D）和目标大小（S）有关, 正比于 D, 反比于 S: 关联性强的 UI 放置在一起 大拇指点击热区 屏幕边界视为无限大 (容易到达) 关机滑动距离长 米勒定律 人的短时记忆能力广度为 7±2 个信息块: 手机号/银行卡号/超大数字分段放置, 信息分层 e.g 134 9999 9999, 999, 999, 999 文章布局时增大段落间 margin, 改变部分文字的粗细/字体/颜色 导航/选项卡不超过 9 个 (超过 9 个可使用 dropdown/submenu) 席克定律 用户所面临的选择数量越多, 做出选择所花费的时间就越长, 在人机交互的界面中选项越多, 意味着用户做出决策的时间越长: 减少选项并提供默认值 分类分层 分步分页 (大部分手机应用注册界面) 泰斯勒定律 泰斯勒定律又称复杂性守恒定律, 该定律认为每一个过程都有其固有的复杂性, 这个复杂性存在一个临界点, 超过了这个点就不能再简化了, 你只能将固有的复杂性从一个地方移动到另外一个地方: 智能手机: 按键的复杂度转为手机操作系统的复杂度 智能推荐: 用户自己选择筛选条件的复杂度转为人工智能算法的复杂度 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/css/cssBasicNotes.html":{"url":"programming/web/css/cssBasicNotes.html","title":"Css Basic Notes","keywords":"","body":"CSS 3 Basic Notes CSS 3 Basic Notes Cascading and Inheritance Cascading Order Specificity Property Value Initial Value Specified Value Computed Value Used Value Actual Value Best Practice Normalize gap rem vs em 属性排序 概述 显示属性 自身属性 文本属性 详细 显示属性 Detail 自身属性 Detail 文本属性 Detail 命名规范 页面结构 导航 功能 CSS Files CSS Selector 元素选择器 关系选择器 Descendant Selectors Sibling Selectors 属性选择器 伪类 伪元素 Descendant Selector HTML Body Property Box Style width z-index overflow/overflow-x/overflow-y text-overflow resize box-sizing height column Box Model Margin Percentage of Width/Top Block Formatting Context Stack Context Create BFC Margin Collapsing/Merging Float Patterns fixed parent 清除浮动 Float Best Practice Position Patterns static relative absolute fixed Flex Patterns Under the Hood of flex Useful Shorthand of flex 父元素属性 子元素属性 Flexibility of Float Pseudo Elements of Flex Box Fixed Sidebar with Flexbox Flexbox Best Practice Grid Patterns Grid Attention Tips Grid Alignment Column Patterns Two Column Pattern Three Column Pattern Absolute and Margin Column Float and Margin Column Float and Negative Margin Column Centering Patterns Horizontal Centering Pattern Vertical Centering Pattern Mixing Centering Pattern List Style Alignment Text Align Vertical Align Opacity Border Border Radius Border Image CSS Colors HSL Color CSS Background Background Image Background Size Background Repeat Background Attachment Background Clip Background Origin Blend Mode Mask Style Clip Path Background Best Practice Scroll Indicator Jumbotron and Landing Page Horizontal Scrolling Best Practices CSS Text white-space CSS Font font-size font-style font-variant font-size-adjust font-diplay custom function - @font-face Font Best Practice CSS Couter CSS Filter Backdrop Filter Object Position/Fit Animation Animation Property Transition and Transform Animation and Transform Animation Helper Transition Basic Usage Transition Internal Transition Direction Class Controls on Transition Transform Perspective Transform Style backface-visibility Animation Details Animation Play State FLIP GreenSock Library TweenMax TimelineMax Responsive Desgin Responsive Font Responsive Length Responsive Box Responsive Width and Height responsive inline-box responsive image media query JavaScript Media Query API 设备类型 设备特性 Style for Print PDF Accessibility Screnn Reader Only 常用组件 (Awesome Demo) Landing Page Modal Flexiable Heading Table Form Select Navigation 基本原则 Hidden Link Awesome Navigation Style Button Footer Sticky Footer Picture 圆形图片 Animation Tips Animated Dots Fade with Class Accordion Menu Animation Slides Animation Resizable Component Slides Layout 相同单元 元素定位 Geometry Stretch Line Dash Line Circle Triangle Polygon CSS Variables Variables DOM API Scope Variebls Invalid and Empty Value in CSS Variables SVG Inline SVG SVG Basic Shape Tags SVG Text Tag SVG Accessibility Tags SVG Group Tag SVG Defs Tag Cascading and Inheritance Cascading Order user agent normal user normal author normal CSS Animations author !important user !important user agent !important Specificity Specificity (Selector Priority) has 4 bits - thousands, hundreds, tens, ones 0000: thousands: inline-style hundreds: ID selector tens: class selector, attribute selector, pseudo-class(:) ones: element selector, pseudo-element(::) Universal selector (*), combinators (+, >, ~, ' ') negation pseudo-class (:not) have no effect on specificity, but selectors in it have effect on specificity h1 { specificity: 0001; } #id { specificity: 0100; } h1 + p::first-letter { specificity: 0003; } li > a[href*='en-US'] > .inline-warning { specificity: 0022; } /* Hello */ inline-style { specificity: 1000; } /* specificity: 0101 */ #outer a { background-color: red; } /* specificity: 0201 */ /* win */ #outer #inner a { background-color: blue; } /* specificity: 0104 */ #outer div ul li a { color: yellow; } /* specificity: 0113 */ /* win */ #outer div ul .nav a { color: white; } /* specificity: 0024 */ div div li:nth-child(2) a:hover { border: 10px solid black; } /* specificity: 0023 */ div li:nth-child(2) a:hover { border: 10px dashed black; } /* specificity: 0033 */ /* win */ div div .nav:nth-child(2) a:hover { border: 10px double black; } Styles for a directly targeted element will always take precedence over inherited styles, regardless of the specificity of the inherited rule #parent { color: green; } /* element will be purple */ h1 { color: purple; } Property Value Initial Value The initial value of a CSS property is its default value, as listed in its definition table Specified Value The specified value of a CSS property is the value it receives from the document's style sheet Computed Value The computed value of a CSS property is the value that is transferred from parent to child during inheritance. It is calculated from the specified value by: Handling the special values inherit, initial, unset, and revert Doing the computation needed to reach the value described in the \"Computed value\" line in the property's definition table Used Value The used value of a CSS property is its value after all calculations have been performed on the computed value: The used values of dimensions (e.g., width, line-height) are in pixels The used values of shorthand properties (e.g., background) are consistent with those of their component properties (e.g., background-color or background-size) and with position and float Actual Value The actual value of a CSS property is the used value of that property after any necessary approximations have been applied The user agent performs four steps to calculate a property's actual (final) value: the specified value is determined based on the result of cascading, inheritance, or using the initial value. the computed value is calculated according to the specification (for example, a span with position: absolute will have its computed display changed to block) layout is calculated, resulting in the used value the used value is transformed according to the limitations of the local environment, resulting in the actual value initial -> specified -> computed -> used -> actual value span { position: absolute; } /* display computed to `block` */ Best Practice Normalize html { box-sizing: border-box; margin: 0; padding: 0; font-size: 100%; } *, *::before, *::after { box-sizing: inherit; margin: inherit; padding: inherit; } body { line-height: 1.5; } gap * + * { margin-top: 1.5em; } rem vs em Size in em if the property scales according to it’s font-size .container { margin-top: 1.2em; } Size in em if the font-size should be modular (relative to it's context/parent): Modular Font Size .container { font-size: 1.2rem; } .container p { font-size: 1em; } .container small { font-size: 0.9em; } Size everything else in rem (include media queries) 属性排序 概述 显示属性 -> 自身属性 -> 文本属性 显示属性 position display float clear 自身属性 width height margin padding border list-style background 文本属性 color font text-decoration text-align vertical-align white-space other text content 详细 显示属性 Detail position z-index top right bottom left box-sizing display visibility float clear 自身属性 Detail width min-width max-width height min-height max-height overflow margin margin-top margin-right margin-bottom margin-left padding padding-top padding-right padding-bottom padding-left border border-width border-top-width border-right-width border-bottom-width border-left-width border-style border-top-style border-right-style border-bottom-style border-left-style border-color border-top-color border-right-color border-bottom-color border-left-color outline list-style table-layout caption-side border-collapse border-spacing empty-cells background background-color background-image background-repeat background-position 文本属性 Detail color font font-family font-size font-weight line-height text-align text-indent text-transform text-decoration letter-spacing word-spacing white-space vertical-align opacity cursor content quotes 命名规范 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标籤页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright CSS Files abstracts: $variables, @mixin function vendors: external libraries (font-awesome, bootstrap) base: normalize.css, reset.css, utils.css, font.css, base.css (margin-right, text-center, float-right) components: form.css, button.css, navbar.css, dropdown.css layout: columns.css, grid.css, header.css, footer.css, section.css, navigation.css pages: home.css, about.css themes: color.css, font.css main.css CSS Selector 元素选择器 p { margin-bottom: 1em; line-height: 1.5em; } 关系选择器 Descendant Selectors E F：所有后代选择器 E > F：直接子选择器 ul li { margin-bottom: 0.5em; } ul > li { list-style: none; } /* 仅限ul的直接子元素li，忽略嵌套子元素 */ Sibling Selectors E + F：直接相邻兄弟选择器 E ~ F：一般兄弟选择器 li + li { border-top: 1px solid #ddd; } /* p before h1 */ p { color: #fff; } /* 定位具有相同父元素的，h1标签之后的所有p标签 */ h1 ~ p { color: #f00; } checkbox input as hidden click event listener input.checkbox { opacity: 0; visibility: hidden; } nav { transform: scale(0); } input.checkbox:checked + nav { transform: scale(1); } input.checkbox:checked ~ nav { transform: scale(1); } 属性选择器 E[attr] input[required] { border: 1px solid #f00; } //定位页面里所有具有必填属性\"required\"的input E[attr=val] input[type='password'] { border: 1px solid #aaa; } //定位页面里的密码输入框 E[attr|=val] p[class|='a'] { color: #333; } //定位页面里所有的P段落里具有class属性且属性值为a或是a-开始的，比如class=\"a\"以及class=\"a-b\" E[attr~=val] // 定位页面里所有具有属性title且属性值里拥有完整单词english的div容器 // 比如title=\"english\"以及title=\"a english\" div[title~='english'] { color: #f88; } E[attr^=val] div[class^='a'] { color: #666; } //定位页面里具有属性class且属性值以a开头的div容器，比如class=\"a\"以及class=\"ab\" E[attr$=val] div[class$='a'] { color: #f00; } //定位页面里具有属性class且属性值以a结尾的div窗口，比如class=\"nba\"以及class=\"cba\" E[attr*=val] a[title*='link'] { text-decoration: underline; } //定位所有title里具有link字符串的a链接 伪类 :link：未访问的链接； :visited：已访问的链接，不建议使用； :hover：鼠标移动到容器，不仅限于链接，可用于页面中的任何元素； link - visited - hover order matters :active: 被激活时的状态，不仅限于链接，可用于任何具有 tabindex 属性的元素； :focus: 获得焦点时状态，不仅限于链接，可用于任何具有 tabindex 属性的元素： :enabled: 已启用的界面元素：input :disabled: 已禁用的界面元素：input :target: 该选择器定位当前活动页面内定位点的目标元素, #anchor-name #info:target {font-size:24px;} :default: 应用于一个或多个作为一组类似元素中的默认元素的 UI 元素； :valid: 应用于输入验证有效元素，基于 input 的 type/pattern 属性 :invalid: 应用于输入验证无效元素， :in-range: 应用于具有范围限制的元素，其中该值位于限制内；比如具有 min 和 max 属性的 number 和 range 输入框； :out-of-range: 与:in-range 选择相反，其中该值在限制范围外； :required: 应用于具有必填属性 required 的表单控件； :optional: 应用于没有必填属性 required 的所有表单控件 :read-only: 应用于其内容无法供用户修改的元素； :read-write: 应用于其内容可供用户修改的元素，比如输入框； :root: 根元素，始终指 html 元素； :placeholder-shown: select input with placeholder :focus-visible: selected when Tab (shortcut) focused :focus-within: selected when any children focused :empty：没有子元素的元素，没有子元素包括文本节点； :not(exception)：该选择器将选择与括号内的选择器不匹配的元素： :lang(en)：具有使用双字母缩写(en)表示的语言的元素； :has(): a target element has child elements, :has normal priority :where(): a target element has child elements, :where 0 priority E F:first-of-type 相同类型 的第一个元素 E F:last-of-type 相同类型 的最后一个元素 E F:only-of-type 孩子中只有一种该元素 E :nth-child(n) 选择 E 的第 n 个孩子 E F:nth-child(n)：该选择器定位元素 E 的第 n 个子元素的元素 F,可省略 E E F:nth-last-child(n)：该选择器定位元素 E 的倒数第 n 个子元素的元素 F,可省略 E E F:nth-of-type(n)：该选择器定位元素 E 的第 n 个 相同类型 子元素,可省略 E E F:nth-lash-of-type(n)：该选择器定位元素 E 的导数第 n 个 相同类型 子元素,可省略 E E F:first-child 第一个孩子 E F:last-child 最后一个孩子 E F:only-child 单一后代 p1 p1 div:target { background-color: purple; } #p1:target { background-color: purple; } .msg { opacity: 0; transition: opacity 0.2s ease-in-out; } input:not(:placeholder-shown) + .msg { opacity: 1; } /* Mouse Focus Style */ button:focus:not(:focus-visible) { outline: 2px dotted #416dea; outline-offset: 2px; box-shadow: 0px 1px 1px #416dea; } /* Tab Focus Style */ button:focus-visible { outline: 2px solid #416dea; outline-offset: 2px; box-shadow: 0px 1px 1px #416dea; } 伪元素 ::first-line：匹配文本首行； ::first-letter：匹配文本首字母； ::selection：匹配突出显示的文本： //定义选中的文本颜色与背景色 ::selection { background: #444; color: #fff; } ::before 与 ::after ：使用 contnet 属性生成额外的内容并插入在标记中： a:after { content: '↗'; } attr() – 调用当前元素的属性 a:after { content: '(' attr(href) ')'; } a:after { content: '(' attr(data-language) ')'; } url() / uri() – 用于引用媒体文件 h1::before { content: url(logo.png); } counter() – 调用计数器，可以不使用列表元素实现序号功能,配合 CSS3 中counter-increment和counter-reset属性 h2:before { counter-increment: chapter; content: 'Chapter ' counter(chapter); } div { counter-reset: tidbit-counter 58; } h2::before { counter-increment: tidbit-counter 1; content: counter(tidbit-counter, list-style-type) ': '; } HTML CSS JS nested counters ol { counter-reset: section; /* 为每个ol元素创建新的计数器实例 */ list-style-type: none; } li:before { counter-increment: section; /* 只增加计数器的当前实例 */ content: counters(section, '.') ' '; /* 为所有计数器实例增加以“.”分隔的值 */ } item item item item item item item item item item item item item item item 利用伪类画额外图形 .first-details-intro::after { width: 0; height: 0; content: ''; position: absolute; top: 50%; right: 0; border-top: 15px solid transparent; border-right: 25px solid #fff; border-bottom: 15px solid transparent; } Descendant Selector using the descendant selector without more specificity can be really expensive. The browser is going to check every descendant element for a match because the relationship isn’t restricted to parent and child. For .container ul li a selector: match every on the page find every contained in a use the previous matches and narrow down to the ones contained in a finally, filter down the above selection to the ones contained in an element with the class .container HTML Body Property auto inherit initial 指定为默认值，用于消除样式 none Box Style width auto with css-sizing: present for fill-available/max-content/min-content/fit-content with height/width/min-width/max-width/min-height/max-height/ grid-template-rows/grid-template-columns/flex-basis. z-index 数值越大，处于可视的优先级越大 overflow/overflow-x/overflow-y visible,hidden,scroll,auto text-overflow clip 切除溢出部分 ellipsis 省略号标志 .truncation-article-container { width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .article-container { display: -webkit-box; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 4; /* 需要显示的行数 */ overflow: hidden; text-overflow: ellipsis; } resize 前置属性:overflow /*允许用户修改元素尺寸*/ resize: none/both/horizontal/vertical/inherit; box-sizing content-box(default), padding-box, border-box height XXvh(viewport height) 直接计算宽度/高度 cal(50% - 100px); cal(10em + 3px); column /*子元素分列*/ .three-column { padding: 1em; -moz-column-count: 3; -moz-column-gap: 1em; -webkit-column-count: 3; -webkit-column-gap: 1em; column-count: 3; column-gap: 1em; } column-count column-width column-gap 分隔距离 column-rule(style) 分隔线 Box Model block-level box: display 属性为 block, list-item, table 的元素, 会生成 block-level box，并且参与 block formatting context inline-level box: display 属性为 inline, inline-block, inline-table 的元素， 会生成 inline-level box，并且参与 inline formatting context Flex Formatting Context(FFC) Grid Formatting Context(GFC) Margin If both margin-left and margin-right are auto, their used values are equal. (CSS2 Visual formatting model details: 10.3.3) If margin-top, or margin-bottom are auto, their used value is 0. (CSS2 Visual formatting model details: 10.6.3) Percentage of Width/Top positioned elements with top: percentage depend on height of parent, if height of parent is auto, it's not working. Block Formatting Context 一个 BFC 包含创建该上下文元素的所有子元素，但不包括创建了新 BFC 的子元素的内部元素 BFC 就是页面上的一个隔离的独立容器, 容器里面的子元素不会影响到外面的元素, 反之也如此 一个元素不能同时存在于两个 BFC 中: 可让处于 BFC 内部的元素与外部的元素相互隔离 内部的 Box 会在垂直方向，一个接一个地放置 vertical margin collapsing 每个元素的 margin box 的左边, 与包含块 border box 的左边相接触 BFC 的区域不会与 float box 重叠: 自适应分栏布局, 清除外/内部浮动 计算 BFC 的高度时, 浮动元素也参与计算: 防止内边距塌陷 (margin-top collapse with margin-bottom) Stack Context The root element forms the root stacking context. Other stacking contexts are generated by any position/opacity/transform element (including relatively positioned elements) having a computed value of z-index other than auto. Once apply a position property to a box, can use the z-index property to adjust its stack level. Create BFC 根元素或其它包含它的元素 overflow: not visible (i.e hidden) float: left/right position: absolute/fixed display: inline-block display: table-cell/table-caption/table-*h display: flow-root direct children of display: flex/inline-flex direct children of display: grid/inline-grid Margin Collapsing/Merging closet sibling: 1's margin-bottom with 2's margin-top parent and it's first/last child: up with up (bottom with bottom) empty block: margin-top with margin-bottom Best Practice: only use margin-bottom: 1em/1rem for spacing. Float Patterns float make element specified value of display: inline-table computed to table inline/inline-block/table-* computed to block fixed parent Floating wont work inside fixed or absolute divs unless specify widthh .parent { position: fixed; left: 0px; top: 5px; width: 100%; } 清除浮动 Best Practice: 为父容器添加 clearfix class display: table 防止外边距塌陷, clear: both 清楚浮动 .clearfix:before, .clearfix:after { content: ''; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } Float Best Practice 段中部分元素浮动(结合 margin/padding), 可实现内嵌效果 分栏布局 Position Patterns position static top/left/width/right/z-index are invalid relative 使元素相对于 static 布局, 可使用top/bottom/left/right属性进行平移 absolute 使元素相对于 浏览器窗口/父元素(positoin: non-static) 布局 (包括 % 形式的 width/height) 若 body 为 static, 则元素不会随着滚动条滚动, 其相对于初始窗口布局 可使用top/bottom/left/right属性进行定位 float: none display: inline-table computed to table display: inline/inline-block/table-* computed to block .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: -50; } .fullscreen-video { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; background-size: cover; overflow: hidden; z-index: -100; } .fullscreen-video video { min-width: 100%; min-height: 100%; } fixed 使元素想对于 浏览器窗口 布局, 但不受滑动条影响 可使用top/bottom/left/right属性进行定位 float: none display: inline-table computed to table display: inline/inline-block/table-* computed to block /* 使子元素可以相对于父元素布局*/ .parent { position: relative; } .children { position: absolute; top: auto; left: 0; } Flex Patterns Complete Guid to Flexbox Under the Hood of flex 当 flex-basis 设置为 auto 且 width（或者 height）不为 auto 时，计算 used size 时会用到 width（或者 height）的值 when there is some free space left: true width = flex-basis (or width) + flex-grow/sum of flex-grow when there is not enough space: true width = flex-basis (or width) - flex-shrink/sum of flex-shrink text nodes and pseudo-elements can be flex children Useful Shorthand of flex flex: flex-grow flex-shrink flex-basis flex:auto: 元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收 flex 容器中额外的自由空间， 也会缩短至自身最小尺寸以适应容器 equal toflex: 1 1 auto flex:initial: 属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器， 但不会伸长并吸收 flex 容器中的额外自由空间来适应容器 equal to flex: 0 1 auto flex:none: 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器 equal to flex: 0 0 auto flex: 元素会被赋予一个容器中自由空间的指定占比 equal to flex: 1 0 父元素属性 display: flex; flex-direction: row/column; flex-wrap: nowrap/wrap/wrap-reverse; justify-content: flex-start/flex-end/center/space-between/space-around; align-content: flex-start/flex-end/center/space-between/space-around; align-items: flex-start/flex-end/center/baseline/stretch; 子元素属性 flex: number; /*宽/高度权重*/ order: number; /*显示顺序*/ flex-basis: number; flex-shrink: number; flex-grow: number; align-self: auto/flex-start/flex-end/center/baseline/stretch; Flexibility of Float .parent { display: flex; } .child { /* this will push child to the right of parent border */ margin-left: auto; } Pseudo Elements of Flex Box set flex to pseudo elements of flex box will change width of pseudo elements. .flex { display: flex; } .flex::before { position: relative; /* no need for absolute position */ display: block; } Fixed Sidebar with Flexbox body { height: 100vh; margin: 0; display: flex; } aside { flex: 0 0 auto; /* inflexible */ } main { flex: 1 1 auto; /* auto flexible */ overflow: auto; } Flexbox Best Practice .container { display: -webkit-flex; display: flex; } .initial { /*width: 100px~200px*/ -webkit-flex: initial; flex: initial; width: 200px; min-width: 100px; } .none { /*width: 200px*/ -webkit-flex: none; flex: none; width: 200px; } .flex1 { /*width: left width * 1/3*/ -webkit-flex: 1; flex: 1; } .flex2 { /*width: left width * 2/3*/ -webkit-flex: 2; flex: 2; } /*子元素全部居中对齐*/ .vertical-container { height: 300px; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; } .layer { display: flex; margin: 5px; flex-direction: row; justify-content: flex-start; align-items: center; border: 1px solid #000; background-color: #fff; flex-grow: 1; } Grid Patterns Complete Grid Guide .container { grid-template-columns: 1fr 1fr 1fr; grid-template-columns: repeat(3, 1fr); /* * grid-template-columns: * repeat([auto-fit / auto-fill / numbers], minmax(60px, 1fr)); */ grid-template-rows: 1fr 1fr 1fr; grid-template-rows: minmax(90px, 1fr); grid-template-areas: 'header header header' 'advert content content' 'footer footer footer'; grid-gap: 10px; justify-items: center; align-items: end; } .item { grid-row: start / end; /* 2 / -1 */ grid-column: start / end; grid-area: footer; /* grid-area: hstart / vstart / hend / vend */ justify-self: center; align-self: end; } responsive grid layout .items { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); } named rows and columns .main { display: grid; grid-column-gap: 2rem; grid-row-gap: 1rem; grid-template-rows: [header] 100px [body] auto; grid-template-columns: [l-gutter] 1fr[sidebar] 4fr [content] 8fr [r-gutter] 1fr; } .header { grid-row: header; grid-column: sidebar / right-gutter; } .sidebar { grid-row: body; grid-column: sidebar; } .content { grid-row: body; grid-column: content; } Grid Attention Tips grid-column will refactor template of grid (grid-template-columns) grid-row will refactor template of grid (grid-template-rows) Grid Alignment justify-content/align-content content within element, attach to parent css selector (effectively adjusts padding of parent) justify-items/align-items inline items inside box, attach to parent css selector (controls margin of children ) justify-self/align-self inline element within parent, attach to chilren css selector (effectively adjusts margin of children) Column Patterns float 左右元素 + margin 中间元素 float 元素 + width: % Two Column Pattern 利用父元素 relative 与 子元素 absolute 进行布局 inline-block + inline-block float + float float + margin-left (block element ignore float element, inline element surround float element) absolute + margin-left (absolute element not in normal flow) float + BFC .div-1 { position: relative; } .div-1a { position: absolute; top: 0; right: 0; width: 200px; } .div-1b { position: absolute; top: 0; left: 0; width: 200px; } Three Column Pattern Absolute and Margin Column position .left and .right with absolute, add margin-left and margin-right to .middle Float and Margin Column .left .right .middle .left { float: left; } .right { float: right; } .middle { margin: 0 right-width 0 left-width; } Float and Negative Margin Column On a floated element, a negative margin opposite the float direction will decrease the float area, causing adjacent elements to overlap the floated element. A negative margin in the direction of the float will pull the floated element in that direction. HTML: .middle first padding-left and padding-right to .container, min-width: 2 * (leftWidth + rightWidth) to container Float: float: left to .left/.middle/.right Negative Margin: margin-left: -100% to .left, margin-right: -rightWidth px to .right Move: right: leftWidth px to .left .container { padding: 0 200px 0 300px; /* padding-left = .left width, same to .right */ } .container .middle { float: left; width: 100%; background-color: blueviolet; } .container .left { float: left; position: relative; right: 300px; width: 300px; margin-left: -100%; background-color: darkblue; } .container .right { float: left; position: relative; width: 200px; margin-right: -200px; background-color: darkred; } Centering Patterns CSS Tricks - Centering CSS Complete Guide Horizontal Centering Pattern inline: text-align, flex/grid box block: auto margin, flex/grid box 父元素 float, 父子元素 relative .container { float: left; position: relative; left: 50%; } .container ul { position: relative; left: -50%; } Vertical Centering Pattern inline*: padding, line-height, vertical-align, flex/grid box block: top+margin, top+tranlateY, vertical-align, flex/grid box Mixing Centering Pattern 在子容器中在设置新元素即可 List Style list-style-type: 改变 ul/ol 前标记类型 list-style-image: 改变 ul/ol 前标记类型 Alignment Text Align justify(自适应，左右都无空格) Vertical Align 垂直对齐方式 .form__item__label { display: flex; flex-direction: row; align-items: center; } Opacity 0 ~ 1, 渐进效果常用属性 Border mix transparent with non-transparent border to make shapes (e.g. triangle). .arrow-up { width: 0; height: 0; border-right: 16px solid transparent; border-left: 16px solid transparent; border-bottom: 20px solid #8888e8; } .arrow-right { width: 0; height: 0; border-top: 16px solid transparent; border-bottom: 16px solid transparent; border-left: 20px solid #e888a3; } .arrow-down { width: 0; height: 0; border-right: 16px solid transparent; border-left: 16px solid transparent; border-top: 20px solid #f7df6c; } .arrow-left { width: 0; height: 0; border-top: 16px solid transparent; border-bottom: 16px solid transparent; border-right: 20px solid #8de698; } Border Radius Border Image border-image: source slice width outset repeat; CSS Colors HSL Color H: hue S: saturation (stay 50% etc.) L: lightness (easy to theme colors) /* Hover Button */ :root { --primary-h: 221; --primary-s: 72%; --primary-l: 62%; } .button { background-color: hsl(var(--primary-h), var(--primary-s), var(--primary-l)); } .button:hover { --primary-l: 54%; } /* Custom Buttons */ :root { --primary-h: 221; --primary-s: 72%; --primary-l: 62%; } .button { background-color: hsl(var(--primary-h), var(--primary-s), var(--primary-l)); } .button--secondary { --primary-l: 90%; color: #222; } .button--ghost { --primary-l: 90%; background-color: transparent; border: 3px solid hsl(var(--primary-h), var(--primary-s), var(--primary-l)); } /* Change lightness to get gradient */ .section { background: linear-gradient( to left, hsl(var(--primary-h), var(--primary-s), var(--primary-l)), hsl(var(--primary-h), var(--primary-s), 95%) ); } .section-2 { --primary-h: 167; } CSS Background Background Image url() linear-gradient() radial-gradient() awesome gradient buttons .btn:hover { background-position: right center; /* change the direction of the change here */ } .btn-1 { background-image: linear-gradient( to right, #f6d365 0%, #fda085 51%, #f6d365 100% ); } .btn-2 { background-image: linear-gradient( to right, #fbc2eb 0%, #a6c1ee 51%, #fbc2eb 100% ); } .btn-3 { background-image: linear-gradient( to right, #84fab0 0%, #8fd3f4 51%, #84fab0 100% ); } .btn-4 { background-image: linear-gradient( to right, #a1c4fd 0%, #c2e9fb 51%, #a1c4fd 100% ); } .btn-5 { background-image: linear-gradient( to right, #ffecd2 0%, #fcb69f 51%, #ffecd2 100% ); } Background Size contain cover useful for images and video .video { min-width: 100%; min-height: 100%; background-size: cover; overflow: hidden; } Background Repeat /* Keyword values */ background-repeat: repeat-x; background-repeat: repeat-y; background-repeat: repeat; background-repeat: space; background-repeat: round; background-repeat: no-repeat; /* Two-value syntax: horizontal | vertical */ background-repeat: repeat space; background-repeat: repeat repeat; background-repeat: round space; background-repeat: no-repeat round; Background Attachment scroll: scrolls with the main view, but stays fixed inside the local view local: scrolls both with the main view and the local view fixed: stays fixed no matter what 对于可以滚动的元素 (设置为 overflow: scroll 的元素), 当 background-attachment 设置为 scroll 时, 背景图不会随元素内容的滚动而滚动 对于可以滚动的元素 (设置为 overflow: scroll 的元素）, 设置 background-attachment: local, 则背景会随内容的滚动而滚动 parallax effect: background-attachment: fixed background-attachment: scroll; /* 背景图相对于元素固定，背景随页面滚动而移动，即背景和内容绑定 */ background-attachment: fixed; /* 背景图相对于元素内容固定 */ background-attachment: local; /* 背景图相对于视口固定，所以随页面滚动背景不动，相当于背景被设置在了 body 上 */ /* parallax effect */ body { box-sizing: border-box; width: 100%; height: 100vh; margin: 0; padding: 0; } .parallax { min-height: 60%; /* key */ background-attachment: fixed; /* key */ background-image: url('./images/bg.jpg'); background-position: center; background-size: cover; background-repeat: no-repeat; } Background Clip 指定背景显示范围 content-box/padding-box/border-box h1 { background-image: url(bg.jpg); background-clip: text; } Background Origin 指定背景绘制起点 content-box/padding-box/border-box Blend Mode mix-blend-mode is used for text styles with multiply: black is cutout (keep black) (0 * WHAT = 0) with screen: white is cutout (keep white) (100 - (100 - WHAT) * (100 - 100) = 100) Even More CSS Secrets .background { background-image: url('bg.png'); background-position: center; background-size: cover; background-repeat: no-repeat; } .background h1 { background-color: black; /* mix with background */ color: white; /* keep white */ mix-blend-mode: screen; /* screen or multiply */ } background-blend-mode is used for multiple background images .container { background: url($pic1), url($pic2); background-size: cover; background-blend-mode: lighten; } Night mode: .night { background-blend-mode: darken; filter: brightness(80%) grayscale(20%) contrast(1.2); } movie style .movie { background-blend-mode: soft-light; filter: contrast(1.1); } Mask Style Black for masking White for showing #masked { width: 100px; height: 100px; background-color: #8cffa0; mask-image: url(https://mdn.mozillademos.org/files/12668/MDN.svg), url(https://mdn.mozillademos.org/files/12676/star.svg); mask-size: 100% 100%; mask-composite: add; /* Can be changed in the live sample */ } Clip Path .polygon { clip-path: polygon(75% 0%, 100% 50%, 75% 100%, 0% 100%, 25% 50%, 0% 0%); } Background Best Practice Scroll Indicator body { position: relative; } .indicator { position: absolute; top: 0; right: 0; left: 0; bottom: 0; z-index: 1; background: linear-gradient(to right top, teal 50%, transparent 50%) no-repeat; background-size: 100% calc(100% - 100vh); pointer-events: none; mix-blend-mode: darken; } /* use after element to hidden triangle background gradient */ /* only show 5px background */ .indicator::after { content: ''; position: fixed; top: 5px; bottom: 0; right: 0; left: 0; z-index: 1; background: #fff; } Jumbotron and Landing Page .jumbotron { background-image: url(''); background-size: cover; background-position: center center; background-repeat: no-repeat; height: 1px; width: 1px; } Horizontal Scrolling Best Practices Horizontal Scrolling: Avoid a full-screen horizontal scroll; ensure that users know there is also content that can be reached using a traditional method. Make scroll interactions obvious and provide instruction. To avoid accessibility issues, ensure that horizontal scrolling elements also work with keyboard navigation. Design horizontal scrolling elements in containers using HTML and CSS. Use visual cues, such as partial images, to show that there is a horizontal scroll action in effect. Use partial horizontal scrolling with a static design element for stability. Design horizontal scroll bars in the same manner as vertical scroll bars to create an element of familiarity for users. Horizontal Scrolling Methods: Rotate 90 deg element. display: flex; overflow-x: auto; grid-auto-flow: column; scroll-snap-type: x mandatory; scroll-snap-align: center; CSS Text .text { text-align: center; text-decoration: underline/line-through; /* 下划线与删除线 */ } .paragraph { text-indent: 2em; /* 段落缩进 */ line-height: 1.5em; /* 行间距 */ word-spacing: 50px; /* 词间距 */ letter-spacing: 50px; /* 字间距 */ } white-space html 中, 普通标签内自动忽略空格符, 并将其与空白符转换成一个空格进行输出, 可用 white-spacing 改变这一行为 p { /* 保留所有特殊符号 */ white-space: pre; } CSS Font font-size Best Practice html { /*浏览器默认size为16px，此时将html-size自动计算为10px*/ font-size: 62.5%; } small { /*11px*/ font-size: 1.1rem; } strong { /*18px*/ font-size: 1.8rem; } font-style normal,italic,oblique font-variant normal,small-caps(小型大写字母) font-size-adjust 使字体保持大小，不随字体类型改变而改变 不同字体有不同的值(x-height/字体尺寸) font-diplay The font display timeline: block period: font face is not loaded, render an invisible fallback font face (use normally when loaded in this period) swap period: font face is not loaded, render a fallback font face (use normally when loaded in this period) failure period: the user agent treats it as a failed load causing normal font fallback font-display - how a font face is displayed based on whether and when it is downloaded and ready to use: auto: font display strategy defined by the user agent block: a short block period and an infinite swap period swap: an extremely small block period and an infinite swap period fallback: an extremely small block period and a short swap period optional: an extremely small block period and no swap period @font-face { font-family: ExampleFont; src: url(/path/to/fonts/examplefont.woff) format('woff'), url(/path/to/fonts/examplefont.eot) format('eot'); font-weight: 400; font-style: normal; font-display: fallback; } custom function - @font-face 使用户使用服务端提供的字体(bootstrap 中有使用@font-face) @font-face { /*:call 105_SparkupNext()*/ font-family: mySpecialFont; font-style/font-weight/font-variant: inherit; src: url(‘./Colleen.ttf’); } /*selector {*/ /*:call 105_SparkupNext()*/ /*font-family:mySpecialFont;*/ /*}*/ Font Best Practice text-decoration: none; text-transform: uppercase; color: black; line-height: 100px; letter-spacing: 1.3px; font-family: sans-serif; font-size: 12px; font-weight: 400; 小米米官网: { font-family: 'Arial', 'Microsoft YaHei', '黑体', '宋体', sans-serif; } 淘宝技术研发中心: { font: 12px/1.5 Tahoma, Helvetica, Arial, '宋体', sans-serif; } 加网: { font: 14px/1.5 'Microsoft YaHei', arial, tahoma, \\5b8b\\4f53, sans-serif; } 淘宝ued: { font: 12px/1 Tahoma, Helvetica, Arial, '\\5b8b\\4f53', sans-serif; } 一淘ux: { font-family: Helvetica, 'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', Arial, sans-serif; } { font: 12px/1 Tahoma, Helvetica, Arial, '\\5b8b\\4f53', sans-serif; } 宋体 SimSun 黑体 SimHei 微软雅黑 Microsoft YaHei 微软正黑体 Microsoft JhengHei 新宋体 NSimSun 新细明体 PMingLiU 细明体 MingLiU 标楷体 DFKai-SB 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 宋体：SimSun 华文细黑：STHeiti Light [STXihei] 华文黑体：STHeiti 华文楷体：STKaiti 华文宋体：STSong 华文仿宋：STFangsong 儷黑 Pro：LiHei Pro Medium 儷宋 Pro：LiSong Pro Light 標楷體：BiauKai 蘋果儷中黑：Apple LiGothic Medium 蘋果儷細宋：Apple LiSung Light 新細明體：PMingLiU 細明體：MingLiU 標楷體：DFKai-SB 黑体：SimHei 新宋体：NSimSun 仿宋：FangSong 楷体：KaiTi 仿宋_GB2312：FangSong_GB2312 楷体_GB2312：KaiTi_GB2312 微軟正黑體：Microsoft JhengHei 微软雅黑体：Microsoft YaHei 隶书：LiSu 幼圆：YouYuan 华文细黑：STXihei 华文楷体：STKaiti 华文宋体：STSong 华文中宋：STZhongsong 华文仿宋：STFangsong 方正舒体：FZShuTi 方正姚体：FZYaoti 华文彩云：STCaiyun 华文琥珀：STHupo 华文隶书：STLiti 华文行楷：STXingkai 华文新魏：STXinwei CSS Couter Adjust the appearance of content based on its location in a document. /* Set a counter named 'section', and its initial value is 0. */ body { counter-reset: section; } /* Increment the value of section counter by 1 */ /* Display the value of section counter */ h3::before { counter-increment: section; content: counter(section); } CSS Filter 来源自 SVG 的滤镜特效 Instagram Filter filter: url(resources.svg); /*引用SVG filter元素*/ filter: blur(5px); /*模糊*/ filter: brightness(0.4); /*高光*/ filter: contrast(200%); /*对比度*/ filter: drop-shadow(16px 16px 20px blue); /*阴影*/ filter: grayscale(50%); /*灰度*/ filter: hue-rotate(90deg); /*色相旋转*/ filter: invert(75%); /*颜色翻转/反相*/ filter: opacity(25%); /*透明度*/ filter: saturate(30%); /*饱和度*/ filter: sepia(60%); /*老照片*/ /* Apply multiple filters */ filter: contrast(175%) brightness(3%); /* Global values */ filter: inherit; filter: initial; filter: unset; Backdrop Filter body { background-image: url('https://images.unsplash.com/image'); background-position: center; } .card { backdrop-filter: blur(12px) saturate(200%); background-color: rgba(17, 25, 40, 0.54); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.125); } Object Position/Fit object-position/object-fit 只针对替换元素有作用: form component img video object-position/object-fit 之间的关系有点类似于 background-position/background-size, 可以处理图片拉伸变形问题. .image-container { position: relative; padding-bottom: calc(2 / 3) * 100%; /* (height / width) ratio */ } .image-container > img { position: absolute; width: 100%; height: 100%; object-fit: cover; } Animation Animation 101 Tutorial Animation Property Transition and Transform .div { transform: scaleX(0); transition: * * transform * * 0.5s ease; } .div:hover { transform: scaleX(1); } Animation and Transform Animation Helper opacity overflow: hidden pseudo elements (::before and ::after) pseudo elements with animation (opacity, scale, translate, width/height, margin, background-position) :hover/:foucs/:target + animation/transform/transition transform: scale/translate animation-delay width/height max-width/max-height margin border background background-position background with multiple gradient single box-shadow multiple box-shadow overflow: hidden; z-index: -1; Changing top/right/bottom/left of pseduo element can change animation start point (e.g bottom: 0, right: 0, change width/height from 0 to 100%, size animation will start from bottom-right corner). Transition Basic Usage transition-property: color; transition-duration: 1s; transition-timing-function: cubic-bezier(.42, 0, .58, 1); transition-delay: .5s; .element { transition: property durtation timing-function delay; transition: transform 0.5s ease-in-out 0.2s; } Transition Internal transition take effect only when browser detecing different styles between style stage. // transition not working panel.style.transform = 'scale(0)'; panel.style.transition = 'transform .5s'; // previous `transform` is empty panel.style.transform = 'scale(1)'; // transition working panel.style.transform = 'scale(0)'; panel.style.transition = 'transform .5s'; // previous `transform` is `scale(0)` requestAnimationFrame(() => { panel.style.transform = 'scale(1)'; }); // transition working panel.style.transform = 'scale(0)'; // `getComutedStyle(element).property` trigger a new `style` stage getComputedStyle(panel).transform; panel.style.transition = 'transform .5s'; // previous `transform` is `scale(0)` panel.style.transform = 'scale(1)'; Transition Direction By specifying the transition on the element itself, define the transition to occur in both directions (hover on and hover off). Change transition when :hvoer etc state bring magic effect: .menu-nav { visibility: hidden; transform: translateX(-100%); transition: all 0.4s ease-in-out; } .menu-link { opacity: 0; transition: opacity 0.4s ease-in-out; } .menu-toggle:checked ~ .menu-nav { visibility: visible; transform: translateX(0); } .menu-toggle:checked ~ .menu-nav .menu-link { opacity: 1; /* magic effect for delaying transition */ transition: opacity 0.4s ease-in-out 0.4s; } Class Controls on Transition Transition Best Practice: with transition: opacity 0.5s set, fisrt add .opacity-0 class, then replace it with .opacity-1 class. Transition animation get trigger as css style of element changed (class changed). .element { transition: opacity 0.5s; } /* before-enter -> enter -> before-leave -> leave */ .enter, .before-leave { opacity: 1; } .leave, .before-enter { opacity: 0; } div.classList.add('before-enter'); setTimeout(() => { div.classList.remove('before-enter'); div.classList.add('enter'); }, 20); Transform Transformations do affect the visual rendering, but have no affect on the CSS layout other than affecting overflow. Transforms are also taken into account when computing client rectangles exposed via the Element Interface Extensions, namely getClientRects() and getBoundingClientRect(), which are specified in [CSSOM-VIEW]. scale/X/Y/Z/3d(): 0 - n translate/X/Y/Z/3d(): n px rotate/X/Y/Z/3d(): deg skew/X/Y(): deg matrix()/matrix3d() transform-orgin: change transform start point top bottom center left right perspective(): 为 3D 转换元素定义透视视图 keep translate(-50%, -50%) in keyframe transform peoperty list when using it for alignment 一般需要在容器元素上加上以下样式: .transform-container { perspective: 1024px; transform-style: preserve-3d; } .front .back { backface-visibility: hidden; } :hover should not add to transfromed elements :hover should add to parent element 当旋转绝对定位居中的元素时, 需要改变 transform-origin: .roate { position: absolute; top: 200px; left: 50%; transform: translateX(-50%); transform-origin: left; } Perspective translateZ 的功能就是让元素在自己的眼前或近或远 .parent { perspective: 201px; } 其子元素: 设置的 translateZ 值越小，则子元素大小越小（因为元素远去，我们眼睛看到的就会变小）； translateZ 值越大，该元素也会越来越大 当 translateZ 值非常接近 201 像素，但是不超过 201 像素的时候（如 200 像素） 该元素的大小就会撑满整个屏幕（父辈元素没有 overflow:hidden 的限制） 当 translateZ 值再变大，超过 201 像素的时候，该元素看不见了 Transform Style transform-style 属性也是 3D 效果中经常使用的， 其两个参数，flat|preserve-3d. 前者 flat 为默认值，表示平面的； 后者 preserve-3d 表示 3D 透视 backface-visibility backface-visibility: hidden; 当元素 rotateY(180deg) 时，元素将被隐藏 Animation Details transform: scale, translate, rotate, skew animation bounce/cache: first -100, then, +5/+20, finally 0 .element { animation: name duration timing-function delay iteration-count direction; } Tip : fade in body style @keyframes body-fade-in { from { opacity: 0; } to { opacity: 1; } } body { animation-name: body-fade-in; animation-duration: 2.5s; animation-timing-function: ease; animation-iteration-count: 1; } @keyframes name { 0%/from { color: red; } 50% { color: blue; } 100%/to { color: green; } } /*直接动画*/ .div { animation-name: name; animation-duration: 1s; animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1); animation-delay: 0.5s; } /*hover后再播放动画，高级化transform+transition*/ .div:hover { animation-name: name; animation-duration: 1s; animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1); animation-delay: 0.5s; } animation-iteration-count: 执行次数 infinite animation-direction: 执行方向 normal 0%->100%方向 alternate/alternate-reverse 不断交替方向 reverse 100%->0%方向 animation-fill-mode: forwards animatino-play-state: paused/running DOM events: animationiteration: triggered after each animation iteration animationend: triggered after an animation completes animationstart: triggered at the start of an animation Animation Play State div { animation-play-state: paused; } :checked ~ div { animation-play-state: running; } animation pattern: 利用 animation-paly-state 与 JS 添加 .animate 类控制动画开始和停止. .to-animte { animation: animationName 1.5s linear; animation-play-state: paused; animation-iteration-count: infinite; } .animate { animation-iteration-count: running; } element.classList.add('animate'); setTimeout(() => element.classList.remove('animate'), duration); FLIP first: 初始状态 last: 动画结束状态 invert: last 至 first 的 transform 属性 play: transition: transform .2s linear /* first: scale(1), last: scale(1.2) */ .scale-up { transform: scale(0.8); transition: transform 0.2s linear; } .scale-up:hover { transform: none; } GreenSock Library TweenMax TweenMax.fromTo(element, 1, { x: 0 }, { x: 100 }); TimelineMax const tl = new TimelineMax(); tl.staggerFrom( [ '#Capa_1 > g > path:nth-child(1)', '#Capa_1 > circle:nth-child(7)', '#Capa_1 > path:nth-child(6)', '#Capa_1 > circle:nth-child(5)', ], 1, { scaleY: 0, scaleX: 0, transformOrigin: 'center', ease: Bounce.easeOut, stagger: 0.2, } ); Responsive Desgin Responsive Font em/rem font-size Responsive Length vw vh vmin vmax Responsive Box Responsive Width and Height min-height max-height min-width max-width /* responsive images */ img { max-width: 100%; } responsive inline-box use inline-box with width .element { display: inline-box; width: 80%; } responsive image .responsive-image { display: block; max-width: 100%; height: auto; } media query only for improving compatibility with older browsers definition order matters when media query with a different selector @media (not/only) 设备类型 and ((not) 设备特性), (not/only) 设备类型 and ((not) 设备特性-1) and ((not) 设备特性-2) { /* 样式代码 */ } /*screen size : 500px ~ 1000px*/ @media screen and (min-width: 500px) and (max-width: 1000px) { .container { width: 750px; } } JavaScript Media Query API MDN Media Query Tutorial // https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList const mql = window.matchMedia(mediaQueryString); if (window.matchMedia('(min-width: 400px)').matches) { /* the view port is at least 400 pixels wide */ } else { /* the view port is less than 400 pixels wide */ } 设备类型 类型 解释 all 所有设备 braille 盲文 embossed 盲文打印 handheld 手持设备 print 文档打印或打印预览模式 projection 项目演示，比如幻灯 screen 彩色电脑屏幕 speech 演讲 tty 固定字母间距的网格的媒体，比如电传打字机 tv 电视 设备特性 属性 值 Min/Max 描述 aspect-ratio 整数/整数 yes 渲染界面宽高比例 device-aspect-ratio 整数/整数 yes 设备屏幕宽高比例 color 整数 yes 每种色彩的字节数 color-index 整数 yes 色彩表中的色彩数 height length yes 渲染界面的高度 width length yes 渲染界面的宽度 device-height length yes 设备屏幕的输出高度 device-width length yes 设备屏幕的输出宽度 grid 整数 no 是否是基于格栅的设备 monochrome 整数 yes 缓冲器中每像素字节 resolution 分辨率(“dpi/dpcm”) yes 分辨率 scan Progressive interlaced no tv 媒体扫描方式 orientation Portrait/landscape no 横屏或竖屏 Style for Print PDF Page Style Standard PDF Style Tutorial Accessibility Screnn Reader Only .sr-only { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; border: 0; clip: rect(0 0 0 0); clip-path: polygon(0px 0px, 0px 0px, 0px 0px); white-space: nowrap; overflow: hidden; } 常用组件 (Awesome Demo) Landing Page h1 { background-image: url(bg.jpg); background-clip: text; } .jumbotron { min-height: 100%; background-image: url(''); background-size: cover; background-position: center center; background-repeat: no-repeat; opacity: 0.8; } .fullscreen-video { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; background-size: cover; overflow: hidden; z-index: -100; } .fullscreen-video video { min-width: 100%; min-height: 100%; } .parallax { min-height: 60%; /* key */ background-attachment: fixed; /* key */ background-image: url('./images/bg.jpg'); background-position: center; background-size: cover; background-repeat: no-repeat; } Modal .overlay { position: absolute; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); } Flexiable Heading h1 { display: flex; width: 100%; align-items: center; } h1::before, h1::after { content: ''; background-color: gray; height: 0.1em; margin: 0.2em; flex: 1; } reset.css Table margin-left: auto to align-left border: 0 and border-collapse: collapse to remove border line table-layout: fixed to contain cells with same width implement filter or pagination with display: none applied to Form Form Design Patterns Select .custom-select { width: 15%; height: 35px; margin-right: 20px; /* 消除默认箭头 */ text-indent: 0.01px; text-overflow: ''; /* 自定义边框 */ border: 0; /* 将箭头图片移至右端 */ background: url('../img/arrow.png') no-repeat; background-color: #fff; background-position: right; /* 消除默认样式 */ appearance: none; -webkit-appearance: none; -moz-appearance: none; } .custom-select:focus { border: 1px solid #e74f4d; } .custom-select option { width: 100%; height: 25px; padding-left: 30px; color: #323333; background-color: #fff; line-height: 25px; } .custom-select option:hover { color: #fff; background: url(../img/tick.png) no-repeat 8px center; background-color: #e74f4d; } Navigation 基本原则 对 a 标签进行样式设置 ul { /* 垂直菜单设置宽度, 水平菜单不设置宽度*/ list-style: none; } /* 水平菜单 */ li { float: left; } a { display: inline-block; text-decoration: none; cursor: pointer; } ul { text-align: right; } li { display: inline-block; } Hidden Link a { opacity: 0; cursor: default; pointer-events: none; text-decoration: none; } Awesome Navigation Style change bottom border a { position: relative; padding-bottom: 5px; color: #008080; text-decoration: none; } a::after { position: absolute; bottom: 0; left: 0; width: 0; height: 3px; background-color: #22313f; content: ''; transform-origin: bottom-center; } a:hover { color: #22313f; } a:hover::after { width: 100%; } Button padding a.btn-custom { padding: 10px 40px; border-radius: 0; background-color: #000; line-height: 100px; text-align: center; } Footer Sticky Footer 如果页面内容不足够长时, 页脚固定在浏览器窗口的底部 如果内容足够长时, 页脚固定在页面的最底部 5 种方法: negative bottom margin content-wrapper with fixed height footer negative top margin on fixed height footer calc on fixed height footer use flex on body use grid on body content html, body { height: 100%; margin: 0; } .wrapper { min-height: 100%; /* Equal to height of footer */ /* But also accounting for potential margin-bottom of last child */ margin-bottom: -50px; } .footer, .push { height: 50px; } content html, body { height: 100%; margin: 0; } .content { min-height: 100%; } .content-inside { padding: 20px; padding-bottom: 50px; } .footer { height: 50px; margin-top: -50px; } content .content { min-height: calc(100vh - 70px); } .footer { height: 50px; } content html, body { height: 100%; } body { display: flex; flex-direction: column; } .content { flex: 1 0 auto; } .footer { flex-shrink: 0; } content html { height: 100%; } body { min-height: 100%; display: grid; grid-template-rows: 1fr auto; } .footer { grid-row-start: 2; grid-row-end: 3; } Picture 圆形图片 { border-radius: 50%; overflow: hidden; } Animation Tips 切换动画时, 需要先把之前的动画清除 (防止出现闪烁 Bug ) Animated Dots dot { display: inline-block; height: 1em; line-height: 1; text-align: left; vertical-align: -0.25ex; overflow: hidden; } dot::before { display: block; content: '...\\A..\\A.'; white-space: pre-wrap; animation: dot1 3s infinite step-start both; } @keyframes dot1 { 33% { transform: translateY(-2em); } 66% { transform: translateY(-1em); } } Fade with Class .enter, .leave { transition: opacity 0.5s; } .before-enter, .leave { opacity: 0; } .enter, .before-leave { opacity: 1; } function enter(el, done) { el.classList.add('before-enter'); setTimeout(() => { el.classList.remove('before-enter'); el.classList.add('enter'); }, 20); setTimeout(() => { el.classList.remove('enter'); done(); }, 500); } function leave(el, done) { el.classList.add('before-leave'); setTimeout(() => { el.classList.remove('before-leave'); el.classList.add('leave'); }, 0); setTimeout(() => { el.classList.remove('leave'); done(); }, 500); } Accordion Menu Animation .menu { overflow: hidden; max-height: 0; transition: max-height, 0.3s; } .container:hover .menu, .menu:focus { max-height: 1em; } Slides Animation .slide { width: 500%; overflow: hidden; } @keyframes slide { 0% { margin-left: 0; } 10% { margin-left: 0; } 12% { margin-left: -100%; } 22% { margin-left: -100%; } 24% { margin-left: -200%; } 34% { margin-left: -200%; } 36% { margin-left: -300%; } 46% { margin-left: -300%; } 48% { margin-left: -400%; } 58% { margin-left: -400%; } 60% { margin-left: -300%; } 70% { margin-left: -300%; } 72% { margin-left: -200%; } 82% { margin-left: -200%; } 84% { margin-left: -100%; } 94% { margin-left: -100%; } 96% { margin-left: 0; } } Resizable Component Codepen Demo bottom-right: new_width = element_original_width + (mouseX - original_mouseX) new_height = element_original_height + (mouseY - original_mouseY) bottom-left: new_width = element_original_width - (mouseX - original_mouseX) new_height = element_original_height + (mouseY - original_mouseY) new_x = element_original_x - (mouseX - original_mouseX) top-right: new_width = element_original_width + (mouseX - original_mouseX) new_height = element_original_height - (mouseY - original_mouseY) new_y = element_original_y + (mouseY - original_mouseY) top-left: new_width = element_original_width - (mouseX - original_mouseX) new_height = element_original_height - (mouseY - original_mouseY) new_x = element_original_x + (mouseX - original_mouseX) new_y = element_original_y + (mouseY - original_mouseY) Slides position: absolute to stack slides up id + :target for style current slide (change z-index) add animation to slide change: (prev, current, next) .slide, .slide:target, .slide:target ~ slide add overflow: hidden to body when animation next prev next prev next prev next prev body { overflow: hidden; /* key 1 */ } .slide { box-sizing: border-box; position: absolute; /* key 2 */ width: 100%; height: 100vh; z-index: 0; /* key 3 */ } .slide:target { z-index: 1; /* key 4 */ } /* Rotate Fade-In Animation */ .slide { z-index: 0; transform: rotate(90deg); transform-origin: 0 0; transition: transform 1s, opacity 0.8s; } .slide:target { z-index: 1; transform: rotate(0deg); } .slide:target ~ section { transform: rotate(-90deg); opacity: 0; } 当两个 width: 100% slide 同时处于同一水平位置, 添加左进/右进动画, 当 slide 向右滑动时, 水平的 scrollX 会直接滑到最右边, 导致幻灯片浏览异常. 解决办法 如下: const resetScollX = () => { window.scrollTo(0, 0); }; Layout 相同单元 ul + li + float .container{text-align:center;} + .content{width: xx%;} 元素定位 align margin + padding position + top/bottom/left/right float flex Geometry background: color/image/gradient/clip-path border box-shadow (inset) pseudo element Stretch Line background line border line pseudo element with line-through text-decoration .line { width: 70%; height: 10px; background-color: #000; } .line { background: linear-gradient(#000, #000) 50% / 70% 10px no-repeat; } .line { border-top: 10px solid #000; } .line::after { /* control line length */ content: '_______'; /* hide content */ color: transparent; /* set thickness */ font-size: 5em; text-decoration: line-through #000; } Dash Line background dash line border dash line pseudo element with dashed text-decoration .dash { background: linear-gradient(to left, #000 70%, transparent 0); ​background-repeat: repeat-x; background-size: 30px 10px; } .dash { border-top: 10px dashed #000; } .dash::after { text-decoration-style: dashed; } Circle background circle clip path circle border circle pseudo element circle .circle { background-image: radial-gradient(#000 72%, transparent 0); } .circle { clip-path: circle(50%); } .circle { border-radius: 50%; } .circle::after { content: '·'; line-height: 0; font-size: 120vw; } Triangle background triangle clip path triangle border triangle pseudo elment triangle .triangle { background: linear-gradient(, #000 50%, transparent 0); } /* clip path */ .arrow-right { width: 20px; height: 32px; background-color: #e888a3; clip-path: polygon(0 0, 0 100%, 100% 50%); } /* transparent border */ .arrow-up { width: 0; height: 0; border-right: 16px solid transparent; border-left: 16px solid transparent; border-bottom: 20px solid #8888e8; } /* pseudo element + hidden overflow */ .arrow-down { width: 40px; height: 40px; position: relative; overflow: hidden; &::before { content: ''; display: block; width: calc(40px / 1.41); height: calc(40px / 1.41); position: absolute; top: 0; left: 0; background: #f7df6c; transform: rotate(-45deg); transform-origin: 0 0; } } /* HTML Entities */ /** * ◄ : &#9668; * ► : &#9658; * ▼ : &#9660; * ▲ : &#9650; */ .arrow::before { content: '&#9660'; } Polygon const polygon = (n = 3) => { let deg = (2 * Math.PI) / n; let points = []; for (let i = 0; i CSS Variables Variables DOM API .element { height: 100vh; /* Fallback for browsers that do not support Custom Properties */ height: calc(var(--vh, 1vh) * 100); } window.addEventListener('resize', () => { const vh = window.innerHeight * 0.01; document.documentElement.style.setProperty('--vh', `${vh}px`); }); const root = document.documentElement; const bgColor = getComputedStyle(root).getPropertyValue('--body-bg'); Scope Variebls Info Info Message. .alert { --primary: #777; --secondary: #ccc; border: 1px solid var(--primary); background-color: var(--secondary); } .alert::before { background-color: var(--primary); } .alert-title { color: var(--primary); } .alert-success { --primary: #40c057; --secondary: #d3f9d8; } .alert-info { --primary: #228be6; --secondary: #d0ebff; } .alert-warning { --primary: #fab005; --secondary: #fff3bf; } .alert-error { --primary: #fa5252; --secondary: #ffe3e3; } Invalid and Empty Value in CSS Variables --invalid-value: initial; is invalid value leding to var(--invalid-value) called failed, var(--invalid-value, backup-value) get backup-value. --empty-value: ; is valid empty value leding to var(--empty-value) called succeeded, var(--empty-value, backup-value) get parent value. Use Invalid and Empty Value to implement if (true) in CSS. :root { --ON: initial; --OFF: ; } button { --is-raised: var(--OFF); border: 1px solid var(--is-raised, rgb(0 0 0 / 0.1)); } button:hover { --is-raised: var(--ON); } /** * css-media-vars * BSD 2-Clause License * Copyright (c) James0x57, PropJockey, 2020 */ html { --media-print: initial; --media-screen: initial; --media-speech: initial; --media-xs: initial; --media-sm: initial; --media-md: initial; --media-lg: initial; --media-xl: initial; /* ... */ --media-pointer-fine: initial; --media-pointer-none: initial; } /* 把当前变量变为空值 */ @media print { html { --media-print: ; } } @media screen { html { --media-screen: ; } } @media speech { html { --media-speech: ; } } /* 把当前变量变为空值 */ @media (max-width: 37.499em) { html { --media-xs: ; --media-lte-sm: ; --media-lte-md: ; --media-lte-lg: ; } } /** 移动优先的样式规则 */ .breakpoints-demo > * { /** 小于 37.5em, 宽度 100% */ --xs-width: var(--media-xs) 100%; /** 小于 56.249em, 宽度 49% */ --sm-width: var(--media-sm) 49%; --md-width: var(--media-md) 32%; --lg-width: var(--media-gte-lg) 24%; width: var(--xs-width, var(--sm-width, var(--md-width, var(--lg-width)))); --sm-and-down-bg: var(--media-lte-sm) red; --md-and-up-bg: var(--media-gte-md) green; background: var(--sm-and-down-bg, var(--md-and-up-bg)); } SVG Inline SVG My Awesome SVG .circle { fill: #ffff00; } SVG Basic Shape Tags rectangles and squares: circles: ellipse: line: polyline: polygon: path: SVG Text Tag The text tag is used to create selectable and accessible text. SVG Accessibility Tags The title and description tags are specifically for providing accessibility content. SVG Group Tag The group tag is used to group elements together to add class names and apply animations, filters, patterns and effects to a group of elements. SVG Defs Tag The defs tag is used to define elements for later reuse. This is where you create patterns, filters and masks to be reused later. This is also used to create icon systems. ... © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/css/sassBasicNotes.html":{"url":"programming/web/css/sassBasicNotes.html","title":"Sass Basic Notes","keywords":"","body":"Sass Basic Notes Sass Basic Notes Basis Variable $ normal variable # string variable & nesting varilable List Map arguments list !default flag Directive Mixin/Include if-else for loop while loop each import extend Media Queries with extend Built-in Functions Color Math type and unit Error Handle function error handle mixin error handle Lists Check Project Structure Best Practice Performance Children Selector Tools Framework Sprite Builder Grid System Media Query Basis Variable $ normal variable start with $ $heading-color: green; h1 { color: $heading-color; } # string variable #{$var}: combine with string & nesting varilable refer to parent-selector, only use it on: pseduo selectors and pseduo elements .button { &:hover { color: $color-button-hover; } &::after { } } relationship selectors .button { .sidebar & { font-size: 0.9rem; } } List length($list) nth($list, $n) set-nth($list, $n, $value) index($list, $value) list-separator($list) append($list, $value, [$separator]) Map map-get($map, $key) map-merge($map, $map) map-remove($map, $keys) map-keys($map) map-values($map) map-has-key($map, $key) $colors: ( color1: blue, color2: red, color3: green ); @each $key, $color in $colors { .#{$color}-text { color: $color; } } arguments list @mixin dummy($a, $b, $c) { // … } // Yep @include dummy(true, 42, 'kittens'); // Yep but nope $params: (true, 42, 'kittens'); $value: dummy(nth($params, 1), nth($params, 2), nth($params, 3)); // Yep $params: (true, 42, 'kittens'); @include dummy($params...); // Yep $params: ( 'c': 'kittens', 'a': true, 'b': 42 ); @include dummy($params...); !default flag only assign when variables hadn't been assigned Directive Mixin/Include @mixin box-shadow($x, $y, $blur, $c) { -webkit-box-shadow: $x, $y, $blur, $c; -moz-box-shadow: $x, $y, $blur, $c; -ms-box-shadow: $x, $y, $blur, $c; box-shadow: $x, $y, $blur, $c; } div { @include box-shadow(0px, 0px, 4px, #fff); } if-else @mixin border-stroke($val) { @if $val == light { border: 1px solid black; } @else if $val == medium { border: 3px solid black; } @else if $val == heavy { border: 6px solid black; } @else { border: none; } } // Good @if not index($list, $item) { // … } // Bad @if index($list, $item) == null { // … } for loop @for $i from 1 through 12 { .col-#{$i} { width: 100% / 12 * $i; } } while loop $x: 1; @while $x each @each $color in blue, red, green { .#{$color}-text { color: $color; } } import // import _variables.scss in main.scss @import 'variables'; ~ to import scss from node_modules @import '~bootstrap/scss/bootstrap'; extend @extend is basically about moving selectors around: can't extend complex selector can't extend cross media query avoid extending from nested selectors avoid chaining @extend directives // This CSS won't print because %equal-heights is never extended. %equal-heights { display: flex; flex-wrap: wrap; } // This CSS will print because %message-shared is extended. %message-shared { border: 1px solid #ccc; padding: 10px; color: #333; } .message { @extend %message-shared; } .success { @extend %message-shared; border-color: green; } .error { @extend %message-shared; border-color: red; } .warning { @extend %message-shared; border-color: yellow; } .panel { background-color: red; height: 70px; border: 2px solid green; } .big-panel { @extend .panel; width: 150px; font-size: 2em; } Media Queries with extend %foo { content: 'foo'; } // Wrong @media print { .bar { // This doesn't work. Worse: it crashes. @extend %foo; } } // Right @media print { .bar { @at-root (without: media) { @extend %foo; } } } // Right %foo { content: 'foo'; &-print { @media print { content: 'foo print'; } } } @media print { .bar { @extend %foo-print; } } Built-in Functions Offical Documentation or Devdocs Guide Color mix is better than lighten/darken @function tint($color, $percentage) { @return mix(white, $color, $percentage); } @function shade($color, $percentage) { @return mix(black, $color, $percentage); } Math round($number) ceil($number) floor($number) abs($number) max min $value: 13.37; $length: $value * 1em; whatever { padding-top: round($length); // 13em } type and unit unit($length) unitless($length) type-of($var) is-type-of($var, $type) Error Handle type-of is-type-of unit unitless @warn/@error function error handle @function add-10($number) { @if type-of($number) != 'number' { @warn \"`#{$number}` is not a number of `add-10`.\"; @return false; } @return $number + 10; } mixin error handle @mixin module($name) { // Initialize a validity checker boolean $everything-okay: true; // Check for argument validity @if type-of($name) != 'string' { @warn '\"#{$name}\" is not a string for \"module\".'; $everything-okay: false; } // If everything's still okay, dump mixin content @if $everything-okay { @content; } } Lists Check @if length($value) > 1 and type-of($value) != map { // It is a list of multiple values } Project Structure Complete Guide for Sass Directory Structure Difference between Sass Directory Architectures sass/ |– abstracts/ | |– _variables.scss # Sass Variables | |– _functions.scss # Sass Functions | |– _mixins.scss # Sass Mixins | |– _helpers.scss # Class & placeholders helpers | ... # Etc… | |– vendors/ | |– _bootstrap.scss # Bootstrap | |– _jquery-ui.scss # jQuery UI | ... # Etc… | |– base/ | |– _reset.scss # Reset/normalize | |– _typography.scss # Typography rules | ... # Etc… | |– components/ | |– _buttons.scss # Buttons | |– _carousel.scss # Carousel | |– _cover.scss # Cover | |– _dropdown.scss # Dropdown | |– _navigation.scss # Navigation | ... # Etc… | |– layout/ | |– _grid.scss # Grid system | |– _header.scss # Header | |– _footer.scss # Footer | |– _sidebar.scss # Sidebar | |– _forms.scss # Forms | ... # Etc… | |– pages/ | |– _home.scss # Home specific styles | |– _contact.scss # Contact specific styles | ... # Etc… | |– themes/ | |– _theme.scss # Default theme | |– _admin.scss # Admin theme | ... # Etc… | |– main.scss # primary Sass file in main.scss file: @charset 'utf-8'; import abstracts import vendors import base import layout import components import themes (or pages when it's not partial directory) When working on a very large project with a lot of abstract utilities, it might be interesting to group them by topic rather than type, for instance typography (_typography.scss), theming (_theming.scss), etc. Each file contains all the related helpers: variables, functions, mixins and placeholders. Best Practice Performance mixin better than extend Children Selector // Good %button { display: inline-block; // … button styles // Relationship: a %button that is a child of a %modal %modal > & { display: block; } } .button { @extend %button; } // Bad Style .modal { @extend %modal; > .button { @extend %button; } } Tools Framework Compass Bourbon Sprite Builder Grunticon Grumpicon Grid System Susy Singulartiy CSSWizardry Grids Media Query Sass MQ Breakpoint Sass Include Media © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/css/sassOfficalReference.html":{"url":"programming/web/css/sassOfficalReference.html","title":"Sass Offical Reference","keywords":"","body":"Sass (Syntactically Awesome StyleSheets) Sass is an extension of CSS that adds power and elegance to the basic language. It allows you to use variables, nested rules, mixins, inline imports, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized, and get small stylesheets up and running quickly, particularly with the help of the Compass style library. Features Fully CSS-compatible Language extensions such as variables, nesting, and mixins Many {Sass::Script::Functions useful functions} for manipulating colors and other values Advanced features like control directives for libraries Well-formatted, customizable output Syntax There are two syntaxes available for Sass. The first, known as SCSS (Sassy CSS) and used throughout this reference, is an extension of the syntax of CSS. This means that every valid CSS stylesheet is a valid SCSS file with the same meaning. In addition, SCSS understands most CSS hacks and vendor-specific syntax, such as IE's old filter syntax. This syntax is enhanced with the Sass features described below. Files using this syntax have the .scss extension. The second and older syntax, known as the indented syntax (or sometimes just \"Sass\"), provides a more concise way of writing CSS. It uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties. Some people find this to be easier to read and quicker to write than SCSS. The indented syntax has all the same features, although some of them have slightly different syntax; this is described in {file:INDENTED_SYNTAX.md the indented syntax reference}. Files using this syntax have the .sass extension. Either syntax can import files written in the other. Files can be automatically converted from one syntax to the other using the sass-convert command line tool: # Convert Sass to SCSS sass-convert style.sass style.scss # Convert SCSS to Sass sass-convert style.scss style.sass Note that this command does not generate CSS files. For that, use the sass command described elsewhere. Using Sass Sass can be used in three ways: as a command-line tool, as a standalone Ruby module, and as a plugin for any Rack-enabled framework, including Ruby on Rails and Merb. The first step for all of these is to install the Sass gem: gem install sass If you're using Windows, you may need to install Ruby first. To run Sass from the command line, just use sass input.scss output.css You can also tell Sass to watch the file and update the CSS every time the Sass file changes: sass --watch input.scss:output.css If you have a directory with many Sass files, you can also tell Sass to watch the entire directory: sass --watch app/sass:public/stylesheets Use sass --help for full documentation. Using Sass in Ruby code is very simple. After installing the Sass gem, you can use it by running require \"sass\" and using {Sass::Engine} like so: engine = Sass::Engine.new(\"#main {background-color: #0000ff}\", :syntax => :scss) engine.render #=> \"#main { background-color: #0000ff; }\\n\" Rack/Rails/Merb Plugin To enable Sass in Rails versions before Rails 3, add the following line to environment.rb: config.gem \"sass\" For Rails 3, instead add the following line to the Gemfile: gem \"sass\" To enable Sass in Merb, add the following line to config/dependencies.rb: dependency \"merb-haml\" To enable Sass in a Rack application, add the following lines to config.ru. require 'sass/plugin/rack' use Sass::Plugin::Rack Sass stylesheets don't work the same as views. They don't contain dynamic content, so the CSS only needs to be generated when the Sass file has been updated. By default, .sass and .scss files are placed in public/stylesheets/sass (this can be customized with the :template_location option). Then, whenever necessary, they're compiled into corresponding CSS files in public/stylesheets. For instance, public/stylesheets/sass/main.scss would be compiled to public/stylesheets/main.css. Caching By default, Sass caches compiled templates and partials. This dramatically speeds up re-compilation of large collections of Sass files, and works best if the Sass templates are split up into separate files that are all @imported into one large file. Without a framework, Sass puts the cached templates in the .sass-cache directory. In Rails and Merb, they go in tmp/sass-cache. The directory can be customized with the :cache_location option. If you don't want Sass to use caching at all, set the :cache option to false. Options Options can be set by setting the {Sass::Plugin::Configuration#options Sass::Plugin#options} hash in environment.rb in Rails or config.ru in Rack... Sass::Plugin.options[:style] = :compact ...or by setting the Merb::Plugin.config[:sass] hash in init.rb in Merb... Merb::Plugin.config[:sass][:style] = :compact ...or by passing an options hash to {Sass::Engine#initialize}. All relevant options are also available via flags to the sass and scss command-line executables. Available options are: :style: Sets the style of the CSS output. See Output Style. :syntax: The syntax of the input file, :sass for the indented syntax and :scss for the CSS-extension syntax. This is only useful when you're constructing {Sass::Engine} instances yourself; it's automatically set properly when using {Sass::Plugin}. Defaults to :sass. :property_syntax: Forces indented-syntax documents to use one syntax for properties. If the correct syntax isn't used, an error is thrown. :new forces the use of a colon after the property name. For example: color: #0f3 or width: $main_width. :old forces the use of a colon before the property name. For example: :color #0f3 or :width $main_width. By default, either syntax is valid. This has no effect on SCSS documents. :cache: Whether parsed Sass files should be cached, allowing greater speed. Defaults to true. :read_cache: If this is set and :cache is not, only read the Sass cache if it exists, don't write to it if it doesn't. :cache_store: If this is set to an instance of a subclass of {Sass::CacheStores::Base}, that cache store will be used to store and retrieve cached compilation results. Defaults to a {Sass::CacheStores::Filesystem} that is initialized using the :cache_location option. :never_update: Whether the CSS files should never be updated, even if the template file changes. Setting this to true may give small performance gains. It always defaults to false. Only has meaning within Rack, Ruby on Rails, or Merb. :always_update: Whether the CSS files should be updated every time a controller is accessed, as opposed to only when the template has been modified. Defaults to false. Only has meaning within Rack, Ruby on Rails, or Merb. :always_check: Whether a Sass template should be checked for updates every time a controller is accessed, as opposed to only when the server starts. If a Sass template has been updated, it will be recompiled and will overwrite the corresponding CSS file. Defaults to false in production mode, true otherwise. Only has meaning within Rack, Ruby on Rails, or Merb. :poll: When true, always use the polling backend for {Sass::Plugin::Compiler#watch} rather than the native filesystem backend. :full_exception: Whether an error in the Sass code should cause Sass to provide a detailed description within the generated CSS file. If set to true, the error will be displayed along with a line number and source snippet both as a comment in the CSS file and at the top of the page (in supported browsers). Otherwise, an exception will be raised in the Ruby code. Defaults to false in production mode, true otherwise. :template_location: A path to the root sass template directory for your application. If a hash, :css_location is ignored and this option designates a mapping between input and output directories. May also be given a list of 2-element lists, instead of a hash. Defaults to css_location + \"/sass\". Only has meaning within Rack, Ruby on Rails, or Merb. Note that if multiple template locations are specified, all of them are placed in the import path, allowing you to import between them. Note that due to the many possible formats it can take, this option should only be set directly, not accessed or modified. Use the {Sass::Plugin::Configuration#template_location_array Sass::Plugin#template_location_array}, {Sass::Plugin::Configuration#add_template_location Sass::Plugin#add_template_location}, and {Sass::Plugin::Configuration#remove_template_location Sass::Plugin#remove_template_location} methods instead. :css_location: The path where CSS output should be written to. This option is ignored when :template_location is a Hash. Defaults to \"./public/stylesheets\". Only has meaning within Rack, Ruby on Rails, or Merb. :cache_location: The path where the cached sassc files should be written to. Defaults to \"./tmp/sass-cache\" in Rails and Merb, or \"./.sass-cache\" otherwise. If the :cache_store option is set, this is ignored. :unix_newlines: If true, use Unix-style newlines when writing files. Only has meaning on Windows, and only when Sass is writing the files (in Rack, Rails, or Merb, when using {Sass::Plugin} directly, or when using the command-line executable). :filename: The filename of the file being rendered. This is used solely for reporting errors, and is automatically set when using Rack, Rails, or Merb. :line: The number of the first line of the Sass template. Used for reporting line numbers for errors. This is useful to set if the Sass template is embedded in a Ruby file. :load_paths: An array of filesystem paths or importers which should be searched for Sass templates imported with the @import directive. These may be strings, Pathname objects, or subclasses of {Sass::Importers::Base}. This defaults to the working directory and, in Rack, Rails, or Merb, whatever :template_location is. The load path is also informed by {Sass.load_paths} and the SASS_PATH environment variable. :filesystem_importer: A {Sass::Importers::Base} subclass used to handle plain string load paths. This should import files from the filesystem. It should be a Class object inheriting from {Sass::Importers::Base} with a constructor that takes a single string argument (the load path). Defaults to {Sass::Importers::Filesystem}. :sourcemap: Controls how sourcemaps are generated. These sourcemaps tell the browser how to find the Sass styles that caused each CSS style to be generated. This has three valid values: :auto uses relative URIs where possible, assuming that that the source stylesheets will be made available on whatever server you're using, and that their relative location will be the same as it is on the local filesystem. If a relative URI is unavailable, a \"file:\" URI is used instead. :file always uses \"file:\" URIs, which will work locally but can't be deployed to a remote server. :inline includes the full source text in the sourcemap, which is maximally portable but can create very large sourcemap files. Finally, :none causes no sourcemaps to be generated at all. :line_numbers: When set to true, causes the line number and file where a selector is defined to be emitted into the compiled CSS as a comment. Useful for debugging, especially when using imports and mixins. This option may also be called :line_comments. Automatically disabled when using the :compressed output style or the :debug_info/:trace_selectors options. :trace_selectors: When set to true, emit a full trace of imports and mixins before each selector. This can be helpful for in-browser debugging of stylesheet imports and mixin includes. This option supersedes the :line_comments option and is superseded by the :debug_info option. Automatically disabled when using the :compressed output style. :debug_info: When set to true, causes the line number and file where a selector is defined to be emitted into the compiled CSS in a format that can be understood by the browser. Useful in conjunction with the FireSass Firebug extension for displaying the Sass filename and line number. Automatically disabled when using the :compressed output style. :custom: An option that's available for individual applications to set to make data available to {Sass::Script::Functions custom Sass functions}. :quiet: When set to true, causes warnings to be disabled. Syntax Selection The Sass command-line tool will use the file extension to determine which syntax you are using, but there's not always a filename. The sass command-line program defaults to the indented syntax but you can pass the --scss option to it if the input should be interpreted as SCSS syntax. Alternatively, you can use the scss command-line program which is exactly like the sass program but it defaults to assuming the syntax is SCSS. Encodings When running on Ruby 1.9 and later, Sass is aware of the character encoding of documents. Sass follows the CSS spec to determine the encoding of a stylesheet, and falls back to the Ruby string encoding. This means that it first checks the Unicode byte order mark, then the @charset declaration, then the Ruby string encoding. If none of these are set, it will assume the document is in UTF-8. To explicitly specify the encoding of your stylesheet, use a @charset declaration just like in CSS. Add @charset \"encoding-name\"; at the beginning of the stylesheet (before any whitespace or comments) and Sass will interpret it as the given encoding. Note that whatever encoding you use, it must be convertible to Unicode. Sass will always encode its output as UTF-8. It will include a @charset declaration if and only if the output file contains non-ASCII characters. In compressed mode, a UTF-8 byte order mark is used in place of a @charset declaration. CSS Extensions Nested Rules Sass allows CSS rules to be nested within one another. The inner rule then only applies within the outer rule's selector. For example: #main p { color: #00ff00; width: 97%; .redbox { background-color: #ff0000; color: #000000; } } is compiled to: #main p { color: #00ff00; width: 97%; } #main p .redbox { background-color: #ff0000; color: #000000; } This helps avoid repetition of parent selectors, and makes complex CSS layouts with lots of nested selectors much simpler. For example: #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } is compiled to: #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } Referencing Parent Selectors: & Sometimes it's useful to use a nested rule's parent selector in other ways than the default. For instance, you might want to have special styles for when that selector is hovered over or for when the body element has a certain class. In these cases, you can explicitly specify where the parent selector should be inserted using the & character. For example: a { font-weight: bold; text-decoration: none; &:hover { text-decoration: underline; } body.firefox & { font-weight: normal; } } is compiled to: a { font-weight: bold; text-decoration: none; } a:hover { text-decoration: underline; } body.firefox a { font-weight: normal; } & will be replaced with the parent selector as it appears in the CSS. This means that if you have a deeply nested rule, the parent selector will be fully resolved before the & is replaced. For example: #main { color: black; a { font-weight: bold; &:hover { color: red; } } } is compiled to: #main { color: black; } #main a { font-weight: bold; } #main a:hover { color: red; } & must appear at the beginning of a compound selector, but it can be followed by a suffix that will be added to the parent selector. For example: #main { color: black; &-sidebar { border: 1px solid; } } is compiled to: #main { color: black; } #main-sidebar { border: 1px solid; } If the parent selector can't have a suffix applied, Sass will throw an error. Nested Properties CSS has quite a few properties that are in \"namespaces;\" for instance, font-family, font-size, and font-weight are all in the font namespace. In CSS, if you want to set a bunch of properties in the same namespace, you have to type it out each time. Sass provides a shortcut for this: just write the namespace once, then nest each of the sub-properties within it. For example: .funky { font: { family: fantasy; size: 30em; weight: bold; } } is compiled to: .funky { font-family: fantasy; font-size: 30em; font-weight: bold; } The property namespace itself can also have a value. For example: .funky { font: 20px/24px fantasy { weight: bold; } } is compiled to: .funky { font: 20px/24px fantasy; font-weight: bold; } Placeholder Selectors: %foo Sass supports a special type of selector called a \"placeholder selector\". These look like class and id selectors, except the # or . is replaced by %. They're meant to be used with the @extend directive; for more information see @extend-Only Selectors. On their own, without any use of @extend, rulesets that use placeholder selectors will not be rendered to CSS. Comments: /* */ and // Sass supports standard multiline CSS comments with /* */, as well as single-line comments with //. The multiline comments are preserved in the CSS output where possible, while the single-line comments are removed. For example: /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } // These comments are only one line long each. // They won't appear in the CSS output, // since they use the single-line comment syntax. a { color: green; } is compiled to: /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } a { color: green; } When the first letter of a multiline comment is !, the comment will always rendered into css output even in compressed output modes. This is useful for adding Copyright notices to your generated CSS. Since multiline comments become part of the resulting CSS, interpolation within them is resolved. For example: $version: \"1.2.3\"; /* This CSS is generated by My Snazzy Framework version #{$version}. */ is compiled to: /* This CSS is generated by My Snazzy Framework version 1.2.3. */ SassScript In addition to the plain CSS property syntax, Sass supports a small set of extensions called SassScript. SassScript allows properties to use variables, arithmetic, and extra functions. SassScript can be used in any property value. SassScript can also be used to generate selectors and property names, which is useful when writing mixins. This is done via interpolation. Interactive Shell You can easily experiment with SassScript using the interactive shell. To launch the shell run the sass command-line with the -i option. At the prompt, enter any legal SassScript expression to have it evaluated and the result printed out for you: $ sass -i >> \"Hello, Sassy World!\" \"Hello, Sassy World!\" >> 1px + 1px + 1px 3px >> #777 + #777 #eeeeee >> #777 + #888 white Variables: $ The most straightforward way to use SassScript is to use variables. Variables begin with dollar signs, and are set like CSS properties: $width: 5em; You can then refer to them in properties: #main { width: $width; } Variables are only available within the level of nested selectors where they're defined. If they're defined outside of any nested selectors, they're available everywhere. They can also be defined with the !global flag, in which case they're also available everywhere. For example: #main { $width: 5em !global; width: $width; } #sidebar { width: $width; } is compiled to: #main { width: 5em; } #sidebar { width: 5em; } For historical reasons, variable names (and all other Sass identifiers) can use hyphens and underscores interchangeably. For example, if you define a variable called $main-width, you can access it as $main_width, and vice versa. Data Types SassScript supports eight data types: numbers (e.g. 1.2, 13, 10px) strings of text, with and without quotes (e.g. \"foo\", 'bar', baz) colors (e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)) booleans (e.g. true, false) nulls (e.g. null) lists of values, separated by spaces or commas (e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif) maps from one value to another (e.g. (key1: value1, key2: value2)) function references SassScript also supports all other types of CSS property value, such as Unicode ranges and !important declarations. However, it has no special handling for these types. They're treated just like unquoted strings. Strings CSS specifies two kinds of strings: those with quotes, such as \"Lucida Grande\" or 'http://sass-lang.com', and those without quotes, such as sans-serif or bold. SassScript recognizes both kinds, and in general if one kind of string is used in the Sass document, that kind of string will be used in the resulting CSS. There is one exception to this, though: when using #{} interpolation, quoted strings are unquoted. This makes it easier to use e.g. selector names in mixins. For example: @mixin firefox-message($selector) { body.firefox #{$selector}:before { content: \"Hi, Firefox users!\"; } } @include firefox-message(\".header\"); is compiled to: body.firefox .header:before { content: \"Hi, Firefox users!\"; } Lists Lists are how Sass represents the values of CSS declarations like margin: 10px 15px 0 0 or font-face: Helvetica, Arial, sans-serif. Lists are just a series of other values, separated by either spaces or commas. In fact, individual values count as lists, too: they're just lists with one item. On their own, lists don't do much, but the SassScript list functions make them useful. The {Sass::Script::Functions#nth nth function} can access items in a list, the {Sass::Script::Functions#join join function} can join multiple lists together, and the {Sass::Script::Functions#append append function} can add items to lists. The @each directive can also add styles for each item in a list. In addition to containing simple values, lists can contain other lists. For example, 1px 2px, 5px 6px is a two-item list containing the list 1px 2px and the list 5px 6px. If the inner lists have the same separator as the outer list, you'll need to use parentheses to make it clear where the inner lists start and stop. For example, (1px 2px) (5px 6px) is also a two-item list containing the list 1px 2px and the list 5px 6px. The difference is that the outer list is space-separated, where before it was comma-separated. When lists are turned into plain CSS, Sass doesn't add any parentheses, since CSS doesn't understand them. That means that (1px 2px) (5px 6px) and 1px 2px 5px 6px will look the same when they become CSS. However, they aren't the same when they're Sass: the first is a list containing two lists, while the second is a list containing four numbers. Lists can also have no items in them at all. These lists are represented as () (which is also an empty map). They can't be output directly to CSS; if you try to do e.g. font-family: (), Sass will raise an error. If a list contains empty lists or null values, as in 1px 2px () 3px or 1px 2px null 3px, the empty lists and null values will be removed before the containing list is turned into CSS. Comma-separated lists may have a trailing comma. This is especially useful because it allows you to represent a single-element list. For example, (1,) is a list containing 1 and (1 2 3,) is a comma-separated list containing a space-separated list containing 1, 2, and 3. Bracketed Lists Lists can also be written with square brackets—we call these bracketed lists. Bracketed lists containing are used as line names in CSS Grid Layout, but they can also be used in pure Sass code just like any other list. Bracketed lists can be comma- or space-separated. Maps Maps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they're syntactically similar to media query expressions: $map: (key1: value1, key2: value2, key3: value3); Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though. Like lists, maps are mostly manipulated using SassScript functions. The {Sass::Script::Functions#map-get map-get function} looks up values in a map and the {Sass::Script::Functions#map-merge map-merge function} adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created. Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. () represents both a map with no key/value pairs and a list with no elements. Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key. Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps. Colors Any CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector. First Class Functions A function reference is returned by get-function($function-name). The function can be passed to call($function, $args...) and the function it refers to will be invoked. First class functions cannot be used directly as CSS output and any attempt to do so will result in an error. Operations All types support equality operations (== and !=). In addition, each type has its own operations that it has special support for. Number Operations SassScript supports the standard arithmetic operations on numbers (addition +, subtraction -, multiplication *, division /, and modulo %). Sass math functions preserve units during arithmetic operations. This means that, just like in real life, you cannot work on numbers with incompatible units (such as adding a number with px and em) and two numbers with the same unitthat are multiplied together will produce square units (10px * 10px == 100px * px). Be Aware that px * px is an invalid CSS unit and you will get an error from Sass for attempting to use invalid units in CSS. Relational operators (, >, , >=) are also supported for numbers, and equality operators (==, !=) are supported for all types. Division and / CSS allows / to appear in property values as a way of separating numbers. Since SassScript is an extension of the CSS property syntax, it must support this, while also allowing / to be used for division. This means that by default, if two numbers are separated by / in SassScript, then they will appear that way in the resulting CSS. However, there are three situations where the / will be interpreted as division. These cover the vast majority of cases where division is actually used. They are: If the value, or any part of it, is stored in a variable or returned by a function. If the value is surrounded by parentheses, unless those parentheses are outside a list and the value is inside. If the value is used as part of another arithmetic expression. For example: p { font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division font: (italic bold 10px/8px); // In a list, parentheses don't count } is compiled to: p { font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; } If you want to use variables along with a plain CSS /, you can use #{} to insert them. For example: p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } is compiled to: p { font: 12px/30px; } Subtraction, Negative Numbers, and - There are a number of different things - can mean in CSS and in Sass. It can be a subtraction operator (as in 5px - 3px), the beginning of a negative number (as in -3px), a unary negation operator (as in -$var), or part of an identifier (as in font-weight). Most of the time, it's clear which is which, but there are some tricky cases. As a general rule, you're safest if: You always include spaces on both sides of - when subtracting. You include a space before - but not after for a negative number or a unary negation. You wrap a unary negation in parentheses if it's in a space-separated list, as in 10px (-$var). The different meanings of - take precedence in the following order: A - as part of an identifier. This means that a-1 is an unquoted string with value \"a-1\". The only exception are units; Sass normally allows any valid identifier to be used as an identifier, but identifiers may not contain a hyphen followed by a digit. This means that 5px-3px is the same as 5px - 3px. A - between two numbers with no whitespace. This indicates subtraction, so 1-2 is the same as 1 - 2. A - at the beginning of a literal number. This indicates a negative number, so 1 -2 is a list containing 1 and -2. A - between two numbers regardless of whitespace. This indicates subtraction, so 1 -$var are the same as 1 - $var. A - before a value. This indicates the unary negation operator; that is, the operator that takes a number and returns its negative. Color Operations Older versions of Sass supported arithmetic operations for color values, where they worked separately for each color channel. This means that the operation is performed on the red, green, and blue channels in turn. For example: p { color: #010203 + #040506; } computes 01 + 04 = 05, 02 + 05 = 07, and 03 + 06 = 09, and is compiled to: p { color: #050709; } However, these operations rarely corresponded with any human understandings of how colors in practice. They were deprecated and are no longer supported in recent versions of Sass. Stylesheets should use {Sass::Script::Functions color functions} instead to manipulate colors. String Operations The + operation can be used to concatenate strings: p { cursor: e + -resize; } is compiled to: p { cursor: e-resize; } Note that if a quoted string is added to an unquoted string (that is, the quoted string is to the left of the +), the result is a quoted string. Likewise, if an unquoted string is added to a quoted string (the unquoted string is to the left of the +), the result is an unquoted string. For example: p:before { content: \"Foo \" + Bar; font-family: sans- + \"serif\"; } is compiled to: p:before { content: \"Foo Bar\"; font-family: sans-serif; } By default, if two values are placed next to one another, they are concatenated with a space: p { margin: 3px + 4px auto; } is compiled to: p { margin: 7px auto; } Within a string of text, #{} style interpolation can be used to place dynamic values within the string: p:before { content: \"I ate #{5 + 10} pies!\"; } is compiled to: p:before { content: \"I ate 15 pies!\"; } Null values are treated as empty strings for string interpolation: $value: null; p:before { content: \"I ate #{$value} pies!\"; } is compiled to: p:before { content: \"I ate pies!\"; } Boolean Operations SassScript supports and, or, and not operators for boolean values. List Operations Lists don't support any special operations. Instead, they're manipulated using the list functions. Parentheses Parentheses can be used to affect the order of operations: p { width: 1em + (2em * 3); } is compiled to: p { width: 7em; } Functions SassScript defines some useful functions that are called using the normal CSS function syntax: p { color: hsl(0, 100%, 50%); } is compiled to: p { color: #ff0000; } See {Sass::Script::Functions this page} for a full list of available functions. Keyword Arguments Sass functions can also be called using explicit keyword arguments. The above example can also be written as: p { color: hsl($hue: 0, $saturation: 100%, $lightness: 50%); } While this is less concise, it can make the stylesheet easier to read. It also allows functions to present more flexible interfaces, providing many arguments without becoming difficult to call. Named arguments can be passed in any order, and arguments with default values can be omitted. Since the named arguments are variable names, underscores and dashes can be used interchangeably. See {Sass::Script::Functions} for a full listing of Sass functions and their argument names, as well as instructions on defining your own in Ruby. Interpolation: #{} You can also use SassScript variables in selectors and property names using #{} interpolation syntax: $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } is compiled to: p.foo { border-color: blue; } It's also possible to use #{} to put SassScript into property values. In most cases this isn't any better than using a variable, but using #{} does mean that any operations near it will be treated as plain CSS. For example: p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } is compiled to: p { font: 12px/30px; } & in SassScript Just like when it's used in selectors, & in SassScript refers to the current parent selector. It's a comma-separated list of space-separated lists. For example: .foo.bar .baz.bang, .bip.qux { $selector: &; } The value of $selector is now ((\".foo.bar\" \".baz.bang\"), \".bip.qux\"). The compound selectors are quoted here to indicate that they're strings, but in reality they would be unquoted. Even if the parent selector doesn't contain a comma or a space, & will always have two levels of nesting, so it can be accessed consistently. If there is no parent selector, the value of & will be null. This means you can use it in a mixin to detect whether a parent selector exists: @mixin does-parent-exist { @if & { &:hover { color: red; } } @else { a { color: red; } } } Variable Defaults: !default You can assign to variables if they aren't already assigned by adding the !default flag to the end of the value. This means that if the variable has already been assigned to, it won't be re-assigned, but if it doesn't have a value yet, it will be given one. For example: $content: \"First content\"; $content: \"Second content?\" !default; $new_content: \"First time reference\" !default; #main { content: $content; new-content: $new_content; } is compiled to: #main { content: \"First content\"; new-content: \"First time reference\"; } Variables with null values are treated as unassigned by !default: $content: null; $content: \"Non-null content\" !default; #main { content: $content; } is compiled to: #main { content: \"Non-null content\"; } @-Rules and Directives Sass supports all CSS3 @-rules, as well as some additional Sass-specific ones known as \"directives.\" These have various effects in Sass, detailed below. See also control directives and mixin directives. @import Sass extends the CSS @import rule to allow it to import SCSS and Sass files. All imported SCSS and Sass files will be merged together into a single CSS output file. In addition, any variables or mixins defined in imported files can be used in the main file. Sass looks for other Sass files in the current directory, and the Sass file directory under Rack, Rails, or Merb. Additional search directories may be specified using the :load_paths option, or the --load-path option on the command line. @import takes a filename to import. By default, it looks for a Sass file to import directly, but there are a few circumstances under which it will compile to a CSS @import rule: If the file's extension is .css. If the filename begins with http://. If the filename is a url(). If the @import has any media queries. If none of the above conditions are met and the extension is .scss or .sass, then the named Sass or SCSS file will be imported. If there is no extension, Sass will try to find a file with that name and the .scss or .sass extension and import it. For example, @import \"foo.scss\"; or @import \"foo\"; would both import the file foo.scss, whereas @import \"foo.css\"; @import \"foo\" screen; @import \"http://foo.com/bar\"; @import url(foo); would all compile to @import \"foo.css\"; @import \"foo\" screen; @import \"http://foo.com/bar\"; @import url(foo); It's also possible to import multiple files in one @import. For example: @import \"rounded-corners\", \"text-shadow\"; would import both the rounded-corners and the text-shadow files. Imports may contain #{} interpolation, but only with certain restrictions. It's not possible to dynamically import a Sass file based on a variable; interpolation is only for CSS imports. As such, it only works with url() imports. For example: $family: unquote(\"Droid+Sans\"); @import url(\"http://fonts.googleapis.com/css?family=#{$family}\"); would compile to @import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\"); Partials If you have a SCSS or Sass file that you want to import but don't want to compile to a CSS file, you can add an underscore to the beginning of the filename. This will tell Sass not to compile it to a normal CSS file. You can then import these files without using the underscore. For example, you might have _colors.scss. Then no _colors.css file would be created, and you can do @import \"colors\"; and _colors.scss would be imported. Note that you may not include a partial and a non-partial with the same name in the same directory. For example, _colors.scss may not exist alongside colors.scss. Nested @import Although most of the time it's most useful to just have @imports at the top level of the document, it is possible to include them within CSS rules and @media rules. Like a base-level @import, this includes the contents of the @imported file. However, the imported rules will be nested in the same place as the original @import. For example, if example.scss contains .example { color: red; } then #main { @import \"example\"; } would compile to #main .example { color: red; } Directives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context. It's not possible to nest @import within mixins or control directives. @media @media directives in Sass behave just like they do in plain CSS, with one extra capability: they can be nested in CSS rules. If a @media directive appears within a CSS rule, it will be bubbled up to the top level of the stylesheet, putting all the selectors on the way inside the rule. This makes it easy to add media-specific styles without having to repeat selectors or break the flow of the stylesheet. For example: .sidebar { width: 300px; @media screen and (orientation: landscape) { width: 500px; } } is compiled to: .sidebar { width: 300px; } @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @media queries can also be nested within one another. The queries will then be combined using the and operator. For example: @media screen { .sidebar { @media (orientation: landscape) { width: 500px; } } } is compiled to: @media screen and (orientation: landscape) { .sidebar { width: 500px; } } Finally, @media queries can contain SassScript expressions (including variables, functions, and operators) in place of the feature names and feature values. For example: $media: screen; $feature: -webkit-min-device-pixel-ratio; $value: 1.5; @media #{$media} and ($feature: $value) { .sidebar { width: 500px; } } is compiled to: @media screen and (-webkit-min-device-pixel-ratio: 1.5) { .sidebar { width: 500px; } } @extend There are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. The most common way of handling this is to use both the more general class and the more specific class in the HTML. For example, suppose we have a design for a normal error and also for a serious error. We might write our markup like so: Oh no! You've been hacked! And our styles like so: .error { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } Unfortunately, this means that we have to always remember to use .error with .seriousError. This is a maintenance burden, leads to tricky bugs, and can bring non-semantic style concerns into the markup. The @extend directive avoids these problems by telling Sass that one selector should inherit the styles of another selector—in other words, that all elements that match one selector should be styled as though they also match the other selector. For example: .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } is compiled to: .error, .seriousError { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } This means that all styles defined for .error are also applied to .seriousError, in addition to the styles specific to .seriousError. Think of it as a shorthand that lets you write class=\"seriousError\" instead of class=\"error seriousError\". Other rules that use .error will work for .seriousError as well. For example, if we have special styles for errors caused by hackers: .error.intrusion { background-image: url(\"/image/hacked.png\"); } Then will have the hacked.png background image as well. How it Works @extend works by inserting the extending selector (e.g. .seriousError) anywhere in the stylesheet that the extended selector (.e.g .error) appears. Thus the example above: .error { border: 1px #f00; background-color: #fdd; } .error.intrusion { background-image: url(\"/image/hacked.png\"); } .seriousError { @extend .error; border-width: 3px; } is compiled to: .error, .seriousError { border: 1px #f00; background-color: #fdd; } .error.intrusion, .seriousError.intrusion { background-image: url(\"/image/hacked.png\"); } .seriousError { border-width: 3px; } When merging selectors, @extend is smart enough to avoid unnecessary duplication, so something like .seriousError.seriousError gets translated to .seriousError. In addition, it won't produce selectors that can't match anything, like #main#footer. Multiple Extends A single selector can extend more than one selector. This means that it inherits the styles of all the extended selectors. For example: .error { border: 1px #f00; background-color: #fdd; } .attention { font-size: 3em; background-color: #ff0; } .seriousError { @extend .error; @extend .attention; border-width: 3px; } is compiled to: .error, .seriousError { border: 1px #f00; background-color: #fdd; } .attention, .seriousError { font-size: 3em; background-color: #ff0; } .seriousError { border-width: 3px; } In effect, every element with class .seriousError also has class .error and class .attention. Thus, the styles defined later in the document take precedence: .seriousError has background color #ff0 rather than #fdd, since .attention is defined later than .error. Multiple extends can also be written using a comma-separated list of selectors. For example, @extend .error, .attention is the same as @extend .error; @extend .attention. Chaining Extends It's possible for one selector to extend another selector that in turn extends a third. For example: .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } .criticalError { @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } Now everything with class .seriousError also has class .error, and everything with class .criticalError has class .seriousError and class .error. It's compiled to: .error, .seriousError, .criticalError { border: 1px #f00; background-color: #fdd; } .seriousError, .criticalError { border-width: 3px; } .criticalError { position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; } Selector Sequences Selector sequences, such as .foo .bar or .foo + .bar, currently can't be extended. However, it is possible for nested selectors themselves to use @extend. For example: #fake-links .link { @extend a; } a { color: blue; &:hover { text-decoration: underline; } } is compiled to a, #fake-links .link { color: blue; } a:hover, #fake-links .link:hover { text-decoration: underline; } Merging Selector Sequences Sometimes a selector sequence extends another selector that appears in another sequence. In this case, the two sequences need to be merged. For example: #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } While it would technically be possible to generate all selectors that could possibly match either sequence, this would make the stylesheet far too large. The simple example above, for instance, would require ten selectors. Instead, Sass generates only selectors that are likely to be useful. When the two sequences being merged have no selectors in common, then two new selectors are generated: one with the first sequence before the second, and one with the second sequence before the first. For example: #admin .tabbar a { font-weight: bold; } #demo .overview .fakelink { @extend a; } is compiled to: #admin .tabbar a, #admin .tabbar #demo .overview .fakelink, #demo .overview #admin .tabbar .fakelink { font-weight: bold; } If the two sequences do share some selectors, then those selectors will be merged together and only the differences (if any still exist) will alternate. In this example, both sequences contain the id #admin, so the resulting selectors will merge those two ids: #admin .tabbar a { font-weight: bold; } #admin .overview .fakelink { @extend a; } This is compiled to: #admin .tabbar a, #admin .tabbar .overview .fakelink, #admin .overview .tabbar .fakelink { font-weight: bold; } @extend-Only Selectors Sometimes you'll write styles for a class that you only ever want to @extend, and never want to use directly in your HTML. This is especially true when writing a Sass library, where you may provide styles for users to @extend if they need and ignore if they don't. If you use normal classes for this, you end up creating a lot of extra CSS when the stylesheets are generated, and run the risk of colliding with other classes that are being used in the HTML. That's why Sass supports \"placeholder selectors\" (for example, %foo). Placeholder selectors look like class and id selectors, except the # or . is replaced by %. They can be used anywhere a class or id could, and on their own they prevent rulesets from being rendered to CSS. For example: // This ruleset won't be rendered on its own. #context a%extreme { color: blue; font-weight: bold; font-size: 2em; } However, placeholder selectors can be extended, just like classes and ids. The extended selectors will be generated, but the base placeholder selector will not. For example: .notice { @extend %extreme; } Is compiled to: #context a.notice { color: blue; font-weight: bold; font-size: 2em; } The !optional Flag Normally when you extend a selector, it's an error if that @extend doesn't work. For example, if you write a.important {@extend .notice}, it's an error if there are no selectors that contain .notice. It's also an error if the only selector containing .notice is h1.notice, since h1 conflicts with a and so no new selector would be generated. Sometimes, though, you want to allow an @extend not to produce any new selectors. To do so, just add the !optional flag after the selector. For example: a.important { @extend .notice !optional; } @extend in Directives There are some restrictions on the use of @extend within directives such as @media. Sass is unable to make CSS rules outside of the @media block apply to selectors inside it without creating a huge amount of stylesheet bloat by copying styles all over the place. This means that if you use @extend within @media (or other CSS directives), you may only extend selectors that appear within the same directive block. For example, the following works fine: @media print { .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } } But this is an error: .error { border: 1px #f00; background-color: #fdd; } @media print { .seriousError { // INVALID EXTEND: .error is used outside of the \"@media print\" directive @extend .error; border-width: 3px; } } Someday we hope to have @extend supported natively in the browser, which will allow it to be used within @media and other directives. Extending Compound Selectors Older versions of Sass allowed compound selectors, such as .special.cool or a:hover, to be extended. Only style rules containing all simple selectors would be extended. However, this violated the rule that the elements matching the style rule should be styled as though it matched the extended selector. For example, .neat { @extend .special; } means that all elements with class=\"neat\" should be styled as though they had class=\"neat special\", so .neat { @extend .special.cool; } should mean that all elements with class=\"neat\" should be styled as though they had class=\"neat special cool\". But that's not how it actually worked. They were instead styled in a way that was impossible to achieve with pure HTML, which was inconsistent, violated guarantees that CSS usually provides, and was very expensive to implement leading to slow compile times for stylesheets with many @extends. So the old behavior was deprecated and is no longer supported in the most recent Sass releases. Most old stylesheets that extend complex selectors can be updated to extend both simple selectors individually, as in: .neat { @extend .special, .cool; } This doesn't do exactly the same thing, but it usually works. If that's not sufficient, you can use a placeholder selector to refer to both selectors at once: .special.cool { @extend %special-cool; } .neat { @extend %special-cool; } @at-root The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector: .parent { ... @at-root .child { ... } } Which would produce: .parent { ... } .child { ... } Or it can be used with a block containing multiple selectors: .parent { ... @at-root { .child1 { ... } .child2 { ... } } .step-child { ... } } Which would output the following: .parent { ... } .child1 { ... } .child2 { ... } .parent .step-child { ... } @at-root (without: ...) and @at-root (with: ...) By default, @at-root just excludes selectors. However, it's also possible to use @at-root to move outside of nested directives such as @media as well. For example: @media print { .page { width: 8in; @at-root (without: media) { color: red; } } } produces: @media print { .page { width: 8in; } } .page { color: red; } You can use @at-root (without: ...) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries. There are two special values you can pass to @at-root. \"rule\" refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules. If you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules. @debug The @debug directive prints the value of a SassScript expression to the standard error output stream. It's useful for debugging Sass files that have complicated SassScript going on. For example: @debug 10em + 12em; outputs: Line 1 DEBUG: 22em @warn The @warn directive prints the value of a SassScript expression to the standard error output stream. It's useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug: You can turn warnings off with the --quiet command-line option or the :quiet Sass option. A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning. Usage Example: @mixin adjust-location($x, $y) { @if unitless($x) { @warn \"Assuming #{$x} to be in pixels\"; $x: 1px * $x; } @if unitless($y) { @warn \"Assuming #{$y} to be in pixels\"; $y: 1px * $y; } position: relative; left: $x; top: $y; } @error The @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It's useful for validating arguments to mixins and functions. For example: @mixin adjust-location($x, $y) { @if unitless($x) { @error \"$x may not be unitless, was #{$x}.\"; } @if unitless($y) { @error \"$y may not be unitless, was #{$y}.\"; } position: relative; left: $x; top: $y; } There is currently no way to catch errors. Control Directives & Expressions SassScript supports basic control directives and expressions for including styles only under some conditions or including the same style several times with variations. Note: Control directives are an advanced feature, and are uncommon in day-to-day styling. They exist mainly for use in mixins, particularly those that are part of libraries like Compass, and so require substantial flexibility. if() The built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return -- this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero). if(true, 1px, 2px) => 1px if(false, 1px, 2px) => 2px @if The @if directive takes a SassScript expression and uses the styles nested beneath it if the expression returns anything other than false or null: p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 is compiled to: p { border: 1px solid; } You can explicitly test for $var == false or $var == null if you want to distinguish between these. The @if statement can be followed by several @else if statements and one @else statement. If the @if statement fails, the @else if statements are tried in order until one succeeds or the @else is reached. For example: $type: monster; p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; } } is compiled to: p { color: green; } @for The @for directive repeatedly outputs a set of styles. For each repetition, a counter variable is used to adjust the output. The directive has two forms: @for $var from through and @for $var from to . Note the difference in the keywords through and to. $var can be any variable name, like $i; and are SassScript expressions that should return integers. When is greater than the counter will decrement instead of increment. The @for statement sets $var to each successive number in the specified range and each time outputs the nested styles using that value of $var. For the form from ... through, the range includes the values of and , but the form from ... to runs up to but not including the value of . Using the through syntax, @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } is compiled to: .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } @each The @each directive usually has the form @each $var in . $var can be any variable name, like $length or $name, and is a SassScript expression that returns a list or a map. The @each rule sets $var to each item in the list or map, then outputs the styles it contains using that value of $var. For example: @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); } } is compiled to: .puma-icon { background-image: url('/images/puma.png'); } .sea-slug-icon { background-image: url('/images/sea-slug.png'); } .egret-icon { background-image: url('/images/egret.png'); } .salamander-icon { background-image: url('/images/salamander.png'); } Multiple Assignment The @each directive can also use multiple variables, as in @each $var1, $var2, ... in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example: @each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); border: 2px solid $color; cursor: $cursor; } } is compiled to: .puma-icon { background-image: url('/images/puma.png'); border: 2px solid black; cursor: default; } .sea-slug-icon { background-image: url('/images/sea-slug.png'); border: 2px solid blue; cursor: pointer; } .egret-icon { background-image: url('/images/egret.png'); border: 2px solid white; cursor: move; } Since maps are treated as lists of pairs, multiple assignment works with them as well. For example: @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; } } is compiled to: h1 { font-size: 2em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; } @while The @while directive takes a SassScript expression and repeatedly outputs the nested styles until the statement evaluates to false. This can be used to achieve more complex looping than the @for statement is capable of, although this is rarely necessary. For example: $i: 6; @while $i > 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } is compiled to: .item-6 { width: 12em; } .item-4 { width: 8em; } .item-2 { width: 4em; } Mixin Directives Mixins allow you to define styles that can be re-used throughout the stylesheet without needing to resort to non-semantic classes like .float-left. Mixins can also contain full CSS rules, and anything else allowed elsewhere in a Sass document. They can even take arguments which allows you to produce a wide variety of styles with very few mixins. Defining a Mixin: @mixin Mixins are defined with the @mixin directive. It's followed by the name of the mixin and optionally the arguments, and a block containing the contents of the mixin. For example, the large-text mixin is defined as follows: @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } Mixins may also contain selectors, possibly mixed with properties. The selectors can even contain parent references. For example: @mixin clearfix { display: inline-block; &:after { content: \".\"; display: block; height: 0; clear: both; visibility: hidden; } * html & { height: 1px } } For historical reasons, mixin names (and all other Sass identifiers) can use hyphens and underscores interchangeably. For example, if you define a mixin called add-column, you can include it as add_column, and vice versa. Including a Mixin: @include Mixins are included in the document with the @include directive. This takes the name of a mixin and optionally arguments to pass to it, and includes the styles defined by that mixin into the current rule. For example: .page-title { @include large-text; padding: 4px; margin-top: 10px; } is compiled to: .page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } Mixins may also be included outside of any rule (that is, at the root of the document) as long as they don't directly define any properties or use any parent references. For example: @mixin silly-links { a { color: blue; background-color: red; } } @include silly-links; is compiled to: a { color: blue; background-color: red; } Mixin definitions can also include other mixins. For example: @mixin compound { @include highlighted-background; @include header-text; } @mixin highlighted-background { background-color: #fc0; } @mixin header-text { font-size: 20px; } Mixins may include themselves. This is different than the behavior of Sass versions prior to 3.3, where mixin recursion was forbidden. Mixins that only define descendent selectors can be safely mixed into the top most level of a document. Arguments Mixins can take SassScript values as arguments, which are given when the mixin is included and made available within the mixin as variables. When defining a mixin, the arguments are written as variable names separated by commas, all in parentheses after the name. Then when including the mixin, values can be passed in in the same manner. For example: @mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue, 1in); } is compiled to: p { border-color: blue; border-width: 1in; border-style: dashed; } Mixins can also specify default values for their arguments using the normal variable-setting syntax. Then when the mixin is included, if it doesn't pass in that argument, the default value will be used instead. For example: @mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue); } h1 { @include sexy-border(blue, 2in); } is compiled to: p { border-color: blue; border-width: 1in; border-style: dashed; } h1 { border-color: blue; border-width: 2in; border-style: dashed; } Keyword Arguments in Function Mixins can also be included using explicit keyword arguments. For instance, the above example could be written as: p { @include sexy-border($color: blue); } h1 { @include sexy-border($color: blue, $width: 2in); } While this is less concise, it can make the stylesheet easier to read. It also allows functions to present more flexible interfaces, providing many arguments without becoming difficult to call. Named arguments can be passed in any order, and arguments with default values can be omitted. Since the named arguments are variable names, underscores and dashes can be used interchangeably. Trailing Commas When the last argument to a mixin or function is a positional or keyword-style argument, that argument can be followed by a trailing comma. Some prefer this coding style as it can lead to more concise diffs and fewer syntax errors when refactoring. Variable Arguments Sometimes it makes sense for a mixin or function to take an unknown number of arguments. For example, a mixin for creating box shadows might take any number of shadows as arguments. For these situations, Sass supports \"variable arguments,\" which are arguments at the end of a mixin or function declaration that take all leftover arguments and package them up as a list. These arguments look just like normal arguments, but are followed by .... For example: @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } is compiled to: .shadows { -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; } Variable arguments also contain any keyword arguments passed to the mixin or function. These can be accessed using the {Sass::Script::Functions#keywords keywords($args) function}, which returns them as a map from strings (without $) to values. Variable arguments can also be used when calling a mixin. Using the same syntax, you can expand a list of values so that each value is passed as a separate argument, or expand a map of values so that each pair is treated as a keyword argument. For example: @mixin colors($text, $background, $border) { color: $text; background-color: $background; border-color: $border; } $values: #ff0000, #00ff00, #0000ff; .primary { @include colors($values...); } $value-map: (text: #00ff00, background: #0000ff, border: #ff0000); .secondary { @include colors($value-map...); } is compiled to: .primary { color: #ff0000; background-color: #00ff00; border-color: #0000ff; } .secondary { color: #00ff00; background-color: #0000ff; border-color: #ff0000; } You can pass both an argument list and a map as long as the list comes before the map, as in @include colors($values..., $map...). You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do, keyword arguments will get directly passed through to the wrapped mixin. For example: @mixin wrapped-stylish-mixin($args...) { font-weight: bold; @include stylish-mixin($args...); } .stylish { // The $width argument will get passed on to \"stylish-mixin\" as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px); } Passing Content Blocks to a Mixin It is possible to pass a block of styles to the mixin for placement within the styles included by the mixin. The styles will appear at the location of any @content directives found within the mixin. This makes it possible to define abstractions relating to the construction of selectors and directives. For example: @mixin apply-to-ie6-only { * html { @content; } } @include apply-to-ie6-only { #logo { background-image: url(/logo.gif); } } Generates: * html #logo { background-image: url(/logo.gif); } The same mixins can be done in the .sass shorthand syntax: =apply-to-ie6-only * html @content +apply-to-ie6-only #logo background-image: url(/logo.gif) Note: when the @content directive is specified more than once or in a loop, the style block will be duplicated with each invocation. Some mixins may require a passed content block or may have different behavior depending on whether a content block was passed. The content-exists() function will return true when a content block is passed to the current mixin and can be used to implement such behaviors. Variable Scope and Content Blocks The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value: $color: white; @mixin colors($color: blue) { background-color: $color; @content; border-color: $color; } .colors { @include colors { color: $color; } } Compiles to: .colors { background-color: blue; color: white; border-color: blue; } Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example: #sidebar { $sidebar-width: 300px; width: $sidebar-width; @include smartphone { width: $sidebar-width / 3; } } Function Directives It is possible to define your own functions in sass and use them in any value or script context. For example: $grid-width: 40px; $gutter-width: 10px; @function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width; } #sidebar { width: grid-width(5); } Becomes: #sidebar { width: 240px; } As you can see functions can access any globally defined variables as well as accept arguments just like a mixin. A function may have several statements contained within it, and you must call @return to set the return value of the function. As with mixins, you can call Sass-defined functions using keyword arguments. In the above example we could have called the function like this: #sidebar { width: grid-width($n: 5); } It is recommended that you prefix your functions to avoid naming conflicts and so that readers of your stylesheets know they are not part of Sass or CSS. For example, if you work for ACME Corp, you might have named the function above -acme-grid-width. User-defined functions also support variable arguments in the same way as mixins. For historical reasons, function names (and all other Sass identifiers) can use hyphens and underscores interchangeably. For example, if you define a function called grid-width, you can use it as grid_width, and vice versa. Output Style Although the default CSS style that Sass outputs is very nice and reflects the structure of the document, tastes and needs vary and so Sass supports several other styles. Sass allows you to choose between four different output styles by setting the :style option or using the --style command-line flag. :nested Nested style is the default Sass style, because it reflects the structure of the CSS styles and the HTML document they're styling. Each property has its own line, but the indentation isn't constant. Each rule is indented based on how deeply it's nested. For example: #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } Nested style is very useful when looking at large CSS files: it allows you to easily grasp the structure of the file without actually reading anything. :expanded Expanded is a more typical human-made CSS style, with each property and rule taking up one line. Properties are indented within the rules, but the rules aren't indented in any special way. For example: #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } :compact Compact style takes up less space than Nested or Expanded. It also draws the focus more to the selectors than to their properties. Each CSS rule takes up only one line, with every property defined on that line. Nested rules are placed next to each other with no newline, while separate groups of rules have newlines between them. For example: #main { color: #fff; background-color: #000; } #main p { width: 10em; } .huge { font-size: 10em; font-weight: bold; text-decoration: underline; } :compressed Compressed style takes up the minimum amount of space possible, having no whitespace except that necessary to separate selectors and a newline at the end of the file. It also includes some other minor compressions, such as choosing the smallest representation for colors. It's not meant to be human-readable. For example: #main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline} Extending Sass Sass provides a number of advanced customizations for users with unique requirements. Using these features requires a strong understanding of Ruby. Defining Custom Sass Functions Users can define their own Sass functions using the Ruby API. For more information, see the source documentation. Cache Stores Sass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by :cache_location. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the:cache_store option. For details on creating your own cache store, please see the {Sass::CacheStores::Base source documentation}. Custom Importers Sass importers are in charge of taking paths passed to @import and finding the appropriate Sass code for those paths. By default, this code is loaded from the {Sass::Importers::Filesystem filesystem}, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects. Each importer is in charge of a single load path (or whatever the corresponding notion is for the backend). Importers can be placed in the {file:SASS_REFERENCE.md#load_paths-option :load_paths array} alongside normal filesystem paths. When resolving an @import, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used. User-created importers must inherit from {Sass::Importers::Base}. © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/frameworks/electronBasicNotes.html":{"url":"programming/web/frameworks/electronBasicNotes.html","title":"Electron Basic Notes","keywords":"","body":"Electron Basic Notes Electron Basic Notes Getting Started Basic Concepts Process Shared Data Process Communication Main to Render Render to Main Render to Render Native UI Menu Application Menu Contextual Menu Dialog Electron Security Electron Builder Electron Cheatsheet Getting Started Electron Forge Boilerplate npm install -g electron-forge electron-forge init my-new-project --template=react cd my-new-project electron-forge start Basic Concepts Process 主进程通过实例化 BrowserWindow，每个 BrowserWindow 实例都在它自己的渲染进程内返回一个 web 页面。 当 BrowserWindow 实例销毁时，相应的渲染进程也会终止。 主进程负责掌管所有的 web 页面和它们相应的渲染进程。 每个渲染进程都是相互独立的，它们只关心自己所运行的 web 页面。 在页面（渲染进程）中不允许调用原生 GUI 相关的 API，那是因为在网页（渲染进程）中中掌管原生 GUI 很危险，易造成内存泄露。 如果想在网页中进行 GUI 的操作，渲染进程必须向主进程传达请求，然后在主进程中完成操作。 在 Electron 中，有几种连接主进程和渲染进程的方法， 例如用于传送消息的 ipcRenderer 和 ipcMain 模块，以及用于 RPC 的 remote 模块. Shared Data Web Storage API IndexedDB Electron IPC // main process global.sharedObject = { someProperty: 'default value' }; // render process 1 require('remote').getGlobal('sharedObject').someProperty = 'new value'; // render process 2 console.log(require('remote').getGlobal('sharedObject').someProperty); Process Communication Main to Render webContents.executeJavaScript ipcRenderer ipcMain Render to Main remote module const { BrowserWindow } = require('electron').remote; let win = new BrowserWindow({ width: 800, height: 600 }); win.loadURL('https://github.com'); Render to Render Web Storage API IndexedDB Electron IPC e.g remote.getGlobal Native UI Menu Application Menu Contextual Menu Dialog openFile openDirectory multiSelections createDirectory showHiddenFiles promptToCreate (Windows Only) Electron Security only load secure content (HTTPS/WSS/FTPS) verify integrity of scripts via CSP and SRI don't trust external resources disable nodejs in renderers that display remote content let win; const createBrowserWindow = () => { win = new BrowserWindow({ width: 800, height: 600, title: 'Electron App', webPreferences: { nodeIntegration: false, preload: path.join(__dirname, 'preload.js'); } }); }; // preload.js const fs = require('fs'); global.desktop = { files: () => fs.readdirSync(__dirname); } Electron Builder Electron Cheatsheet Awesome Live Cheatsheet Electron API Demo App © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/frameworks/jQueryBasicNotes.html":{"url":"programming/web/frameworks/jQueryBasicNotes.html","title":"J Query Basic Notes","keywords":"","body":"JQuery JQuery Callbacks Queue Deferred Queue Sizzle Selector Engine DOM Module DOM Internal structure class style Events Module Events Internal Mouse Keyboard Form Document/Window 常用多态函数 window Ajax Module $.getJSON $.ajax Animation Module Tween Object Callbacks Queue callback queue use Observer pattern to add callbacks to callback queue, fire callbacks when events happen. function Callbacks(options) { let list = []; const self; self = { add(fn) { if (options == 'unique') { if (-1 === list.indexOf(fn)) { list.push(fn) } } else { list.push(fn) } }, fire(args) { list.forEach((fn) => { fn(args); }); if (options === 'once') { list = undefined; } }, }; return self; } Deferred Queue Same to Promise class Promise { // `executor` takes 2 parameters, `resolve()` and `reject()`. The executor // function is responsible for calling `resolve()` or `reject()` to say that // the async operation succeeded (resolved) or failed (rejected). constructor(executor) { if (typeof executor !== 'function') { throw new Error('Executor must be a function'); } // Internal state. `$state` is the state of the promise, and `$chained` is // an array of the functions we need to call once this promise is settled. this.$state = 'PENDING'; this.$chained = []; // Implement `resolve()` and `reject()` for the executor function to use const resolve = res => { // A promise is considered \"settled\" when it is no longer // pending, that is, when either `resolve()` or `reject()` // was called once. Calling `resolve()` or `reject()` twice // or calling `reject()` after `resolve()` was already called // are no-ops. if (this.$state !== 'PENDING') { return; } // If `res` is a \"thenable\", lock in this promise to match the // resolved or rejected state of the thenable. const then = res != null ? res.then : null; if (typeof then === 'function') { // In this case, the promise is \"resolved\", but still in the 'PENDING' // state. This is what the ES6 spec means when it says \"A resolved promise // may be pending, fulfilled or rejected\" in // http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects return then(resolve, reject); } this.$state = 'FULFILLED'; this.$internalValue = res; // If somebody called `.then()` while this promise was pending, need // to call their `onFulfilled()` function for (const { onFulfilled } of this.$chained) { onFulfilled(res); } return res; }; const reject = err => { if (this.$state !== 'PENDING') { return; } this.$state = 'REJECTED'; this.$internalValue = err; for (const { onRejected } of this.$chained) { onRejected(err); } }; // Call the executor function with `resolve()` and `reject()` as in the spec. try { // If the executor function throws a sync exception, we consider that // a rejection. Keep in mind that, since `resolve()` or `reject()` can // only be called once, a function that synchronously calls `resolve()` // and then throws will lead to a fulfilled promise and a swallowed error executor(resolve, reject); } catch (err) { reject(err); } } // `onFulfilled` is called if the promise is fulfilled, and `onRejected` // if the promise is rejected. For now, you can think of 'fulfilled' and // 'resolved' as the same thing. then(onFulfilled, onRejected) { return new Promise((resolve, reject) => { // Ensure that errors in `onFulfilled()` and `onRejected()` reject the // returned promise, otherwise they'll crash the process. Also, ensure // that the promise const _onFulfilled = res => { try { // If `onFulfilled()` returns a promise, trust `resolve()` to handle // it correctly. // store new value to new Promise resolve(onFulfilled(res)); } catch (err) { reject(err); } }; const _onRejected = err => { try { // store new value to new Promise reject(onRejected(err)); } catch (_err) { reject(_err); } }; if (this.$state === 'FULFILLED') { _onFulfilled(this.$internalValue); } else if (this.$state === 'REJECTED') { _onRejected(this.$internalValue); } else { this.$chained.push({ onFulfilled: _onFulfilled, onRejected: _onRejected }); } }); } catch(onRejected) { return this.then(null, onRejected); } } Sizzle Selector Engine runtime tokenizer and parser api from querySelectorAll DOM Module DOM Internal createDocumentFragment: 多次使用节点方法(如：appendChild)绘制页面，每次都要刷新页面一次。 使用 document_createDocumentFragment()创建一个文档碎片，把所有的新结点附加在其上， 然后把文档碎片的内容一次性添加到 document 中，提升性能 function domManip(parentEles, target, callback) { const fragment = buildFragment([target], parentEles); callback.call(parentEles); } ... after() { return this.domManip(arguments, function (elem) { this.parentNode.insertBefore(elem, this.nextSibling); }); } structure $('selector').html('tag+text'); $('selector').text('text'); $('selector').clone(); $('selector').remove(); $('selector').appendTo('selector'); $('selector').parent(); $('selector').children(); $('selector').index(); class $('selector').addClass(''); $('selector').removeClass(''); hidden; style $('selector').css('color', 'red'); $('selector').prop('disable', 'true'); Events Module Events Internal 通过 on 绑定事件，分析传递的数据，加工变成 add 能够识别的数据 通过 add 把数据整理放到数据缓存中保存，通过 addEventListener 绑定事件 触发事件执行 addEventListener 回调 dispatch 方法 修正事件对象存在的问题，通过 fix 生成一个可写的事件对象 引入 handlers 把委托和原生事件（例如\"click\"）绑定区分对待 执行数据缓存的事件回调，传入内部产生的事件对象 Mouse click dblclick mouseenter mouseleave Keyboard keypress keydown keyup Form submit change focus blur Document/Window load resize scroll unload 常用多态函数 data、html、css $(document).ready(function(){}); window $(window).scroll(function(event) {}); $(document).height(); //返回整个网页的高度 $(window).height(); //返回窗口高度 $(window).scrollTop(); //返回滚动条距网页顶部距离 Ajax Module $.getJSON $.getJSON(url, data, success(data, status, xhr)); $.getJSON('test.js', function(json) { alert('JSON Data: ' + json.users[3].name); }); $.ajax $.ajax({ url: 'http://localhost:3000', type: 'GET'/'POST'/'PUT'/'DELETE', data: dataSchema, dataType: 'json' success: successCallback, error: errorHandle, }); Animation Module 通过多个 animate 方法形成动画链，那么这个动画链其实都是会加入到 queue 队列里面 在每一次 queue 方法中会把动画数据写到队列中，然后取出队列中的第一个序列通过 dequeue 方法执行 开始执行之前写一个进程锁“inprogress”到 queue 里面，代表这个动画还在执行中， 防止同个序列的多个动画重复执行，这个就是异步执行同步收集的处理方案 此时动画开始了，这里注意动画是在异步执行的同步的代码，继续调用下一个 animate 执行同样的 animate 方法逻辑但是此时问题来了， 动画可能还在执行可是后续的 animate 还在继续调用，所以这个时候后面的动画代码就需要等待了（进程锁） 队列头是有一把“inprogress”进程锁的，那么这时候动画只需要加入队列， 但是可以通过 inprogress 是否存在来判断是否执行 所有的 animate 方法在加入队列都是按照以上的逻辑依次执行， 动画执行完毕了就会有一个结束通知，然后从 queue 取出第一个队列继续执行了，如此循环 Tween Object 通过一个 Tween 类构造出来的缓动对象，其实就是针对每一个属性的封装对象， 这样我们只需要设计一个定时器，在指定的时间内调用 Tween 生成的这些对象就可以了， Tween 内部控制着各自属性的状态改变。 具体右边的实现代码涉及了如下几个部分了： Animation 函数，入口函数用来做一些参数的初始化工作，整个动画的开始调度 animation 对象就是实际的动画对象了，通过 Animation 函数创建，这个对象上实现了所有属性与方法 new Tween() 通过 Tween 创建每一个属性对象相关的数据 animation.tweens 保存了每一个属性对象的容器 Animation.fx 就是具体开始动画执行的调用的一个调度对象了 定时器都是执行一个回调函数的，tick 就是定时器执行的回调， tick 函数中通过计算出变化数据，然后通过循环 animation.tweens 中的每一个动画属性对象，来实现改变 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/html/htmlBasicNotes.html":{"url":"programming/web/html/htmlBasicNotes.html","title":"Html Basic Notes","keywords":"","body":"HTML5 Basic Notes HTML5 Basic Notes Emmet 嵌套操作 属性操作 字符操作 缺省元素 Structure section header footer hgroup nav main address aside blockquote pre Head Tag Favicon Form validate novalidate 表单元素共有属性 form=form_name formaction=target_name formmethod=post/get formenctype formtarget formnovalidate autofocus required labels 隐式 control 属性 input type text radio checkbox search tel url email date/month/week/time/datetime-local indeterminate list && autocomplete pattern validity output textarea maxlength cols wrap menu dialog datalist Form Demo Content details > summary | datalist datagrid 配合 autocomplete 属性 open(boolean) dl>(multi)dt + (multi)dd summary mark ins del u em strong small hr meter value min max low high optimum wbr Media figure figcaption img src alt Responsive Images a(anchor) href id/name target embed command Information time pubdate datetime Attributes dataset Global Attributes contentEditable hidden spellcheck tabindex Nginx Config Accessbility Semantic HTML Structure Access Body Access Article Access Radio Group with fieldset and legend Element Access Reference Access Text Access Button Access Image Access Audio/Source Access Figure Access Form Access Time Access Address Access Color Contrast Accesskey and Tabindex ARIA Emmet 嵌套操作 孩子 : > div>ul>li 兄弟 : + div+ul>li 上级：^ ul>li^div ul>li>a^^div 重复：* ul>li*3 分组：() div>(p>span)*2 属性操作 id:# class:. div#header+div.main+div#footer 属性值:[] a[title=test target=_self] 数列值：$ p.item$*3 p.item$$*3 数列操作符：@ p.item$@-*3 @- = -1 p.item$@3*3 @3 = 从3开始3次 p.item$@-3*3 @-3 = 3次后到3结束 字符操作 字符操作：{} a{click} click a>{click}+span{me} clickme 缺省元素 .header+.footer = div.header+div.footer ul>.item*3 = ul>li.item*3 table>.row*4>.cell*3 = table>tr.row*4>td.cell*3 Structure Reference Website section 必须含有hx标题子标签 header footer not only can the page contain a header and a footer, but so can every and element hgroup nav 传统导航条 侧边栏导航 页内跳转 翻页操作 main 每个网页只有 1 个main元素 main不可为article、aside、header、footer、nav孩子 address 联系信息 - QQ、住址、电子邮箱、主页链接 aside 名词解释的附属部分/友情链接/广告 blockquote 长文本引用 pre 代码段 Head Tag Meta data list in HEAD. Favicon Theme Color MDN Introduction HTML Specification Form Form Design Patterns 这是分区的标题 选择照片按钮 这是分区的标题 选择尺寸： 5寸 富士，单选第一个 == 提交 == 重置 配送方式 快递 EMS 平邮 意见反馈,多行文本框 validate Complete Guide for Form Validation Complete Guide for Constraint Validation novalidate 关闭表单的提交验证 表单元素共有属性 form=form_name 使表单元素可放置于表单之外 formaction=target_name 使表单元素可提交到不同页面 formmethod=post/get 使表单元素以不同的方式提交 formenctype 默认值：application/x-www-form-urlencoded 提交前编码所有字符 multipart/form-data 不编码字符，上传控件表单元素必须使用改值 text/plain 表单元素数据中的空格->+ formtarget 定义表单提交后加载页面打开方式 blank 在新窗口中打开被链接文档 self 默认:在相同的框架中打开被链接文档 parent 在父框架集中打开被链接文档 top 在整个窗口中打开被链接文档 framename 在指定的框架中打开被链接文档 formnovalidate 取消表单元素的提交验证 将 submit 元素的 formnovalidate 属性值为 true，使整个表单提交验证失效，实现加提交； 进而弹出再次确认按钮(真提交)。 autofocus required labels 指定表单元素的标签 OS : 隐式 control 属性 javascript tips：通过 control 属性改变标签对应表单元素的值 var textbox = $('#label_id').control; textbox.value = '666666'; // 等同于 input.value = '666666'; input type text radio name 相同时, 多个 radio 组成一个 radio group checkbox search 搜索条 tel 电话号码 - 无输入检查 url email date/month/week/time/datetime-local stepUp(); stepDown(); input.valueAsNumber input.valueAsDate indeterminate javascript tips：检查 type=checkbox 的状态 if (checkbox.indeterminate) { } else { if (checkbox.checked) { } else { } } list && autocomplete 为输入框指定智能提示数据 pattern 通过正则表达式指定输入格式 validity 返回 ValidityState 对象，拥有 ValidityState.valid 属性 output input 元素的镜像元素 textarea maxlength cols 每行可显示字符最大数 wrap hard:换行时加入换行标志，此时必须指定cols属性 soft:不加入换行标志 menu dialog datalist style=\"display: none\"; Windows Mac OS Linux Form Demo Sign Up Form Your basic info Name Email Password Age: Under 16 16 or Older Your profile Biography Select Courses Computer Science Engineering Electrical Engineering Mechanical Engineering Civil Engineering Chemical Engineering Finance Management Technology Management Marketing Management Business Administration Interests: Engineering Business Law Submit Content details > summary | datalist Attr - datagrid 配合 autocomplete 属性 open(boolean) 默认 open=false dl>(multi)dt + (multi)dd defined list>defined tab + defined data summary 折叠/收缩时触发 toggle 事件 mark 突出/高亮显示，无关原文作者 ins insert text del delete text u underline text em 原文作者文章重点 strong 原文作者段落强调 small 免责声明、注意事项、法律规定、版权声明 不改变文字样式 hr 下划线 value/max 百分比 meter value min max low high optimum wbr 软换行 Media figure 流内容 如代码、文件、图片、音频、视频 figcaption figure 可拥有唯一的 0/1 个 figcaption figure_title img Attr - src alt (图片崩溃时文本)、title(提示信息)、class(CSS 类选择器) Responsive Images a(anchor) Attr - href 超链接指向--超链接/#id/#name id/name 当前锚点标识 target 定义被链接文档出现方式 blank 在新窗口中打开被链接文档 self 默认:在相同的框架中打开被链接文档 parent 在父框架集中打开被链接文档 top 在整个窗口中打开被链接文档 framename 在指定的框架中打开被链接文档 embed 插入媒体流 command Information time pubdate boolean 代表当前表示整个网页的时间 datetime T 分隔日期与时间 Z 使用 UTC 标准时间 + 时差 Attributes dataset const onChange = event => { const { currentTarget: { dataset: { row, column } } } = event; }; Global Attributes contentEditable -boolean hidden boolean spellcheck boolean tabindex -1: 编程可获得焦点，tab 键不可获得焦点 Nginx Config 子域名设置: sudo mkdir -p /var/www/blog/html sudo chown -R $USER:$USER /var/www/blog/html sudo chmod -R 755 /var/www sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/blog # change 'root' and 'server_name' config, remove 'default_server' config sudo vim /etc/nginx/sites-available/blog sudo ln -s /etc/nginx/sites-available/blog /etc/nginx/sites-enabled/ sudo nginx -t sudo systemctl restart nginx Accessbility 不要将颜色作为传达信息的唯一手段 (色盲/弱) 确保文本与其背景保持足够的对比 提供输入焦点的视觉提示 注意表单 避免组件识别障碍 Semantic HTML Definitive Guide Semantic HTML Presentation Structure Access header main footer section article nav aside Body Access Article Access The element is used to represent a fully self-contained region of content Why you should buy more cheeses than you currently do Part 1: Variety is spicy Part 2: Cows are great Radio Group with fieldset and legend Choose one of these three items: Choice One Choice Two Choice Three Element Access Reference Access Everytime Kenny is killed, Stan will announce Oh my God, you/they killed Kenny! . Words can be like X-rays, if you use them properly – they'll go through anything. You read and you're pierced. – Aldous Huxley, Brave New World Text Access 不要将 元素与 、 或 元素混淆: 元素表示某些重要性的文本 强调文本 元素表示某些相关性的文本 Button Access Use for clickable elements Image Access alt=\"\" Audio/Source Access src=\"\" type=\"\" Figure Access Form Access label[for] input Name: Time Access Thursday, September 15th Address Access Contact us! us@example.com 123 Main St., Suite 404 Yourtown, AK, 12345 United States of America Color Contrast more than 4.5:1 ratio Accesskey and Tabindex document.addEventListener('keyup', (event) => { switch (event.keyCode) { // escape case 27: // exit break; // enter || spacebar case 13 || 32: // submit or something break; // left arrow case 37: // move back / previous break; // right arrow case 39: // move forward break; // up arrow case 38: // move up break; // down arrow case 40: // move down break; } } /** * Traps the tab key inside of the context, so the user can't accidentally get * stuck behind it. * * Note that this does not work for VoiceOver users who are navigating with * the VoiceOver commands, only for default tab actions. We would need to * implement something like the inert attribute for that (see https://github.com/WICG/inert) * @param {object} e the Event object */ export function trapTabKey(e, context) { if (e.key !== 'Tab') return; let focusableItems = getFocusable(context); let focusedItem = document.activeElement; let focusedItemIndex = focusableItems.indexOf(focusedItem); if (e.shiftKey) { if (focusedItemIndex == 0) { focusableItems[focusableItems.length - 1].focus(); e.preventDefault(); } } else { if (focusedItemIndex == focusableItems.length - 1) { focusableItems[0].focus(); e.preventDefault(); } } } ARIA Web Accessibility Initiative - Accessible Rich Internet Applications: aria-label aria-labelledby=\"dropdownMenuButton\": dropdown/form aria-disabled=\"true\": disable element aria-controls=\"navbarSupportedContent\": navigation aria-expanded=\"false\": dropdown aria-haspopup=\"true\": dropdown/popup aria-current=\"pages: breadcrumb aria-valuenow/aria-valuemin/aria-valuemax: progress aria-describledBy: input + small Expand List Sample Link Sample Link 2 Sample Link 3 const listExpander = document.querySelector('.list-expander'); const list = document.querySelector('#expandable-list-1'); listExpander.addEventListener('click', e => { if (list.getAttribute('aria-expanded') === 'true') { list.setAttribute('aria-expanded', 'false'); } else { list.setAttribute('aria-expanded', 'true'); } }); © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/javascript/javascriptAdvancedNotes.html":{"url":"programming/web/javascript/javascriptAdvancedNotes.html","title":"Javascript Advanced Notes","keywords":"","body":"JavaScript Advanced Notes JavaScript Advanced Notes Modern JavaScript TC39 Babel babel-node babel-core Codemod Variable let const Destructuring(Pattern Matching) 默认值 Sample swap 简化函数的参数与返回值 解析 JSON 对象 遍历 map/list 加载特定模块 Array Iterator Style Matching Object Style Matching String Style Matching Number/Boolean Style Matching Function Arguments Style Matching String Methods Template String Tagged Templates RegExp RegExp Group Number Internationalization Number Intl String Intl Time Intl Array Array.includes Array.from Array.copyWithin Array.find Array.flat Array.flatMap Array.map Array.filter Array.reduce Array.sort Spread Array New Object API Arrow Function Modules Class 语法糖 Map WeakMap Symbol Iterator Synchronous Iterator Asynchronous Iterator Generator Basic Usage Complex Usage Asynchronous Generator Proxy and Reflect Default Zero Value with Proxy Negative Array Indice with Proxy Hiding Properties with Proxy Read Only Object with Proxy Range Judgement with Proxy Functional JavaScript Pros Cons Closure 闭包函数的结构 Partial Application Currying Internal JavaScript Variables Lifecycle Exection Context Global Exection Context Function Exection Context Event Loop Browser Internal Browser Process Render Engine HTML Parser CSS Parser Layout Paint Effective JavaScript Memory Leak 禁用特性 局部变量/函数参数 字符串 函数 作用域链 循环 倒序循环可提升性能 Duff's Device(达夫设备) Exception Call Stack Overflow Event Delegate(事件委托) 缓存模式 加载脚本 延迟加载 动态加载 DOM Performance 重排与重绘 批量修改 DOM requestAnimationFrame CSS 定时器(防止脚本阻塞) 计时器 Web Worker 运行环境 Web Worker Loader worker 实例 Ajax 数据格式 Ajax 缓存 Reduce Repeat Manipulation Debounce and Throttle RequestAnimationFrame Throttling First Paint Time 算数逻辑运算 位操作 Math 对象 Browser Performance Browser Caches HTTP Cache Code Caching Browser Pefermance Monitoring 合成监控 真实用户监控 对比 方案 使用标准的 API 定义合适的指标 上报关联的维度 Speed Tools Data Format and Size Images Format Images Compression Images Scaling Data Loading Data Preloading Images Lazy Loading JavaScript Lazy Loading Prefetch Babel Config for JavaScript V8 Good Parts Object Shape Inline Cache V8 Perf Tools Awesome V8 Performance Tutorial Perf and Analysis Tools Inspect Android Device Performance Best Practice Testing and Debugging Log Log Clock Headless Testing Browser Context DOM Testing Event Testing Operation Simulation Testing Tracing Testing Other Puppeterr Testing API Frameworks Unit 测试 UI 测试 可测试代码 范例 圈复杂度 函数复杂度 扇出(引用) 扇入(被引用) 耦合度 内容耦合(5) 公共耦合(4) 控制耦合(3) 印记耦合(2) 数据耦合(1) 无耦合(0) 单元测试 测试原则 隔离被测代码 mock/stub/spy Monkey Patch Tools API console API JS API Trace Property (Vue Internal) Node API Browser Compatibility 特性检测 Chrome Dev Tools Shortcuts Elements Panel Style Tab Console Panel Console Settings capture default eventListener Source Panel Network Panel Performance Panel Simulation DevTools Testing DevTools Memory Panel JS Profiler Panel Layer Panel Rendering Panel More Tools JavaScript Style Guide Naming Style Variable Style Object Style Array Style Destruct Style String Style Function Style Arrow Function Style Module Style Iterator and Generator Style Expression Style 换行 Style 空格 Style 注释 Style 模块 对象 属性 方法/函数 SSR SEO SEO Tutorials SEO Tips SEO Metadata PWA Service Worker SW Pros SW Costs SW Demo SW for Broken Images PWA Library PWA Tutorials HTTP/2 Security Content Security Policy Level 3 Trusted Types CSRF Object Property Sandbox User Fingerprint HTTP Protocol HTTP 2 HTTP 3 DevOps Static Assets CI System Release System Blue Green Deployment Rolling Update Gray Release Gray Release Introduction Gray Release Solution Gray Release Performance Modern JavaScript TC39 New Feature Process Babel babel example.js -o compiled.js babel src -d lib -s babel-node A read-eval-print loop(REPL) can replace node REPL. babel-core 提供 babel 转码 API npm install babel-core --save const babel = require('babel-core'); // 字符串转码 babel.transform('code();', options); // => { code, map, ast } // 文件转码（异步） babel.transformFile('filename.js', options, function (err, result) { result; // => { code, map, ast } }); // 文件转码（同步） babel.transformFileSync('filename.js', options); // => { code, map, ast } // Babel AST转码 babel.transformFromAst(ast, code, options); // => { code, map, ast } Codemod Use Babel to refactor code, like jscodeshift. Variable 一方面规定, var/function 声明的全局变量, 依旧是全局对象的属性, 意味着会Hoisting. 另一方面规定, let/const/class 声明的全局变量, 不属于全局对象的属性, 意味着不会Hoisting. let 块级作用域内定义的变量/函数，在块级作用域外 ReferenceError 不存在变量提升, 导致暂时性死区 (Temporal Dead Zone) let variable in for-loop closure, every closure for each loop binds the block-scoped variable. const a = 1; b = 3; // temporal dead zone: throw reference error let b = 2; const const 一旦声明变量，就必须立即初始化，不能留到以后赋值 引用一个Reference变量时，只表示此变量地址不可变，但所引用变量的值/属性可变 (xxx * const, 即const指针, 指向一个变量) 不存在变量提升, 导致暂时性死区 (Temporal Dead Zone) 块级作用域 Destructuring(Pattern Matching) 建议只要有可能，就不要在模式中放置圆括号 赋值语句的非模式部分，可以使用圆括号 默认值 ES6 内部使用严格相等运算符（===），判断一个位置是否有值。若此位置无值，则使用默认值 如果一个数组成员不严格等于 undefined，默认值不会生效 const [x = 1] = [undefined]; x; // 1 const [x = 1] = [null]; x; // null let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError Sample swap [x, y] = [y, x]; 简化函数的参数与返回值 可用于工厂(factory)/设置(options)模式: 传参一般为 options 对象，具有固定的属性名 一次性定义多个参数 一次性定义多个参数的默认值 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]) // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}) // 可省略 var foo = config.foo || 'default foo'; jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config }) { // ... do stuff }; // 返回一个数组 function example() { return [1, 2, 3]; } const [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2, }; } const { foo, bar } = example(); 解析 JSON 对象 const jsonData = { id: 42, status: 'OK', data: [867, 5309], }; const { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] 遍历 map/list const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + ' is ' + value); } // first is hello // second is world // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [, value] of map) { // ... } 加载特定模块 const { SourceMapConsumer, SourceNode } = require('source-map'); Array Iterator Style Matching 等号右边必须为数组等实现了 Iterator 接口的对象,否则报错 Array Set Generator 函数 const [foo, [[bar], baz]] = [1, [[2], 3]]; foo; // 1 bar; // 2 baz; // 3 const [, , third] = ['foo', 'bar', 'baz']; third; // \"baz\" const [x, , y] = [1, 2, 3]; x; // 1 y; // 3 const [head, ...tail] = [1, 2, 3, 4]; head; // 1 tail; // [2, 3, 4] const [x, y, ...z] = ['a']; x; // \"a\" y; // undefined z; // [] // Generator 函数 function* fibs() { var a = 0; var b = 1; while (true) { yield a; [a, b] = [b, a + b]; } } const [first, second, third, fourth, fifth, sixth] = fibs(); sixth; // 5 Object Style Matching 真正被赋值的是后者，而不是前者 const { pattern: variable } = { key: value }; 解构赋值的规则: 只要等号右边的值不是对象，就先将其转为对象 undefined/null 无法转化为对象 const { prop: x } = undefined; // TypeError const { prop: y } = null; // TypeError const { bar, foo } = { foo: 'aaa', bar: 'bbb' }; foo; // \"aaa\" bar; // \"bbb\" const { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }; const { baz } = { foo: 'aaa', bar: 'bbb' }; baz; // undefined const { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz; // \"aaa\" const obj = { first: 'hello', last: 'world' }; const { first: f, last: l } = obj; f; // 'hello' l; // 'world' const { log, sin, cos } = Math; String Style Matching const [a, b, c, d, e] = 'hello'; a; // \"h\" b; // \"e\" c; // \"l\" d; // \"l\" e; // \"o\" let { length: len } = 'hello'; len; // 5 Number/Boolean Style Matching number/boolean 会转化成对象 let { toString: s } = 123; s === Number.prototype.toString; // true let { toString: s } = true; s === Boolean.prototype.toString; // true Function Arguments Style Matching function add([x, y]) { return x + y; } add([1, 2]) // 3 [([1, 2], [3, 4])].map(([a, b]) => a + b); // [ 3, 7 ] function move({ x = 0, y = 0 } = {}) { return [x, y]; } move({ x: 3, y: 8 }); // [3, 8] move({ x: 3 }); // [3, 0] move({}); // [0, 0] move(); // [0, 0] // 严格为 undefined 时，触发默认值设置 [1, undefined, 3].map((x = 'yes') => x); // [ 1, 'yes', 3 ] String 'z' === 'z'; // true '\\172' === 'z'; // true '\\x7A' === 'z'; // true '\\u007A' === 'z'; // true '\\u{7A}' === 'z'; // true Methods string.codePointAt(index): 正确处理 4 字节存储字符 string.fromCodePoint(codePoint) function is32Bit(c) { return c.codePointAt(0) > 0xffff; } String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'; // true string.includes(substr)/startsWith(substr)/endsWith(substr) 使用第二个参数 n 时，endsWith 针对前 n 个字符，其他两个方法针对从第 n 个位置直到字符串结束 const s = 'Hello world!'; s.startsWith('world', 6); // true s.endsWith('Hello', 5); // true s.includes('Hello', 6); // false repeat(times) 'hello'.repeat(2); // \"hellohello\" 'na'.repeat(2.9); // \"nana\" 'na'.repeat(-0.9); // \"\" 'na'.repeat(-1); // RangeError 'na'.repeat(NaN); // \"\" 'na'.repeat(Infinity); // RangeError 'na'.repeat('na'); // \"\" 'na'.repeat('3'); // \"nanana\" padStart/padEnd(len, paddingStr) '1'.padStart(10, '0'); // \"0000000001\" '12'.padStart(10, '0'); // \"0000000012\" '123456'.padStart(10, '0'); // \"0000123456\" '12'.padStart(10, 'YYYY-MM-DD'); // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD'); // \"YYYY-09-12\" Template String str 表示模板字符串 // 普通字符串 `In JavaScript '\\n' is a line-feed.``\\`Yo\\` World!``In JavaScript this is // 多行字符串 not legal.``${ x // 引用变量 } + ${y * 2} = ${x + y * 2}``${obj.x + obj.y}``foo ${ fn() // 调用函数 } bar`; Tagged Templates const boldify = (parts, ...insertedParts) => { return parts .map((s, i) => { if (i === insertedParts.length) return s; return `${s}${insertedParts[i]}`; }) .join(''); }; const name = 'Jamon Holmgren'; console.log(boldify`Hi, my name is ${name}!`); // => \"Hi, my name is Jamon Holmgren!\" function template(strings, ...keys) { return function (...values) { const dict = values[values.length - 1] || {}; const result = [strings[0]]; keys.forEach(function (key, i) { const value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); }); return result.join(''); }; } const t1Closure = template`${0}${1}${0}!`; t1Closure('Y', 'A'); // \"YAY!\" const t2Closure = template`${0} ${'foo'}!`; t2Closure('Hello', { foo: 'World' }); // \"Hello World!\" 编译模板(小型模板引擎) function compile(template) { const evalExpr = //g; const expr = //g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; const script = `(function parse(data){ var output = \"\"; function echo(html){ output += html; } ${template} return output; })`; return script; } const template = ` `; const parse = compile(template); div.innerHTML = parse({ supplies: ['broom', 'mop', 'cleaner'] }); // => // => broom // => mop // => cleaner // => // 下面的hashTemplate函数 // 是一个自定义的模板处理函数 const libraryHtml = hashTemplate` #for book in ${myBooks} #{book.title} by #{book.author} #end `; 国际化处理 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`; // \"欢迎访问xxx，您是第xxxx位访问者！\" XSS 攻击 const message = SaferHTML`${sender} has sent you a message.`; function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i /g, '&gt;'); // Don't escape special characters in the template. s += templateData[i]; } return s; } 运行代码 jsx` ${this.state.value} `; java` class HelloWorldApp { public static void main(String[] args) { System.out.println(“Hello World!”); // Display the string. } } `; HelloWorldApp.main(); RegExp u 修饰符 y (粘连全局符) 修饰符号隐含了头部匹配的标志 function codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0; } const s = '𠮷𠮷'; s.length; // 4 codePointLength(s); // 2 RegExp Group const string = 'Favorite GitHub Repos: tc39/ecma262 v8/v8.dev'; const regex = /\\b(?[a-z0-9]+)\\/(?[a-z0-9\\.]+)\\b/g; for (const match of string.matchAll(regex)) { console.log(`${match[0]} at ${match.index} with '${match.input}'`); console.log(`owner: ${match.groups.owner}`); console.log(`repo: ${match.groups.repo}`); } Number 0bxxx/0Bxxx 0oxxx/0Oxxx Number.isFinite()/isNaN()/parseInt()/parseFloat()/isInteger()/isSafeInteger() Number.EPSILON/MAX_SAFE_INTEGER/MIN_SAFE_INTEGER ** 指数运算符 BigInt const a = 2172141653; const b = 15346349309; a * b; // => 33334444555566670000 BigInt(a) * BigInt(b); // => 33334444555566667777n Internationalization Number Intl const nfFrench = new Intl.NumberFormat('fr'); nf.format(12345678901234567890n); // => 12 345 678 901 234 567 890 String Intl const lfEnglish = new Intl.ListFormat('en'); // const lfEnglish = new Intl.ListFormat('en', { type: 'disjunction' }); => 'or' lfEnglish.format(['Ada', 'Grace', 'Ida']); // => 'Ada, Grace and Ida' Time Intl const rtfEnglish = new Intl.RelativeTimeFormat('en', { numeric: 'auto' }); rtf.format(-1, 'day'); // 'yesterday' rtf.format(0, 'day'); // 'today' rtf.format(1, 'day'); // 'tomorrow' rtf.format(-1, 'week'); // 'last week' rtf.format(0, 'week'); // 'this week' rtf.format(1, 'week'); // 'next week' const dtfEnglish = new Intl.DateTimeFormat('en', { year: 'numeric', month: 'long', day: 'numeric', }); dtfEnglish.format(new Date()); // => 'May 7, 2019' dtfEnglish.formatRange(start, end); // => 'May 7 - 9, 2019' Array [...Array(5).keys()]; // => [0, 1, 2, 3, 4] Array.includes no more indexOf() > -1 Array.from 强大的函数式方法 伪数组对象(array-like object) 可枚举对象(iterable object) 克隆数组 map 函数 // Set // Map // NodeList对象 const ps = document.querySelectorAll('p'); Array.from(ps).forEach(function (p) { console.log(p); }); // arguments对象 function foo() { const args = Array.from(arguments); // ... } Array.from('hello'); // => ['h', 'e', 'l', 'l', 'o'] const namesSet = new Set(['a', 'b']); Array.from(namesSet); // ['a', 'b'] // 克隆数组 Array.from([1, 2, 3]); // => [1, 2, 3] Array.from(arrayLike, (x) => x * x); // => Array.from(arrayLike).map((x) => x * x); Array.from([1, 2, 3], (x) => x * x); // [1, 4, 9] Array.copyWithin 替换数组元素，修改原数组 Array.prototype.copyWithin(target, (start = 0), (end = this.length)); [1, 2, 3, 4, 5].copyWithin(0, 3)[ // => [4, 5, 3, 4, 5] // -2相当于3号位，-1相当于4号位 (1, 2, 3, 4, 5) ].copyWithin(0, -2, -1); // => [4, 2, 3, 4, 5] // 将2号位到数组结束，复制到0号位 const i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // => Int32Array [3, 4, 5, 4, 5] Array.find arr.find(fn); arr.findIndex(fn); Array.flat [2, [2, 2]] => [2, 2, 2] Array.flatMap map + flat Array.map 相当于 Haskell 中的 List Map Array.filter 相当于 Haskell 中的 List Filter Array.reduce 相当于 Haskell 中的 fold Array.sort Spread Array arr2.push(...arr1); var obj = { x: 1, y: 2, z: 3 }; obj[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...obj]; // print [1, 2, 3] New Object API Object.keys() Object.values() Object.entries() const score = { jamon: 42, todd: 19, ken: 4, gant: 41, }; Object.keys(score).map((k) => score[k]); // => [ 42, 19, 4, 41 ] Object.values(score); // => [ 42, 19, 4, 41 ] Object.entries(score); /** * => * [ * [ 'jamon', 42 ], * [ 'todd', 19 ], * [ 'ken', 4 ], * [ 'gant', 41 ], * ] */ const object = { x: 42, y: 50, abc: 9001 }; const result = Object.fromEntries( Object.entries(object) .filter(([key, value]) => key.length === 1) map(([key, value]) => [key, value * 2]) ); const map = new Map(Object.entries(object)); const objectCopy = Object.fromEntries(map); Arrow Function no thisArgs binding no arguments binding no prototype binding no suited for New constructor not suited as methods of plain object (this in arrow function would be refer to window) Modules import { lastName as surname } from './profile.js'; export const firstName = 'Michael'; export const lastName = 'Jackson'; export const year = 1958; // profile.js const firstName = 'Michael'; const lastName = 'Jackson'; const year = 1958; export { firstName, lastName, year }; // 接口改名 export { foo as myFoo } from 'my_module'; // 整体输出 export * from 'my_module'; CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 CommonJS 模块输出的是一个值的拷贝, ES6 模块 Export 分 3 种情况: export default xxx输出value, export xxx输出reference. defaultThing and anotherDefaultThing shows ES6 export default value, importedThing and module.thing shows ES6 export normal reference, and Destructuring Behavior create a brand new value. function/class special case: export default function/class thing() {}; // function/class expressions export default reference, function/class thing() {}; export default thing; // function/class statements export default value. Export default value: // module.js let thing = 'initial'; export { thing }; export default thing; setTimeout(() => { thing = 'changed'; }, 500); // main.js import { thing, default as defaultThing } from './module.js'; import anotherDefaultThing from './module.js'; setTimeout(() => { console.log(thing); // \"changed\" console.log(defaultThing); // \"initial\" console.log(anotherDefaultThing); // \"initial\" }, 1000); Export normal reference: // module.js export let thing = 'initial'; setTimeout(() => { thing = 'changed'; }, 500); // main.js import { thing as importedThing } from './module.js'; const module = await import('./module.js'); let { thing } = await import('./module.js'); // Destructuring Behavior setTimeout(() => { console.log(importedThing); // \"changed\" console.log(module.thing); // \"changed\" console.log(thing); // \"initial\" }, 1000); To sum up: // These give you a live reference to the exported thing(s): import { thing } from './module.js'; import { thing as otherName } from './module.js'; import * as module from './module.js'; const module = await import('./module.js'); // This assigns the current value of the export to a new identifier: let { thing } = await import('./module.js'); // These export a live reference: export { thing }; export { thing as otherName }; export { thing as default }; export default function thing() {} // These export the current value: export default thing; export default 'hello!'; Class 语法糖 class A { constructor(value) { this.val = value; } } class B extends A { constructor(value) { super(value); } } const b = new B(6); console.log(B.__proto__ === A); console.log(B.prototype.constructor === B); console.log(B.prototype.__proto__ === A.prototype); console.log(b.__proto__ === B.prototype); function AA(value) { this.val = value; } function BB(value) { AA.call(this, value); } BB.prototype = Object.create(AA.prototype); BB.prototype.constructor = BB; const bb = new BB(6); console.log(BB.__proto__ === Function.prototype); // not consistence with class syntax console.log(BB.prototype.constructor === BB); console.log(BB.prototype.__proto__ === AA.prototype); console.log(bb.__proto__ === BB.prototype); 禁止对复合对象字面量进行导出操作 (array literal, object literal) Map const map = new Map([ // You define a map via an array of 2-element arrays. The first // element of each nested array is the key, and the 2nd is the value ['name', 'Jean-Luc Picard'], ['age', 59], ['rank', 'Captain'], ]); // To get the value associated with a given `key` in a map, you // need to call `map.get(key)`. Using `map.key` will **not** work. map.get('name'); // 'Jean-Luc Picard' const map = new Map([]); const n1 = new Number(5); const n2 = new Number(5); map.set(n1, 'One'); map.set(n2, 'Two'); // `n1` and `n2` are objects, so `n1 !== n2`. That means the map has // separate keys for `n1` and `n2`. map.get(n1); // 'One' map.get(n2); // 'Two' map.get(5); // undefined // If you were to do this with an object, `n2` would overwrite `n1` const obj = {}; obj[n1] = 'One'; obj[n2] = 'Two'; obj[n1]; // 'Two' obj[5]; // 'Two' const objectClone = new Map(Object.entries(object)); const arrayClone = new Map(Array.from(map.entries)); const map = new Map([ ['name', 'Jean-Luc Picard'], ['age', 59], ['rank', 'Captain'], ]); // The `for/of` loop can loop through iterators for (const key of map.keys()) { key; // 'name', 'age', 'rank' } for (const v of map.values()) { v; // 'Jean-Luc Picard', 59, 'Captain' } for (const [key, value] of map.entries()) { key; // 'name', 'age', 'rank' value; // 'Jean-Luc Picard', 59, 'Captain' } WeakMap WeakMap 结构与 Map 结构基本类似, 唯一的区别就是 WeakMap 只接受对象作为键名 (null 除外), 而且键名所指向的对象不计入垃圾回收机制. 它的键所对应的对象可能会在将来消失. 一个对应 DOM 元素的 WeakMap 结构, 当某个 DOM 元素被清除, 其所对应的 WeakMap 记录就会自动被移除. 有时候我们会把对象作为一个对象的键用来存放属性值, 普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收, 有造成内存泄漏的危险, 而 WeakMap/WeakSet 则更加安全些. Symbol A Symbol is a unique and immutable primitive value and may be used as the key of an Object property. Symbols don't auto-convert to \"strings\" and can't convert to numbers let arr = ['a', 'b', 'c']; let iter = arr[Symbol.iterator](); iter.next(); // { value: 'a', done: false } iter.next(); // { value: 'b', done: false } iter.next(); // { value: 'c', done: false } iter.next(); // { value: undefined, done: true } Iterator 一个数据结构只要具有 Symbol.iterator 属性 (其为 function), 就可以认为是 \"可遍历的\" (iterable) implement iterator with Symbol.iterator Synchronous Iterator const Iterable = { [Symbol.iterator]() { return Iterator; }, }; const Iterator = { next() { return IteratorResult; }, return() { return IteratorResult; }, throw(e) { throw e; }, }; const IteratorResult = { value: any, done: boolean, }; const Iterator = { next() { return IteratorResult; }, [Symbol.iterator]() { return this; }, }; function methodsIterator() { let index = 0; let methods = Object.keys(this) .filter((key) => { return typeof this[key] === 'function'; }) .map((key) => this[key]); // iterator object return { next: () => ({ // Conform to Iterator protocol done: index >= methods.length, value: methods[index++], }), }; } let myMethods = { toString: function () { return '[object myMethods]'; }, sumNumbers: function (a, b) { return a + b; }, numbers: [1, 5, 6], [Symbol.iterator]: methodsIterator, // Conform to Iterable Protocol }; for (let method of myMethods) { console.log(method); // logs methods `toString` and `sumNumbers` } Asynchronous Iterator const AsyncIterable = { [Symbol.asyncIterator]() { return AsyncIterator; }, }; const AsyncIterator = { next() { return Promise.resolve(IteratorResult); }, return() { return Promise.resolve(IteratorResult); }, throw(e) { return Promise.reject(e); }, }; const IteratorResult = { value: any, done: boolean, }; function remotePostsAsyncIteratorsFactory() { let i = 1; let done = false; const asyncIterableIterator = { // the next method will always return a Promise async next() { // do nothing if we went out-of-bounds if (done) { return Promise.resolve({ done: true, value: undefined, }); } const res = await fetch( `https://jsonplaceholder.typicode.com/posts/${i++}` ).then((r) => r.json()); // the posts source is ended if (Object.keys(res).length === 0) { done = true; return Promise.resolve({ done: true, value: undefined, }); } else { return Promise.resolve({ done: false, value: res, }); } }, [Symbol.asyncIterator]() { return this; }, }; return asyncIterableIterator; } (async () => { const ait = remotePostsAsyncIteratorsFactory(); await ait.next(); // { done:false, value:{id: 1, ...} } await ait.next(); // { done:false, value:{id: 2, ...} } await ait.next(); // { done:false, value:{id: 3, ...} } // ... await ait.next(); // { done:false, value:{id: 100, ...} } await ait.next(); // { done:true, value:undefined } })(); // tasks will run in parallel ait.next().then(...); ait.next().then(...); ait.next().then(...); Generator Synchronous Generators Basic Usage function* gen() { yield 1; yield 2; yield 3; } const g = gen(); g.next(); // { value: 1, done: false } g.next(); // { value: 2, done: false } g.next(); // { value: 3, done: false } g.next(); // { value: undefined, done: true } g.return(); // { value: undefined, done: true } g.return(1); // { value: 1, done: true } iterable object const users = { james: false, andrew: true, alexander: false, daisy: false, luke: false, clare: true, *[Symbol.iterator]() { // this === 'users' for (const key in this) { if (this[key]) yield key; } }, }; early return function* gen() { yield 1; yield 2; yield 3; } const g = gen(); g.next(); // { value: 1, done: false } g.return('foo'); // { value: \"foo\", done: true } g.next(); // { value: undefined, done: true } Complex Usage The generator function itself is not iterable, call it to get the iterable-iterator for (const v of someOddNumbers) { console.log(v); } // => TypeEror: someOddNumbers is not iterable for (const v of number()) { console.log(v); // 1 3 5 7 } messaging system function* lazyCalculator(operator) { const firstOperand = yield; const secondOperand = yield; switch (operator) { case '+': yield firstOperand + secondOperand; return; case '-': yield firstOperand - secondOperand; return; case '*': yield firstOperand * secondOperand; return; case '/': yield firstOperand / secondOperand; return; } } const g = gen('*'); g.next(); // { value: undefined, done: false } g.next(10); // { value: undefined, done: false } g.next(2); // { value: 20, done: false } g.next(); // { value: undefined, done: true } error handling function* generator() { try { yield 1; } catch (e) { console.log(e); } yield 2; yield 3; yield 4; yield 5; } const it = generator(); it.next(); // {value: 1, done: false} // the error will be handled and printed (\"Error: Handled!\"), // then the flow will continue, so we will get the // next yielded value as result. it.throw(Error('Handled!')); // {value: 2, done: false} it.next(); // {value: 3, done: false} // now the generator instance is paused on the // third yield that is not inside a try-catch. // the error will be re-thrown out it.throw(Error('Not handled!')); // !!! Uncaught Error: Not handled! !!! // now the iterator is exhausted it.next(); // {value: undefined, done: true} Generator based control flow goodness for nodejs and the browser, using promises, letting you write non-blocking code in a nice-ish way (just like tj/co). function coroutine(generatorFunc) { const generator = generatorFunc(); nextResponse(); function nextResponse(value) { const response = generator.next(value); if (response.done) { return; } if (value.then) { value.then(nextResponse); } else { nextResponse(response.value); } } } coroutine(function* bounce() { yield bounceUp; yield bounceDown; }); Asynchronous Generator const asyncSource = { async *[Symbol.asyncIterator]() { yield await new Promise((res) => setTimeout(res, 1000, 1)); }, }; async function* remotePostsAsyncGenerator() { let i = 1; while (true) { const res = await fetch( `https://jsonplaceholder.typicode.com/posts/${i++}` ).then((r) => r.json()); // when no more remote posts will be available, // it will break the infinite loop. // the async iteration will end if (Object.keys(res).length === 0) { break; } yield res; } } // do you remember it? function* chunkify(array, n) { yield array.slice(0, n); array.length > n && (yield* chunkify(array.slice(n), n)); } async function* getRemoteData() { let hasMore = true; let page; while (hasMore) { const { next_page, results } = await fetch(URL, { params: { page } }).then( (r) => r.json() ); // return 5 elements with each iteration yield* chunkify(results, 5); hasMore = next_page != null; page = next_page; } } Proxy and Reflect modify default object behavior with Proxy and Reflect // new Proxy(target, handler) Proxy(target, { set: function (target, name, value, receiver) { const success = Reflect.set(target, name, value, receiver); if (success) { log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }, }); APIs of handler: get set has apply construct ownKeys deleteProperty defineProperty isExtensible preventExtensions getPrototypeOf setPrototypeOf getOwnPropertyDescriptor Default Zero Value with Proxy const withZeroValue = (target, zeroValue = 0) => new Proxy(target, { get: (obj, prop) => (prop in obj ? obj[prop] : zeroValue), }); let pos = { x: 4, y: 19 }; console.log(pos.z); // => undefined pos = withZeroValue(pos); console.log(pos.z); // => 0 Negative Array Indice with Proxy const negativeArray = (els) => new Proxy(target, { get: (target, propKey, receiver) => Reflect.get( target, +propKey Hiding Properties with Proxy const hide = (target, prefix = '_') => new Proxy(target, { has: (obj, prop) => !prop.startsWith(prefix) && prop in obj, ownKeys: (obj) => Reflect.ownKeys(obj).filter( (prop) => typeof prop !== 'string' || !prop.startsWith(prefix) ), get: (obj, prop, rec) => (prop in rec ? obj[prop] : undefined), }); let userData = hide({ firstName: 'Tom', mediumHandle: '@tbarrasso', _favoriteRapper: 'Drake', }); '_favoriteRapper' in userData; // has: false Object.keys(userData); // ownKeys: ['firstName', 'mediumHandle'] userData._favoriteRapper; // get: undefined Read Only Object with Proxy const NOPE = () => { throw new Error('Can\\'t modify read-only object'); }; const NOPE_HANDLER = { set: NOPE, defineProperty: NOPE, deleteProperty: NOPE, deleteProperty: NOPE, preventExtensions: NOPE, setPrototypeOf: NOPE get: (obj, prop) => { if (prop in obj) { return Reflect.get(obj, prop); } throw new ReferenceError(`Unknown prop \"${prop}\"`); } }; const readOnly = target => new Proxy(target, NODE_HANDLER) Range Judgement with Proxy const range = (min, max) => new Proxy(Object.create(null), { has: (_, prop) => +prop >= min && +prop true } nums.filter((n) => n in range(1, 10)); // => [1, 5] Functional JavaScript predictable (pure and immutable) safe (pure and immutable) transparent (pure and immutable) modular (composite) Pros type safe and state safe explicit flow of data concurrency safety Cons verbose more object creation more garbage collection more memory usage With help of immutable.js, object creation/garbage collection/memory usage can be alleviated. For example, in vanilla.js, map2 === map1 become false, but in immutable.js map2 === map1 become true (copy free due to immutable data). const map1 = { 'b': 2 }; const map2 = map1.set{ 'b': 2 }; Closure Closure is a function that remembers the variables from the place where it is defined (lexical scope), regardless of where it is executed later: 函数外部不可对函数内部进行赋值或引用 函数中的闭包函数可对函数进行赋值或引用(函数对于闭包来说是外部, 即内部引用外部) 特权性质: 从外部通过闭包方法访问内部(函数作用域)局部变量 (private getter) Local Scope -> Outer Functions Scope -> Global Scope. Closure Performance: avoid unnecessary closure creation. The stale closure captures variables that have outdated values. // global scope var e = 10; function sum(a) { return function (b) { return function (c) { // outer functions scope return function (d) { // local scope return a + b + c + d + e; }; }; }; } console.log(sum(1)(2)(3)(4)); // log 20 // BAD function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function () { return this.name; }; this.getMessage = function () { return this.message; }; } // GOOD: avoid unnecessary function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function () { return this.name; }; MyObject.prototype.getMessage = function () { return this.message; }; 闭包函数的结构 优先级: this > 局部变量 > 形参 > arguments > 函数名 innerFunc() has access to outerVar from its lexical scope, even being executed outside of its lexical scope. unction outerFunc() { let outerVar = 'I am outside!'; function innerFunc() { console.log(outerVar); // => logs \"I am outside!\" } return innerFunc; } const myInnerFunc = outerFunc(); myInnerFunc(); Partial Application const partialFromBind = (fn, ...args) => { return fn.bind(null, ...args); }; const partial = (fn, ...args) => { return (...rest) => { return fn(...args, ...rest); }; }; Currying chain of multiple single argument functions const add = (x) => (y) => x + y; function schonfinkelize(fn) { const slice = Array.prototype.slice, stored_args = slice.call(arguments, 1); return function () { const new_args = slice.call(arguments), args = stored_args.concat(new_args); return fn.apply(null, args); }; } const addOne = schonfinkelize(add, 1); // addOne(3) === 4; const addFive = schonfinkelize(addOne, 1, 3); // addFive(4) === 9; Internal JavaScript Under the hood Variables Lifecycle Creation phase (Hoisting) Declaration phase: 在作用域中注册变量 Initialization phase: 分配内存, 在作用域中绑定变量 (undefined) Execution phase/Assignment phase Exection Context Global Exection Context create global object (window) create this object(refer to window) declare and initialize variable(undefined)/function, store them into memory Function Exection Context create arguments object create this object declare and initialize variable(undefined)/function, store them into memory 如果 JavaScript 引擎在函数执行上下文中找不到变量, 它会在最近的父级执行上下文中查找该变量. 这个查找链将会一直持续, 直到引擎查找到全局执行上下文. 这种情况下, 如果全局执行上下文也没有该变量, 那么将会抛出引用错误 (Reference Error). 子函数“包含”它父级函数的变量环境，把这个概念称为闭包(Closure), 即使父级函数执行环境已经从执行栈弹出了, 子函数还是可以访问父级函数变量 x (通过作用域链). Event Loop The job of the event loop is to look into the call stack and determine if the call stack is empty or not. If the call stack is empty, it looks into the ES6 job queue and message queue to see if there’s any pending call back waiting to be executed: ES6 job queue: used by Promises (higher priority) message queue: used by setTimeout, DOM events 微任务 Microtask，有特权, 可以插队: process.nextTick, Promises.then (Promise 构造函数是同步函数), Object.observer, MutationObserver 宏任务 Macrotask，没有特权: setTimeout, setInterval, setImmediate, I/O, MessageChannel, postMessage, UI rendering, UI Interaction Events Microtask 优先于 Macrotask 浏览器为了能够使得 JS 内部 (macro)task 与 DOM 任务能够有序的执行, 会在一个 (macro)task 执行结束后, 在下一个 (macro)task 执行开始前, 对页面进行重新渲染. 当 JS 引擎从任务队列中取出一个宏任务来执行, 如果执行过程中有遇到微任务, 那么执行完该宏任务就会去执行宏任务内的所有微任务, 然后更新 UI. 后面就是再从任务队列中取出下一个宏任务来继续执行, 以此类推. for (let ii = 0; ii const bar = () => { console.log('bar'); }; const baz = () => { console.log('baz'); }; const foo = () => { console.log('foo'); setTimeout(bar, 0); new Promise((resolve, reject) => { resolve('Promise resolved'); }) .then((res) => console.log(res)) .catch((err) => console.log(err)); baz(); }; foo(); // foo // baz // Promised resolved // bar As above code, using setTimeout with 0 seconds timer helps to defer execution of Promise and bar until the stack is empty. console.log('1'); setTimeout(() => { console.log(2); Promise.resolve().then(() => { console.log(3); process.nextTick(function foo() { console.log(4); }); }); }); Promise.resolve().then(() => { console.log(5); setTimeout(() => { console.log(6); }); Promise.resolve().then(() => { console.log(7); }); }); process.nextTick(function foo() { console.log(8); process.nextTick(function foo() { console.log(9); }); }); console.log('10'); // 1 10 8 9 5 7 2 3 4 6 Promise 构造函数本身是同步函数 console.log('script start'); const promise1 = new Promise(function (resolve) { console.log('promise1'); resolve(); console.log('promise1 end'); }).then(function () { console.log('promise2'); }); setTimeout(function () { console.log('settimeout'); }); console.log('script end'); // 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout await a(); b() 等价于 Promise(a()).then(b()): a 是同步执行, b 是 microtask async function async1() { console.log('async1 start'); await async2(); console.log('async1 end'); } async function async2() { console.log('async2'); } console.log('script start'); setTimeout(function () { console.log('setTimeout'); }, 0); async1(); new Promise(function (resolve) { console.log('promise1'); resolve(); }).then(function () { console.log('promise2'); }); console.log('script end'); /* script start async1 start async2 promise1 script end async1 end promise2 setTimeout */ 当调用栈没有同步函数时, 直接执行任务队列里的函数 function test() { console.log('start'); setTimeout(() => { console.log('children2'); Promise.resolve().then(() => { console.log('children2-1'); }); }, 0); setTimeout(() => { console.log('children3'); Promise.resolve().then(() => { console.log('children3-1'); }); }, 0); Promise.resolve().then(() => { console.log('children1'); }); console.log('end'); } test(); // start // end // children1 // children2 // children2-1 // children3 // children3-1 Browser Internal Chrome: Blink (based on Webkit) + V8 Firefox: Gecko + SpiderMonkey Safari: Webkit + JavaScriptCore (Nitro) Edge: Trident/EdgeHTML + Chakra Browser Process 浏览器进程: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能. GPU 进程: 实现 3D CSS, 绘制 UI 界面. 网络进程：主要负责页面的网络资源加载. 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页, 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中. 默认情况下, Chrome 会为每个 Tab 标签创建一个渲染进程. 出于安全考虑, 渲染进程都是运行在沙箱模式下. 插件进程：主要是负责插件的运行, 因插件易崩溃，所以需要通过隔离以保证插件进程崩溃不会对浏览器和页面造成影响. Render Engine Parser/Script -> DOM Tree -> Styled Tree -> Layout -> Paint -> Composite HTML Parser DTD is context-sensitive grammar. Use State Machine pattern to implement a tokenizer Data -> Tag Open -> Tag Name -> Tag Close -> Data tokenizer send tokens to constructor, constructing DOM tree initial -> before HTML -> before head -> in head -> after head -> in body -> after body -> after after body -> EOF token CSS Parser CSS is context-free grammar. Webkit use flex/bison (bottom-to-up), Gecko use up-to-bottom. ruleset : selector [ ',' S* selector ]* '{' S* declaration [ ';' S* declaration ]* '}' S* ; selector : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]? ; simple_selector : element_name [ HASH | class | attrib | pseudo ]* | [ HASH | class | attrib | pseudo ]+ ; class : '.' IDENT ; element_name : IDENT | '*' ; attrib : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S* [ IDENT | STRING ] S* ] ']' ; pseudo : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ] ; Layout 为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。 如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局: 父呈现器确定自己的宽度 父呈现器依次处理子呈现器，并且： 放置子呈现器（设置 x,y 坐标） 如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因）， 这会计算子呈现器的高度 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用 将其 dirty 位设置为 false Paint Paint Order: 背景颜色 背景图片 边框 子代 轮廓 Effective JavaScript Memory Leak useless global vars (bind to window or document) useless callback functions (e.g setInterval/setTimeout) useless DOM reference closure circular reference 禁用特性 with () {} eval() 少用 new 少用 cotinue 少用 forEach() 局部变量/函数参数 局部变量引用全局变量/全局变量作为参数传入函数: 加快符号解析 局部变量缓存 DOM 元素 局部变量缓存布局信息 局部变量引用嵌套成员: 加快原型链查找 局部变量引用方法时，应注意会动态改变 this 指针 const DOM = tazimi.util.Dom; DOM.method.call(/* 关注 this 指针*/); 字符串 str = str + 'one' + 'two'; 函数 作用域链 由于作用域链的关系，标识符解析时，寻找局部变量速度远快于寻找全局变量速度.故应将全局变量作为参数传入函数进行调用，不但效率高，而且易于维护与测试. 即 利用局部变量引用全局变量，加快标识符解析 循环 倒序循环可提升性能 for (let i = item.length; i--; ) { process(items[i]); } let j = items.length; while (j--) { process(items[i]); } let k = items.length; do { process(items[k]); } while (k--); Duff's Device(达夫设备) let i = items.length % 8; while (i) { process(items[i--]); } i = Math.floor(items.length / 8); while (i) { process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); } Exception Call Stack Overflow 调用栈尺寸限制异常，应立即定位在代码中的递归实例上 try { recursion(); } catch (ex) { console.error('error info'); } Event Delegate(事件委托) 事件委托利用的是事件冒泡机制，只制定一事件处理程序，就可以管理某一类型的所有事件 使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序 increases performance and reduces memory consumption no need to register new event listeners for newer children window.onload = function () { const oUl = document.getElementById('ul'); const aLi = oUl.getElementsByTagName('li'); oUl.onmouseover = function (e) { const e = e || window.event; const target = e.target || e.srcElement; //alert(target.innerHTML); if (target.nodeName.toLowerCase() == 'li') { target.style.background = 'red'; } // 阻止默认行为并取消冒泡 if (typeof e.preventDefault === 'function') { e.preventDefault(); e.stopPropagation(); } else { e.returnValue = false; e.cancelBubble = true; } }; oUl.onmouseout = function (e) { const e = e || window.event; const target = e.target || e.srcElement; //alert(target.innerHTML); if (target.nodeName.toLowerCase() == 'li') { target.style.background = ''; } // 阻止默认行为并取消冒泡 if (typeof e.preventDefault === 'function') { e.preventDefault(); e.stopPropagation(); } else { e.returnValue = false; e.cancelBubble = true; } }; }; 缓存模式 缓存对象属性与 DOM 对象 加载脚本 合并脚本后再进行高级加载技术 延迟加载 ... The full body of the page ... window.onload = function () { const script = document.createElement(\"script\"); script.src = \"all_lazy_20100426.js\"; document.documentElement.firstChild.appendChild(script); }; 动态加载 function requireScript(file, callback) { const script = document.getElementsByTagName('script')[0]; const newjs = document.createElement('script'); // IE newjs.onreadystatechange = function () { if (newjs.readyState === 'loaded' || newjs.readyState === 'complete') { newjs.onreadystatechange = null; callback(); } }; // others newjs.onload = function () { callback(); }; // 添加至html页面 newjs.src = file; script.parentNode.insertBefore(newjs, script); } requireScript('the_rest.js', function () { Application.init(); }); DOM Performance 局部变量缓存 DOM 元素 局部变量缓存布局信息 const btn = document.getElementById('btn'); HTML Collection 转化成数组再操作 function toArray(coll) { for (let i = 0, a = [], len = coll.length; i children 优于 childNodes childElementCount 优于 childNodes.length firstElementChild 优于 firstChild lastElementChild 优于 lastChild nextElementSibling 优于 nextSibling 优于 childNodes[next] previousElementSibling 优于 previousSibling 重排与重绘 重排: 重新构造渲染树 重绘: 重新绘制受影响部分 获取或改变布局的操作会导致渲染树变化队列刷新,执行渲染队列中的\"待处理变化\",重排 DOM 元素 offsetTop / Left / Width / Height; scrollTop / Left / Width / Height; clientTop / Left / Width / Height; getComputedStyle(); 批量修改 DOM 先 display=\"none\", 修改完成后，display=\"\" 使待修改 DOM 元素脱离标准文档流(改变布局／定位方式)，可减少其他元素的重绘次数 document.createDocumentFragment() const fragment = document.createDocumentFragment(); appendDataToElement(fragment, data); document.getElementById('mylist').appendChild(fragment); oldNode.cloneNode(true); const old = document.getElementById('mylist'); const clone = old.cloneNode(true); appendDataToElement(clone, data); old.parentNode.replaceChild(clone, old); requestAnimationFrame run scripts as early as possible: requestAnimationFrame() runs after the CPU work is done (UI events and JS scripts), and just before the frame is rendered (layout, paint, composite etc.). CSS 在 js 中(除定位属性) 外，不直接操作 element.style.attr/element.cssText: element.classList.add('className'); element.className += ' className'; script -> style -> layout -> paint -> composite Make script stage become: read then write. Interleaved read and write will triger multiple times of relayout/repaint/recomposite. // bad // Forced Synchronous Layout read css -> write css (re-layout/paint/composite) -> read css -> write css (re-layout/paint/composite) -> read css -> write css (re-layout/paint/composite) // good read css -> write css (only re-layout/paint/composite once) 定时器(防止脚本阻塞) JavaScript 　代码与 UI 共享线程 setTimeout()/setInterval() 第二个参数: 不是执行时间, 是加入执行队列时间 若其他位于执行队列中的函数执行时间超过延时，则用户感觉不到延时的存在 模拟有间隙的循环，使得 UI 更新得以进入浏览器线程的执行队列中 const button = document.getElementById('myButton'); button.onclick = function () { oneMethod(); setTimeout(function () { document.getElementById('notice').style.color = 'red'; }, 250); }; 分解任务 function saveDocument(id) { // 利用闭包封装待执行任务 const tasks = [openDocument, writeText, closeDocument, updateUI]; setTimeout(function () { // 执行下一个任务 const task = tasks.shift(); task(id); // 检查是否还有其他任务 if (tasks.length > 0) { // 递归调用(每次参数不同) setTimeout(arguments.callee, 25); } }, 25); } function processArray(items, process, callback) { // 克隆原数组 const todo = items.concat(); setTimeout(function () { process(todo.shift()); if (todo.length > 0) { setTimeout(arguments.callee, 25); } else { callback(items); } }, 25); } 批处理任务 function timedProcessArray(items, process, callback) { // 克隆原始数组 const todo = items.concat(); setTimeout(function () { const start = +new Date(); // 一次批处理任务持续 0.05s do { process(todo.shift()); } while (todo.length 0) { setTimeout(arguments.callee, 25); } else { callback(items); } }, 25); } 计时器 /* * usage: start -> stop -> getTime */ const Timer = { _data: {}, start: function(key) { Timer._data[key] = new Date(); }, stop: function(key) { const time = Timer._data[key]; if (time) { Timer._data[key] = new Date() - time; } }, getTime: function(key) { return Timer._data[key]; }; } Web Worker 运行环境 navigation 对象: appName, appVersion, userAgent, platform location 对象: 所有属性只读 ECMAScript 对象: Object/Array/Date XMLHttpRequest 方法 setTimeout/setInterval 方法 self 对象: 指向全局 worker 对象 importScripts 方法: 加载外部依赖 close 方法: 停止 worker Web Worker Loader // 文件名为index.js function work() { onmessage = ({ data: { jobId, message } }) => { console.log('i am worker, receive:-----' + message); postMessage({ jobId, result: 'message from worker' }); }; } const makeWorker = (f) => { let pendingJobs = {}; const worker = new Worker( URL.createObjectURL(new Blob([`(${f.toString()})()`])) ); worker.onmessage = ({ data: { result, jobId } }) => { // 调用 resolve, 改变 Promise 状态 pendingJobs[jobId](result); delete pendingJobs[jobId]; }; return (...message) => new Promise((resolve) => { const jobId = String(Math.random()); pendingJobs[jobId] = resolve; worker.postMessage({ jobId, message }); }); }; const testWorker = makeWorker(work); testWorker('message from main thread').then((message) => { console.log('i am main thread, i receive:-----' + message); }); worker 实例 先 on ,后 post main.js/worker.js 的 onmessage 与 postMessage 相互触发 /* * jsonparser.js */ self.onmessage = function (event) { const jsonText = event.data, jsonData = JSON.parse(jsonText); self.postMessage(jsonData); }; /* * main.js */ const worker = new Worker('jsonparse.js'; worker.onmessage = function(event) { const jsonData = event.data; evaluateData(jsonData); }; worker.postMessage(jsonText); Ajax 数据格式 Format Size (bytes) Download (ms) Parse (ms) Verbose XML 582,960 999.4 343.1 Verbose JSON-P 487,913 598.2 0.0 Simple XML 437,960 475.1 83.1 Verbose JSON 487,895 527.7 26.7 Simple JSON 392,895 498.7 29.0 Simple JSON-P 392,913 454.0 3.1 Array JSON 292,895 305.4 18.6 Array JSON-P 292,912 316.0 3.4 Custom Format (script insertion) 222,912 66.3 11.7 Custom Format (XHR) 222,892 63.1 14.5 Ajax 缓存 const localCache = {}; function xhrRequest(url, callback) { // Check the local cache for this URL. if (localCache[url]) { callback.success(localCache[url]); return; } // If this URL wasn't found in the cache, make the request. const req = createXhrObject(); req.onerror = function () { callback.error(); }; req.onreadystatechange = function () { if (req.readyState == 4) { if (req.responseText === '' || req.status == '404') { callback.error(); return; } // Store the response on the local cache. localCache[url] = req.responseText; callback.success(req.responseText); } }; } req.open('GET', url, true); // req.set(); req.send(null); Reduce Repeat Manipulation 特性/浏览器检测代码只运行一次 惰性定义模式/自定义模式 Debounce and Throttle 防抖动和节流本质是不一样的: debounce: 防抖动是将多次执行变为最后一次执行 (可用于检测某个连续的 DOM 操作结束, 如 scroll 停止) throttle: 节流是将多次执行变成每隔一段时间执行 (保证一定时间内只执行一次) // 这个是用来获取当前时间戳的 function now() { return +new Date(); } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce(func, wait = 50, immediate = true) { let timer, context, args; // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null; // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args); context = args = null; } }, wait); // 这里返回的函数是每次实际调用的函数 return function (...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later(); // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params); } else { context = this; args = params; } } else { // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 clearTimeout(timer); timer = later(); } }; } // simple throttle function throttle(action) { let isRunning = false; return function () { if (isRunning) return; isRunning = true; window.requestAnimationFrame(() => { action(); isRunning = false; }); }; } /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function (func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function () { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function () { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; RequestAnimationFrame Throttling let frameId = 0; let ticking = false; const handleResize = event => { if (ticking) return; ticking = true; frameId = requestAnimationFrame(() => handleUpdate(event)); }; const handleUpdate = event => { console.log('resize update'); ... ticking = false; }; useEffect(() => { window.addEventListener('resize', handleResize); handleUpdate(); return () => { window.removeEventListener('resize', handleResize); cancelAnimationFrame(frameId); }; }); First Paint Time document.addEventListener('DOMContentLoaded', function () { console.log('DOM 挂载时间: ', Date.now() - timerStart); // 性能日志上报 }); window.addEventListener('load', function () { console.log('所有资源加载完成时间: ', Date.now() - timerStart); // 性能日志上报 }); // 计算加载时间 function getPerformanceTiming() { const performance = window.performance; if (!performance) { // 当前浏览器不支持 console.log('你的浏览器不支持 performance 接口'); return; } const t = performance.timing; const times = {}; //【重要】页面加载完成的时间 //【原因】这几乎代表了用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart; //【重要】解析 DOM 树结构的时间 //【原因】反省下你的 DOM 树嵌套是不是太多了！ times.domReady = t.domComplete - t.responseEnd; //【重要】重定向的时间 //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com times.redirect = t.redirectEnd - t.redirectStart; //【重要】DNS 查询时间 //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？ // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364) times.lookupDomain = t.domainLookupEnd - t.domainLookupStart; //【重要】读取页面第一个字节的时间 //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？ // TTFB 即 Time To First Byte 的意思 // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte times.ttfb = t.responseStart - t.navigationStart; //【重要】内容加载完成的时间 //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？ times.request = t.responseEnd - t.requestStart; //【重要】执行 onload 回调函数的时间 //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？ times.loadEvent = t.loadEventEnd - t.loadEventStart; // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart; // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart; // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart; return times; } 算数逻辑运算 位操作 i%2 => i&0x1 位掩码 const OPTION_A = 1, OPTION_B = 2, OPTION_C = 4, OPTION_D = 8, OPTION_E = 16; const options = OPTION_A | OPTION_C | OPTION_D; Math 对象 Math.E; Math.LN10; Math.LN2; Math.LOG2E; Math.LOG10E; Math.PI; Math.SQRT1_2; Math.SQRT2; Math.abs(num); Math.exp(num); Math.log(num); Math.pow(num, power); Math.sqrt(num); Math.acos(x); Math.asin(x); Math.atan(x); Math.atan2(y, x); Math.cos(x); Math.sin(x); Math.tan(x); Browser Performance Performance 工具指北 Browser Caches Dive into Browser Caches 从缓存位置上来说分为四种, 并且各自有优先级, 当依次查找缓存且都没有命中的时候, 才会去请求网络: Service Worker: PWA (In-) Memory Cache: reload Tab page (On-) Disk Cache: big files Push Cache: HTTP/2 self.addEventListener('install', (event) => { async function buildCache() { const cache = await caches.open(cacheName); return cache.addAll(['/main.css', '/main.mjs', '/offline.html']); } event.waitUntil(buildCache()); }); self.addEventListener('fetch', (event) => { async function cachedFetch(event) { const cache = await caches.open(cacheName); let response = await cache.match(event.request); if (response) return response; response = await fetch(event.request); cache.put(event.request, response.clone()); return response; } event.respondWith(cachedFetch(event)); }); HTTP Cache 浏览器缓存，也称 HTTP 缓存, 分为强缓存和协商缓存. 优先级较高的是强缓存, 在命中强缓存失败的情况下或者Cache-Control: no-cache时, 才会走协商缓存. 强缓存是利用 HTTP 头中的 Expires 和 Cache-Control 两个字段来控制的. 强缓存中, 当请求再次发出时, 浏览器会根据其中的 expires 和 cache-control 判断目标资源是否 命中 强缓存, 若命中则直接从缓存中获取资源, 不会再与服务端发生通信. Cache-Control 相对于 expires 更加准确，它的优先级也更高. 当 Cache-Control 与 expires 同时出现时，以 Cache-Control 为准. expires: Wed, 12 Sep 2019 06:12:18 GMT cache-control: max-age=31536000 协商缓存机制下, 浏览器需要向服务器去询问缓存的相关信息, 进而判断是重新发起请求、下载完整的响应, 还是从本地获取缓存的资源. 如果服务端提示缓存资源未改动 (Not Modified), 资源会被重定向到浏览器缓存, 这种情况下网络请求对应的状态码是 304. Last-Modified 是一个时间戳, 如果启用了协商缓存, 它会在首次请求时随着 Response Headers 返回: Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT 随后每次请求时, 会带上一个叫 If-Modified-Since 的时间戳字段, 它的值正是上一次 response 返回给它的 last-modified 值: If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT 服务器可能无法正确感知文件的变化 (未实际改动或改动过快), 为了解决这样的问题, Etag 作为 Last-Modified 的补充出现了. Etag 是由服务器为每个资源生成的唯一的标识字符串, 这个标识字符串可以是基于文件内容编码的, 因此 Etag 能够精准地感知文件的变化. Code Caching cold run: download -> compile -> store into on-disk cache warm run: fetch from browser cache -> compile -> store metadata hot run: fetch scripts and metadata from browser cache -> skip compile positive case: IIFE function heuristics passive case: too small () and inline scripts Browser Pefermance Monitoring 前端性能监控分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。 合成监控 在一个模拟场景里, 去提交一个需要做性能审计的页面, 通过一系列的工具、规则去运行你的页面, 提取一些性能指标, 得出一个审计报告. 常见的工具有 Google 的 Lighthouse，webpagetest，pagespeed 等 优点 缺点 实现简单 无法还原全部真实场景 能采集到丰富的数据，如硬件指标或瀑布图 登录等场景需要额外解决 不影响真实用户的访问性能 单次数据不够稳定 可以提供页面加载幻灯片等可视化分析途径 数据量较小，无法发挥更大价值 真实用户监控 用户在页面访问之后就会产生各种各样的性能指标, 之后会将这些性能指标上传的我们的日志服务器上, 进行数据的提起清洗加工, 最后在监控平台上进行展示和分析的一个过程. 真实用户监控的优缺点 优点 缺点 无需配置模拟条件，完全还原真实场景 影响真实用户的访问性能及流量消耗 不存在登录等需要额外解决的场景 无法采集硬件相关指标 数据样本足够庞大，可以减少统计误差 无法采集完整的资源加载瀑布图 新年数据可与其它数据关联，产生更大价值 无法可视化展示加载过程 对比 对比项 合成监控 真实用户监控 实现难度及成本 较低 较高 采集数据丰富度 丰富 基础 数据样本量 较小 大(视业务体量) 适合场景 定性分析, 小数据量分析 定量分析, 业务数据深度挖掘 方案 在真实用户性能数据采集时, 要关注四个方面的东西: 使用标准的 API 定义合适的指标 采集正确的数据 上报关联的维度 使用标准的 API 采集性能数据时先抹平 Navigation Timing spec 差异 优先使用 PerformanceTimeline API (在复杂场景，亦可考虑优先使用 PerformanceObserver) 定义合适的指标 First Meaningful Paint: 首次有效渲染时长, 它的一个核心的想法是渲染并不一定代表着用户看到了主要内容, Load 也不一定代表用户看到主要内容. 假设当一个网页的 DOM 结构发生剧烈的变化的时候, 就是这个网页主要内容出现的时候, 那么在这样的一个时间点上, 就是用户看到主要内容的一个时间点. 它的优点是相对校准的估算出内容渲染时间, 贴近用户感知. 但缺点是无原生 API 支持, 算法推导时 DOM 节点不含权重. First Contentful Paint First Meaningful Paint First Ipnut Delay Time to Interactive 上报关联的维度 不同的页面操作/页面打开方式/浏览器环境都会对我们页面加载的性能会有影响, 需要上报这些维度的数据, 以便深入性能分析: 当前页面是否可见 页面加载方式: 直接打开/刷新打开/前进后退打开 是否启用 HTTP2 是否启用 Service Worker Speed Tools Speedup Tools FID Tracking PageSpeed Insights Lighthouse (audit tab) Data Format and Size optimize images for web Images Optimization Techniques Images Format mp4 smaller than gif (ffmpeg) WebP 25-35% smaller than jpg/png Images Compression Imagemin Images Scaling responsive images: provide 3~5 different sizes reduce image transfer sizes by average of ~20% Sharp Jimp Data Loading Resources Priority Data Preloading Images Lazy Loading Lazy Loading Polyfill: window.addEventListener('scroll', function (event) { Array.from(document.querySelectorAll('.lazyload')).forEach((image) => { if (image.slideIntoView(event.getBoundingClientRect())) { image.setAttribute('src', image.dataset.src); } }); }); Observer Lazy Loading: const observer = new IntersectionObserver((nodes) => { nodes.forEach((v) => { if (v.isIntersecting) { v.target.src = v.target.dataset.src; observer.unobserve(v.target); } }); }); const imgs = document.querySelectorAll('img.lazyload'); imgs.forEach((v) => observer.observe(v)); Native Lazy Loading: JavaScript Lazy Loading Script Priorities defer: downloads the script while the document is still parsing, but waits until the document has finished parsing before executing it (in order) async: downloads the script during parsing the document, but will pause the parser to execute the script If the scripts rely on each other, use defer If the script is independent, use async If put JavaScript in , in such script can't access DOM directly (DOM haven't get parsed) Best practice: lazy loading scripts not execute immediately (Chrome Coverage Devtools) const DetailsComponent = lazy(() => import('./details')); const PageComponent = () => { Loading...}> ; }; Prefetch Why not to prefetch prerender: avoid prefetching pages for authentication avoid over-prefetching to limit accidental DOS avoid prefetching pages key to checkout avoid prefetching large resources avoid prefetching cross-origin resources Babel Config for JavaScript { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"esmodules\": true, \"node\": \">= 8\", \"browsers\": \"> 0.25%\" }, \"useBuiltIns\": \"usage\" } ] ] } V8 Good Parts source code (parser) AST (interpreter) bytecode send profilling data from bytecode to optimizing compiler, generate optimized code Ignition interpreter TurboFan optimizing compiler (2 for SpiderMonkey/Edge, 3 for Safari) Object Shape Shapes ICS // o1 and o2 have the same shape // JSObject(1, 2) => Shape('x', 'y') // JSObject(3, 4) => Shape('x', 'y') // 'x' => 0 Offset, Writable, Enumerable, Configurable // 'y' => 1 Offset, Writable, Enumerable, Configurable const o1 = { x: 1, y: 2 }; const o2 = { x: 3, y: 4 }; Shape Transform // Shape chain: Shape(empty) => Shape(x) => Shape(x, y) const o = {}; o.x = 1; o.y = 2; // Shape chain: Shape(empty) => Shape(y) => Shape(y, x) const o = {}; o.y = 2; o.x = 1; // Shape chain: Shape(x) const o = { x: 1 }; array shape: Shape('length'), 'length' => 0 Offset, Writable Inline Cache V8 use ICs to memorize information (same shape) where to find properties on objects: always initialize objects in the same way (generate the same shape) don't add property to objects dynamically (invalid inline cache) don't mess with property attributes of array elements V8 Perf Tools deoptigate turbolizer v8 map processor Awesome V8 Performance Tutorial v8 perf Perf and Analysis Tools Chrome DevTools Chrome UX Report Audits of Chrome: PWA, best practices, SEO, performance, device simulator Inspect Android Device enable developmemnt mode and USB debugging in Android Device link Android and PC with USB cable open chrome://inspect/#devices to start inspecting Performance Best Practice use monomorphic objects due to shape and inline caches use monomorphic fucntion in hot code paths resource optimization code splitting lazy loading offline caching (PWA) Testing and Debugging Log 时间，包含时区信息和毫秒 日志级别 会话标识 功能标识 精炼的内容: 场景信息（谁，什么功能等），状态信息(开始，中断，结束)以及重要参数 其他信息：版本号，线程号 Log Clock performance.now() is more precise (100 us) performance.now() is strictly monotonic (unaffected by changes of machine time) let lastVisibilityChange = 0; window.addEventListener('visibilitychange', () => { lastVisibilityChange = performance.now(); }); // don’t log any metrics started before the last visibility change // don't log any metrics if the page is hidden // discard perf data from when the machine was not running app at full speed if (metric.start requestAnimationFrame(() => { requestAnimationFrame((timestamp) => { metric.finish(timestamp); }); }); Headless Testing Puppeteer Puppeteer Recipes const puppeteer = require('puppeteer'); (async () => { const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://example.com'); await page.screenshot({ path: 'example.png' }); await browser.close(); })(); Browser Context // Create a new incognito browser context const context = await browser.createIncognitoBrowserContext(); // Create a new page inside context. const page = await context.newPage(); // ... do stuff with page ... await page.goto('https://example.com'); // Dispose context once it's no longer needed. await context.close(); DOM Testing page.$(selector) same to querySelector Event Testing // wait for selector await page.waitFor('.foo'); // wait for 1 second await page.waitFor(1000); // wait for predicate await page.waitFor(() => !!document.querySelector('.foo')); const puppeteer = require('puppeteer'); puppeteer.launch().then(async (browser) => { const page = await browser.newPage(); const watchDog = page.waitForFunction('window.innerWidth const [response] = await Promise.all([ page.waitForNavigation(), // The promise resolves after navigation has finished page.click('a.my-link'), // Clicking the link will indirectly cause a navigation ]); const firstRequest = await page.waitForRequest('http://example.com/resource'); const finalRequest = await page.waitForRequest( (request) => request.url() === 'http://example.com' && request.method() === 'GET' ); return firstRequest.url(); const firstResponse = await page.waitForResponse( 'https://example.com/resource' ); const finalResponse = await page.waitForResponse( (response) => response.url() === 'https://example.com' && response.status() === 200 ); return finalResponse.ok(); await page.evaluate(() => window.open('https://www.example.com/')); const newWindowTarget = await browserContext.waitForTarget( (target) => target.url() === 'https://www.example.com/' ); Operation Simulation Testing const [response] = await Promise.all([ page.waitForNavigation(waitOptions), page.click(selector, clickOptions), ]); // Using ‘page.mouse’ to trace a 100x100 square. await page.mouse.move(0, 0); await page.mouse.down(); await page.mouse.move(0, 100); await page.mouse.move(100, 100); await page.mouse.move(100, 0); await page.mouse.move(0, 0); await page.mouse.up(); await page.keyboard.type('Hello World!'); await page.keyboard.press('ArrowLeft'); await page.keyboard.down('Shift'); for (let i = 0; i Tracing Testing await page.tracing.start({ path: 'trace.json' }); await page.goto('https://www.google.com'); await page.tracing.stop(); Other Puppeterr Testing API page.setOfflineMode page.setGeolocation page.metrics page.accessibility page.coverage Frameworks Unit 测试 Jasmine Mocha UI 测试 用户行为: Karma/Selenium 功能测试: Phantomjs/Slimerjs/Karma 可测试代码 完整注释 最小复杂度 = (扇入 * 扇出) ^ 2 可隔离性: 最小依赖性 + 松耦合性 范例 使用依赖注入，将外部对象移至函数参数处(不在函数内部调用构造器): 易于构造 mock/stub, 降低扇出(函数复杂度) 圈复杂度 V(G) = e - n + 2 函数复杂度 函数复杂度 = (扇入 * 扇出) ^ 2 扇出(引用) 所引用外部对象/方法之和 高扇出: 高复杂度/高依赖性/高耦合度 扇入(被引用) 其他对象/方法引用此函数的次数之和 顶层抽象代码 与 不常用功能 应保持低扇入 耦合度 内容耦合(5) O.property = 'tazimi'; O.method = function () {}; O.prototype.method = function () {}; 公共耦合(4) 共享全局变量 const Global = 'global'; function A() { Global = 'A'; } function B() { Global = 'B'; } 控制耦合(3) const absFactory = new AbstractFactory({ env: 'TEST' }); 印记耦合(2) O.prototype.makeBread = function (args) { return new Bread(args.type, args.size); }; O.makeBread({ type: wheat, size: 99, name: 'foo' }); 数据耦合(1) 无耦合(0) 单元测试 测试原则 代码覆盖率 非法值测试 边界测试 非边界测试 隔离被测代码 编写代码时，保持最小复杂度(最小依赖，最低耦合) 利用 mock/stub 模拟外部依赖/测试数据 mock/stub/spy mock: 模拟对象中的方法/接口 stub: 模拟对象中的返回值 spy: 在原有对象的基础上，增加监视用变量/方法 e.g assert/调用次数/参数限制 const mockery = require('mockery'); mockery.enable(); describe('Sum suite File', function () { beforeEach(function () { mockery.registerAllowable('./mySumFS', true); }); afterEach(function () { mockery.deregisterAllowable('./mySumFS'); }); it('Adds Integers!', function () { const filename = 'numbers'; const fsMock = { readFileSync: function (path, encoding) { expect(path).toEqual(filename); expect(encoding).toEqual('utf8'); return JSON.stringify({ a: 9, b: 3 }); }, }; mockery.registerMock('fs', fsMock); const mySum = require('./mySumFS'); expect(mySum.sum(filename)).toEqual(12); mockery.deregisterMock('fs'); }); }); Monkey Patch let _wr = function (type) { let orig = window.history[type]; return function () { let rv = orig.apply(this, arguments); let e = new Event(type.toLowerCase()); e.arguments = arguments; window.dispatchEvent(e); return rv; }; }; window.history.pushState = _wr('pushState'); window.history.replaceState = _wr('replaceState'); window.addEventListener('pushstate', function (event) { // doing something }); window.addEventListener('replacestate', function (event) { // doing something }); Tools API console API var devtools = /./; devtools.toString = function () { this.opened = true; }; console.log('%c', devtools); // devtools.opened will become true if/when the console is opened console.log / info / warn / error; console.dir / dirxml / table; // different output style console.assert; console.group / groupEnd; console.time / timeEnd; console.profile / profileEnd; console.count; console.trace; console.log // `sprinf` style log console.log('%d %o %s', integer, object, string); console.log('%c ...', 'css style'); console.table // display array of object (tabular data) const transactions = [ { id: '7cb1-e041b126-f3b8', seller: 'WAL0412', buyer: 'WAL3023', price: 203450, time: 1539688433, }, { id: '1d4c-31f8f14b-1571', seller: 'WAL0452', buyer: 'WAL3023', price: 348299, time: 1539688433, }, { id: 'b12c-b3adf58f-809f', seller: 'WAL0012', buyer: 'WAL2025', price: 59240, time: 1539688433, }, ]; console.table(data, ['id', 'price']); JS API debugger; copy(obj); // to clipborad window.onerror = function (errorMessage, scriptURI, lineNo, columnNo, error) { console.log('errorMessage: ' + errorMessage); // 异常信息 console.log('scriptURI: ' + scriptURI); // 异常文件路径 console.log('lineNo: ' + lineNo); // 异常行号 console.log('columnNo: ' + columnNo); // 异常列号 console.log('error: ' + error); // 异常堆栈信息 // ... // 异常上报 }; window.addEventListener('error', function () { console.log(error); // ... // 异常上报 }); Trace Property (Vue Internal) const traceProperty = (object, property) => { let value = object[property]; Object.defineProperty(object, property, { get() { console.trace(`${property} requested`); return value; }, set(newValue) { console.trace(`setting ${property} to `, newValue); value = newValue; }, }); }; Node API node --inspect ndb node --inspect ndb index.js Browser Compatibility 特性检测 不使用特性/浏览器推断，往往容易推断错误(且会随着浏览器更新产生新的错误) // 特性检测 if (document.getElementById) { element = document.getElementById(id); } Chrome Dev Tools Shortcuts c-d: go to next word c-f in Elements panel: search DOM node c-m: go to next bracket c-p: go to files cs-p: go to anywhere cs-o: go to functions long click reload: multiple reload options e.g clean cache Elements Panel break on elements Style Tab color picker filter: class filter, pseudo filter, css style filter Console Panel getEventListeners(dom) monitorEvents(dom, events) unmonitorEvents(dom) debug(fn) undebug(fn) monitor(fn) unmonitor(fn) Console Settings preserve log show timestamps Verbose: additional performance log click filename, filter error messages add folder to workspace capture default eventListener $0: the reference to the currently selected element in the Elements panel const listener = getEventListeners($0).click[0].listener; $0.removeEventListener('click', listener); $0.addEventListener('click', (e) => { // do something // ... // then listener(e); }); Source Panel add log points multiple breakpoints: source, XHR/fetch, DOM, global/event listeners open a source file, right click code, Blackbox script item Local Overrides for persistent changes to css styles Network Panel throtting: simulate different network environment initiator：go to files Performance Panel C+S+P: performance monitor C+S+P: FPS script->style->layout->paint->composite timeline performance tips Timeline Events Performance Analysis Reference Simulation DevTools cs-p: type 3G (slow network) cs-p: type sensor (geolocation) Testing DevTools cs-p: type audit cs-p: type coverage Memory Panel JS Profiler Panel Layer Panel tool for composite stage analysis Rendering Panel re-paint area FPS monitor scroll event paint flashing layout/layer border More Tools layers animations coverage JavaScript Style Guide Airbnb Guide Naming Style 变量: 名词前缀 方法/函数: 动词前缀 _method: 表示私有化方法 普通函数: 驼峰命名法(camelCase) 构造函数: 帕斯卡命名法(PascalCase) 缩略词和缩写都必须是全部大写/小写 对于 jQuery 对象的变量使用 $ 作为前缀 Variable Style no single let/const sort let/const // bad let i, len, dragonball, items = getItems(), goSportsTeam = true; // bad let i; const items = getItems(); let dragonball; const goSportsTeam = true; let len; // good const goSportsTeam = true; const items = getItems(); let dragonball; let i; let length; no chains assignment (create implict global variable) // bad (function example() { // JavaScript 把它解释为 // let a = ( b = ( c = 1 ) ); // let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。 let a = (b = c = 1); })(); console.log(a); // throws ReferenceError console.log(b); // 1 console.log(c); // 1 // good (function example() { let a = 1; let b = a; let c = a; })(); console.log(a); // throws ReferenceError console.log(b); // throws ReferenceError console.log(c); // throws ReferenceError use () wrap multiple line // bad const foo = superLongLongLongLongLongLongLongLongFunctionName(); // bad const foo = 'superLongLongLongLongLongLongLongLongString'; // good const foo = superLongLongLongLongLongLongLongLongFunctionName(); // good const foo = 'superLongLongLongLongLongLongLongLongString'; Object Style use literal // bad const item = new Object(); // good const item = {}; use object-shorthand // bad const atom = { lukeSkywalker: lukeSkywalker, addValue: function (value) { return atom.value + value; }, }; // good const atom = { lukeSkywalker, addValue(value) { return atom.value + value; }, }; use Object.prototype.XX not object.xx // bad console.log(object.hasOwnProperty(key)); // good console.log(Object.prototype.hasOwnProperty.call(object, key)); // best const has = Object.prototype.hasOwnProperty; // 在模块范围内的缓存中查找一次 /* or */ import has from 'has'; // https://www.npmjs.com/package/has // ... console.log(has.call(object, key)); use object spread not object.assign // very bad const original = { a: 1, b: 2 }; const copy = Object.assign(original, { c: 3 }); // 变异的 `original` ಠ_ಠ delete copy.a; // 这.... // bad const original = { a: 1, b: 2 }; const copy = Object.assign({}, original, { c: 3 }); // good const original = { a: 1, b: 2 }; const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 } const { a, ...noA } = copy; // noA => { b: 2, c: 3 } use . for static name, use [] for variable name // good const isJedi = luke.jedi; function getProp(prop) { return luke[prop]; } Array Style use literal use push not [] use array spread (best) or Array.from (good) const foo = document.querySelectorAll('.foo'); // good const nodes = Array.from(foo); // best const nodes = [...foo]; Destruct Style 对于多个返回值使用对象解构，而不是数组解构 // bad function processInput(input) { // 处理代码... return [left, right, top, bottom]; } // 调用者需要考虑返回数据的顺序。 const [left, __, top] = processInput(input); // good function processInput(input) { // 处理代码... return { left, right, top, bottom }; } // 调用者只选择他们需要的数据。 const { left, top } = processInput(input); String Style use ' not \" use `${}` not 'str1' + 'str2' Function Style use naming function expression not function declaration // bad function foo() { // ... } // bad const foo = function () { // ... }; // good // 从变量引用调用中区分的词汇名称 const short = function longUniqueMoreDescriptiveLexicalFoo() { // ... }; use ...args not arguments // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } use default parameters not default expression pattern // bad function handleThings(opts) { this.opts = opts || {}; } // good function handleThings(opts = {}) { this.opts = opts; } no reassign parameters: side effect and bad performance Arrow Function Style () and {} should pair // bad arr.map((x) => x + 1); arr.map((x, index) => x + index); [1, 2, 3].map((x) => { const y = x + 1; return x * y; }); // good arr.map((x) => x + 1); arr.map((x, index) => { return x + index; }); [1, 2, 3].map((x) => { const y = x + 1; return x * y; }); use () wrap multiple line return value // bad ['get', 'post', 'put'].map((httpMethod) => Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ) ); // good ['get', 'post', 'put'].map((httpMethod) => Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ) ); Module Style import first // bad import foo from 'foo'; foo.init(); import bar from 'bar'; // good import foo from 'foo'; import bar from 'bar'; foo.init(); no shorthand export from // bad // filename es6.js export { es6 as default } from './AirbnbStyleGuide'; // good // filename es6.js import { es6 } from './AirbnbStyleGuide'; export default es6; path occurs once // bad import foo from 'foo'; // … 其他导入 … // import { named1, named2 } from 'foo'; // good import foo, { named1, named2 } from 'foo'; // best import foo, { named1, named2 } from 'foo'; not export let // bad let foo = 3; export { foo }; // good const foo = 3; export { foo }; Iterator and Generator Style no iterator, 应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of: 使用 map/reduce/filter/any/every/some/find/findIndex/ ... 遍历数组 使用 Object.keys() / Object.values() / Object.entries() 迭代对象生成数组 const numbers = [1, 2, 3, 4, 5]; // bad let sum = 0; for (let num of numbers) { sum += num; } sum === 15; // good let sum = 0; numbers.forEach((num) => { sum += num; }); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) => total + num, 0); sum === 15; // bad const increasedByOne = []; for (let i = 0; i { increasedByOne.push(num + 1); }); // best (keeping it functional) const increasedByOne = numbers.map((num) => num + 1); use function* for generator // bad function* foo() { // ... } // bad const bar = function* () { // ... }; // good function* foo() { // ... } // good const foo = function* () { // ... }; Expression Style if 语句使用 ToBoolean 的抽象方法来计算表达式的结果: Objects 的取值为： true Undefined 的取值为： false Null 的取值为： false Booleans 的取值为： 布尔值的取值 Numbers 的取值为：如果为 +0, -0, or NaN 值为 false 否则为 true Strings 的取值为: 如果是一个空字符串 '' 值为 false 否则为 true 对于布尔值使用简写，但是对于字符串和数字进行显式比较 // bad if (isValid === true) { // ... } // good if (isValid) { // ... } // bad if (name) { // ... } // good if (name !== '') { // ... } // bad if (collection.length) { // ... } // good if (collection.length > 0) { // ... } use {} warp case when exists const/let/function/class declaration // bad switch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {} } // good switch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} } } 换行 Style 键入最后一个运算符后再换行, 运算符置于行尾可使 automatic semicolon insertion 机制失效 换行后保持 2 个缩进层次 // bad const arr = [ [0, 1], [2, 3], [4, 5], ]; const objectInArray = [ { id: 1, }, { id: 2, }, ]; const numberInArray = [1, 2]; // good const arr = [ [0, 1], [2, 3], [4, 5], ]; const objectInArray = [ { id: 1, }, { id: 2, }, ]; const numberInArray = [1, 2]; use () wrap multiple line assignment or arguments // good const foo = superLongLongLongLongLongLongLongLongFunctionName(); ['get', 'post', 'put'].map((httpMethod) => Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ) ); 空格 Style Good places to use a white space include: ,/; 后 +,-,*,/,,= 前后 function () {} function foo() {} } if/for/while () {} } else {} no space inner () [] use space inner {} let d = 0, a = b + 1; if (a && b && c) { d = a % c; a += d; } // antipattern // missing or inconsistent spaces // make the code confusing let d = 0, a = b + 1; if (a && b && c) { d = a % c; a += d; } 注释 Style 上方插入空行 与下方语句统一缩进 /* * comments * comments */ 模块 /* * @module myapp * @namespace MYAPP */ 对象 /* * @class mathStuff */ 属性 /* * @property propertyName * @type Number/String */ 方法/函数 /* * @constructor * @method sum * @param {Number}/{String} instructions * @return {Number}/{String} instructions */ SSR Server Side Rendering with Puppeteer Rendering on the Web if (isBotAgent) { // return pre-rendering static html to search engine crawler // like Gatsby } else { // server side rendering at runtime for real interactive users // ReactDOMServer.renderToString() } SEO SEO Tutorials SEO Basics SPA SEO Basics SEO Tips server-side rendering (e.g next.js) prerendering mobile performance optimization (e.g minify resources, code splitting, CDN, lazy loading, minimize reflows) SEO-friendly routing and URL management Google webmaster tools SEO Metadata const seo = { title: 'About', description: 'This is an awesome site that you definitely should check out.', url: 'https://www.mydomain.com/about', image: 'https://mydomain.com/images/home/logo.png', } PWA Progressive Web Apps: served over HTTPS provide a manifest register a ServiceWorker (web cache for offline and performance) consists of website, web app manifest, service worker, expanded capabilities and OS integration Service Worker SW Pros cache offline background custom request to minimize network Notification API SW Costs need startup time // 20~100 ms for desktop // 100 ms for mobile const entry = performance.getEntriesByName(url)[0]; const swStartupTime = entry.requestStart - entry.workerStart; cache reads aren't always instant: cache hit time = read time (only this case better than NO SW), cache miss time = read time + network latency, cache slow time = slow read time + network latency, SW asleep = SW boot latency + read time ( + network latency), NO SW = network latency. const entry = performance.getEntriesByName(url)[0]; // no remote request means this was handled by the cache if (entry.transferSize === 0) { const cacheTime = entry.responseStart - entry.requestStart; } const cacheStart = performance.now(); const response = await caches.match(event.request); const cacheEnd = performance.now(); SW Demo SW Serving Strategy SW Caching Strategy // Check that service workers are registered if ('serviceWorker' in navigator) { // Use the window load event to keep the page load performant window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js'); }); } SW for Broken Images function isImage(fetchRequest) { return fetchRequest.method === 'GET' && fetchRequest.destination === 'image'; } self.addEventListener('fetch', (e) => { e.respondWith( fetch(e.request) .then((response) => { if (response.ok) return response; // User is online, but response was not ok if (isImage(e.request)) { // Get broken image placeholder from cache return caches.match('/broken.png'); } }) .catch((err) => { // User is probably offline if (isImage(e.request)) { // Get broken image placeholder from cache return caches.match('/broken.png'); } }) ); }); self.addEventListener('install', (e) => { self.skipWaiting(); e.waitUntil( caches.open('precache').then((cache) => { // Add /broken.png to \"precache\" cache.add('/broken.png'); }) ); }); PWA Library Workbox PWA Tutorials Extensive Guide HTTP/2 在 HTTP/1.x 中，每次请求都会建立一次 HTTP 连接: 串行的文件传输. 当请求 a 文件时, b 文件只能等待 连接数过多 HTTP/2 的多路复用就是为了解决上述的两个性能问题. 在 HTTP/2 中, 有两个非常重要的概念, 分别是帧（frame）和流（stream）. 帧代表着最小的数据单位, 每个帧会标识出该帧属于哪个流, 流也就是多个帧组成的数据流. 多路复用, 就是在一个 TCP 连接中可以存在多条流, 避免队头阻塞问题和连接数过多问题. Security Content Security Policy Level 3 CSP help prevent from XSS { \"header\": { \"Content-Security-Policy\": \" script-src 'nonce-random123' 'strict-dynamic' 'unsafe-eval'; object-src 'none'; base-uri 'none' \" } } alert('xss'); // XSS injected by attacker - blocked by CSP alert('this is fine!) nonce only CSP block 3rd lscripts and dynamic scripts generate by trusted users, 'strict-dynamic' can tackle it. const s = document.createElement('script) s.src = '/path/to/script.js'; document.head.appendChild(s); // can execute correctly Trusted Types TrustedURL TrustedHTML TrustedScript TrustedScriptURL // fallback policy TrustedTypes.createPolicy( 'default', { createHTML(s) { console.error('Please fix! Insecure string assignment detected:', s); return s; }, }, true ); // Content-Security-Policy-Report-Only: trusted-types myPolicy; report-uri /cspReport const SanitizingPolicy = TrustedTypes.createPolicy('myPolicy', { createHTML(s: string) => myCustomSanitizer(s) }, false); const trustedHTML = SanitizingPolicy.createHTML(foo); element.innerHTML = trustedHTML; CSRF # Reject cross-origin requests to protect from # CSRF, XSSI & other bugs def allow_request(req): # Allow requests from browsers which don't send Fetch Metadata if not req['sec-fetch-site']: return True # Allow same-site and browser-initiated requests if req['sec-fetch-site'] in ('same-origin', 'same-site', 'none'): return True # Allow simple top-lelve navigations from anywhere if req['sec-fetch-mode'] == 'navigate' and req.method == 'GET': return True return False Object Property object[constructor] object.__proto__ Sandbox // 简化伪代码示例 frame = document.body.appendChild(document.createElement('iframe',{ src: 'about:blank', sandbox: \"allow-scripts allow-same-origin allow-popups allow-presentation allow-top-navigation\", style: 'display: none;', })) window = new Proxy(frame.contentWindow, { ... }) document = new Proxy(document, { ... }) ... sandbox = new Function(` return function ({ window, location, history, document }, code){ with(window) { ${code} } }`) sandbox().call(window, { window, location, history, document }, code) User Fingerprint Use Canvas or WebGL to generate user fingerprint. function getCanvasFingerprint() { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); context.font = '18pt Arial'; context.textBaseline = 'top'; context.fillText('Hello, user.', 2, 2); return canvas.toDataURL('image/jpeg'); } getCanvasFingerprint(); HTTP Protocol HTTP 2 HTTP/2 = HTTP + HPack / Strem + TLS 1.2+ + TCP 二进制传输 (乱序二进制帧 Stream) Header 压缩 (HPack) 多路复用 Server Push 事实加密 (Chrome/Firefox 只支持 HTTP/2 over TLS 1.2+) HTTP 3 HTTP/3 = HTTP + QPack / Strem + QUIC / TLS 1.3+ + UDP 解决多次握手高延迟问题 解决队头 (数据重传) 阻塞 (后续数据) 问题 QUIC 协议保证传输可靠、实现快速握手、集成 TLS 加密、实现多路复用 DevOps Static Assets Fingerprinting is a technique that makes the name of a file, dependent on the contents of the file, not on the timestamp differ from servers. When the file contents change, the filename is also changed. For content that is static or infrequently changed, this provides an easy way to tell whether two versions of a file are identical, even across different servers or deployment dates. When a filename is unique and based on its content, HTTP headers can be set to encourage caches(code: 200) everywhere (whether at CDNs, at ISPs, in networking equipment, or in web browsers) to keep their own copy of the content. When the content is updated(), the fingerprint will change. This will cause the remote clients to request a new copy of the content. This is generally known as cache busting. CI System Full builds upon continuous deployment. Incremental builds are a product of time. Release System Blue Green Deployment 两套系统, 一套稳定的绿色系统, 一套即将发布的蓝色系统. 不断切换并迭代发布到生产环境中. Rolling Update 多个集群实例的服务中, 在不影响服务的情况下, 停止一个或多个实例, 逐步进行版本更新. Gray Release Gray Release Introduction Canary Release: 全量或增量部署新文件, 并逐步把流量切换至新 CDN URL. 根据灰度白名单, 将灰度测试用户的 CDN Assets 更换至不同 Version Number 或者 Fingerprint 的新版本前端页面文件. Gray Release Solution 通过灰度发布收集用户反馈 (转化率等指标), 决定后续是否全面将所有流量切至新版本, 或者完全放弃新版本, 亦或是通过 FLAGS 结合用户特征图像, (如用户级别, UA, Cookie Location, IP, Feature List 等) 只向部分流量投放新版本. 可以实现千人千页, 每个用户获得由不同的功能 (FLAGS 开启关闭) 组成的不同页面. 业界成熟的灰度方案: 简单灰度逻辑通过 Nginx 配置做规则判断(路由, 参数, IP, Cookie 等), upstream 到不同的服务器: 新代码部署到 A 边. 符合灰度策略的小部分流量切到 A 边, 剩余大部分流量仍去往 B 边 验证 A 边功能是否正常可用/好用 验证无误后, 大部分流量转到 A 边, 灰度流量去往 B 边 验证 B 边功能是否正常可用/好用 验证无误后, 流量像往常一样均分到 AB 边 # Canary Deployment map $COOKIE\\_canary $group { # canary account ~\\*devui$ server\\_canary; default server\\_default; } # 流量均分, 注释掉其中某一边, 另一边为灰度流量访问边 upstream server\\_canary { server 11.11.11.11:8000 weight=1 max\\_fails=1 fail\\_timeout=30s; server 22.22.22.22 weight=1 max\\_fails=1 fail\\_timeout=30s; } # 流量均分, 注释掉其中某一边, 另一边为正常流量访问边 upstream server\\_default { server 11.11.11.11:8000 weight=2 max\\_fails=1 fail\\_timeout=30s; server 22.22.22.22 weight=2 max\\_fails=1 fail\\_timeout=30s; } # 配置 8000 端口的转发规则, 并且 expose port server { listen 8000; server\\_name \\_; root /var/canaryDemo; # Load configuration files for the default server block. include /etc/nginx/default.d/\\*.conf; location / { root /var/canaryDemo; index index.html; try_files $uri $uri/ /index.html; } } server { listen 80 default\\_server; listen \\[::\\]:80 default\\_server; server\\_name \\_; # root /usr/share/nginx/html; root /var/canaryDemo; # Load configuration files for the default server block. include /etc/nginx/default.d/\\*.conf; location / { proxy\\_pass http://$group; # root /var/canaryDemo; # index index.html; } error\\_page 404 /404.html; location = /40x.html { } error\\_page 500 502 503 504 /50x.html; location = /50x.h } 复杂灰度逻辑通过 Nginx + Lua 新增一个灰度中心服务, 结合业务来做流量的灰度与切换, 控制 HTML 入口文件, 使灰度规则与业务代码解耦. Gray Release Performance 前端优化: 每一个页面都需要去获取灰度规则，这个灰度请求将阻塞页面. 可以使用 localStrage 存储这个用户是否为灰度用户, 然后定期的更新 localStrage, 取代大量的请求造成的体验问题. 后端优化: 利用 MemCache 在内存中缓存灰度规则与灰度用户列表, 提升灰度发布性能. © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/javascript/javascriptBasicNotes.html":{"url":"programming/web/javascript/javascriptBasicNotes.html","title":"Javascript Basic Notes","keywords":"","body":"JavaScript Basic Notes JavaScript Basic Notes 常量 变量 原始数据类型值 Primitive type undefined null float 非数 NaN number Infinity string 引用特性 非对象特性(基本变量) 基本操作 Object Wrappers for Primitive Type 引用类型值 Object type Date 全局变量 局部变量 变量提升 Hoisting 数组(与 Object 同源) length 数组字面量 常用方法 sort 堆栈 分割/合并 替换 查询 遍历 Deep Clone of Array 其他 Array Tips 高阶函数 类型检测 Best Practice Null 检测 自定义对象检测 属性检测 强制类型转化(Type Coercion) 对象转换 运算符 Loose Comparison 条件表达式 Add Operator 控制流程 switch/case 对象 对象三大特征 原型链 构造函数 构造对象的三种形式 对象字面量 new 构造函数 Object.create 返回值 instanceof 最佳实践 全局对象 私有属性与特权方法 私有属性 特权方法 静态属性与方法 静态属性 静态方法 模块化对象 普通属性 普通方法 Class 式继承 代理构造函数(运用中继者) 类继承(借用构造函数)与原型继承(设置原型) 混合继承模式 kclass 语法糖 原型链继承 共享 - 原型代理(prototype) 独立 - 原型克隆 浅克隆 深克隆 属性混入 - 多重继承 封装 - 工厂方法(闭包) 包装类对象 错误对象 函数 Invocation Patterns and This Bindings Implicit Binding Explicit Binding Constructor Binding Arrow Function Binding prototype arguments arguments.callee 作用域链 全局对象 window 活动对象(Activation Object) 函数表达式 函数入参 回调函数 自定义函数/惰性函数定义 即时函数 即时函数模式 模式作用 即时函数返回值 call/apply/bind bind 通过 call/apply 实现 bind 函数 多态方法 eval 常用函数 Object 类型判断 解析函数 数学函数 时间函数 setInterval 常用模式 API 模式 回调模式 配置对象 返回函数(闭包) Curry 化 链模式 初始化模式 即使函数 即使对象初始化 初始化分支 模块化 命名空间 通用命名空间函数 沙盒模式 实现沙盒构造函数 沙盒使用方式 JavaScript DOM Basic Notes DOM - O DOM Core dynamic creation append insert node Traverse DOM Tree Frag HTML DOM CSSOM Inline Styles Get/Set Styles Computed Styles CSS Class CSSStyleSheet Interface CSS Rules Definition Media Rule Keyframe Rule Add/Remove CSS Rules DOM Events Events Checking Global DOM Event Tab Visibility Event Form Events Input Events Mouse Events Key Events Clipboard Event Frame Events User-Defined Handler Document Window location API Rect API width/height Window Height Scroll Size DOM left/top Property Mutation Observer API Ajax 基本用法 简单封装 跨域请求 JSON jQuery 正则表达式 Flags 元字符 常用限定符 反向引用 RegExp 静态属性 分组语法 Best Practice(提升效率) RegExp 常用函数 test replace replace arguments replace best practice 常用正则表达式 中英文 数字 空字符与空格字符 错误处理(Error/Exception) 错误类型 异常作用 Asynchronous Programming Promise Promise.all Promise Polyfill await/async Await Arrays Sleep Function Race Condition Geolocation API Web Audio API From Oscillator From Music Data Audio Bar Chart with Canvas Web Storage API Web Navigator API Web Files API Web Sockets API Web RTC API Web Workers API Web Animations API Web Canvas API Basic Usage Game Loop With Canvas Canvas Performance Canvas Reference Gamepad API URL API Observer API Intersection Observer 常量 常数值 加括号 可转化为对象 变量 原始数据类型值 Primitive type Undefined Null Boolean Number String undefined 对象属性未定义时，该属性值为 undefined 未初始化变量的初值为 undefined(表示 等待被赋值) var undefined = void null; var undefined = void 1; var undefined = function () {}; ;(fucntion (undef) { var undefined = undef; })(); null 当引用为空或引用对象不存在时，值为 null float 计算浮点数时，应先计算整数，再利用移位/乘法/除法转化为浮点数 var a = (1 + 2) / 10; // a = 0.1 + 0.2; 非数 NaN typeof NaN; // 'number' NaN === NaN; // false isNaN(); isFinite(); function isNumber(value) { return typeof value === 'number' && isFinite(value); } number Infinity Infinity represents all values greater than 1.7976931348623157e+308. Infinity will be converted to null with JSON.stringify(). const largeNumber = 1.7976931348623157e308; const largerNumber = 1.7976931348623157e309; console.log(largeNumber); // 1.7976931348623157e+308 console.log(largerNumber); // Infinity console.log(46 / 0); // Infinity console.log(Number.POSITIVE_INFINITY); // Infinity console.log(Number.MAX_VALUE); // Infinity console.log(-1.7976931348623157e309); // -Infinity console.log(-46 / 0); // -Infinity console.log(Number.NEGATIVE_INFINITY); // -Infinity console.log(Number.MIN_VALUE); // -Infinity console.log(Math.max()); // -Infinity console.log(Math.min()); // Infinity string 引用特性 赋值与传参 传递 string 字符串常量 的引用 所有 string 量 都是不可变量,当对 string 进行操作后，将先会在堆区创建副本，再通过副本进行修改，并返回副本的索引 没有被任何变量引用的 string: 垃圾回收 const goodString = \"I've been a good string\"; console.log(typeof goodString); // string console.log(goodString instanceof String); // false console.log(Object.prototype.toString.call(goodString)); // [object String] const badString = new String(\"I've been a naughty string\"); console.log(typeof badString); // object console.log(badString instanceof String); // true console.log(Object.prototype.toString.call(badString)); // [object String] const isPrimitiveString = value => typeof value === 'string'; console.log(isPrimitiveString(goodString)); // true console.log(isPrimitiveString(badString)); // false const isObjectWrappedString = value => value instanceof String; console.log(isObjectWrappedString(goodString)); // false console.log(isObjectWrappedString(badString)); // true const isString = value => typeof value === 'string' || value instanceof String; console.log(isString(goodString)); // true console.log(isString(badString)); // true const isStringAlternative = value => Object.prototype.toString.call(badString) === '[object String]'; console.log(isStringAlternative(goodString)); // true console.log(isStringAlternative(badString)); // true 非对象特性(基本变量) 字符串中的字符不可枚举(for in 循环) delete 无法删除某位字符 基本操作 +=: 字符串连接操作 Object Wrappers for Primitive Type Using the wrapper function without the new keyword is a useful way of coercing a value into a primitive type. // Not recommended (primitive object wrapper): typeof new String(37); // object // Safe (type coercion with wrapper function): typeof String(37); // string // Primitive strings: '37' === '37'; // true // Object-wrapped string: '37' === new String(37); // false // Type-coerced string: '37' === String(37); // true 引用类型值 Object type Object e.g Date Array Function 反模式: 隐式全局变量(未使用 var 声明便使用变量) 实质:隐式全局变量不是真正的变量，而是全局对象(在浏览器环境中为 window 对象)的属性;可以delete删除隐式全局量 //函数外隐式全局变量 global = 1; //函数内隐式全局变量 function () { global = 1; } //链式赋值 function () { //b为隐式全局变量 var a = b = 1; } Date Definitive Guide const now= new Date(); now.getFullYear(); // 1-n now.getMonth(); // Warn: 0-11 now.getDate(); // 1-n now.getDay(): // Warn: 0-6 now.toString(); now.toDateString(); now.toTimeString(); now.toLocaleString(); now.toLocaleDateString(); now.toLocaleTimeString(); const daysOfMonth = (year, month) => { // `0` for last month of next month return (new Date(year, month + 1, 0)).getDate(); }; const prevYear = (year) => { return (new Date(year - 1, 0)).getFullYear(); } const nextYear = (year) => { return (new Date(year + 1, 0)).getFullYear(); } const prevMonth = (year, month) => { return (new Date(year, month - 1)).getMonth(); }; const nextMonth = (year, month) => { return (new Date(year, month + 1)).getMonth(); }; const getDateItemList = (year, month) => { const days = daysOfMonth(year, month); const currentDateItemList = [...Array(days).keys()].map(index => { return DateItem(year, month, 1 + index); }); const firstDayItem = DateItem(year, month, 1); const firstDayWeekday = firstDayItem.day; const lastMonthDays = daysOfMonth(year, month - 1); const prefixDays = firstDayWeekday === 0 ? 7 : firstDayWeekday; const prefixFirstDay = lastMonthDays - prefixDays + 1; const prefixYear = prevYear(year); const prefixMonth = prevMonth(year, month); const prefixDateItemList = [...Array(prefixDays).keys()].map(index => { return DateItem(prefixYear, prefixMonth, prefixFirstDay + index); }); const lastDayItem = DateItem(year, month, days); const lastDayWeekday = lastDayItem.day; const suffixDays = lastDayWeekday === 6 ? 7 : 6 - lastDayWeekday; const suffixYear = nextYear(year); const suffixMonth = nextMonth(year, month); const suffixDateItemList = [...Array(suffixDays).keys()].map(index => { return DateItem(suffixYear, suffixMonth, 1 + index); }); const dateItemList = [ ...prefixDateItemList, ...currentDateItemList, ...suffixDateItemList ]; return dateItemList; }; 全局变量 定义在函数体外，在函数体内不使用 var 关键字引用 局部变量 函数体内使用 var 关键字定义 不使用 var 声明变量将会导致隐式的全局变量 声明局部变量时绝对不要遗漏 var 关键字 变量提升 Hoisting var 表达式和 function 声明都将会被提升到当前作用域(全局作用域/函数作用域)的顶部, 其余表达式顺序不变 // 我们知道这个行不通 (假设没有未定义的全局变量) function example() { console.log(notDefined); // => throws a ReferenceError } // 在引用变量后创建变量声明将会因变量提升而起作用。 // 注意: 真正的值 `true` 不会被提升。 function example() { console.log(declaredButNotAssigned); // => undefined var declaredButNotAssigned = true; } // 解释器将变量提升到函数的顶部 // 这意味着我们可以将上边的例子重写为： function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // => undefined declaredButNotAssigned = true; } // 使用 const 和 let function example() { console.log(declaredButNotAssigned); // => throws a ReferenceError console.log(typeof declaredButNotAssigned); // => throws a ReferenceError const declaredButNotAssigned = true; } function example() { console.log(named); // => undefined named(); // => TypeError named is not a function superPower(); // => ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } 数组(与 Object 同源) 关联数组：arrayName[“string”] = value; 实际为 Array 对象添加属性{string:value} 缓存数组长度:int l = list.length(访问length造成运算) []数组，{}对象 数组在 数值运算环境 中转化为 0(空数组)/num(单一元素数组)/NaN(多元素数组/NaN 数组) length 数组下标满足 [0, 2^32-1) 即可 运用大于 length 的下标, length 自动增大，不会发生数组边界错误 length 等于 数组最后一个整数属性名+1, length 不一定等于 数组中有效元素个数 数组字面量 不使用构造函数,使用数组字面量创建数组 new Array(3); // 数组长度 new Array(3.14); // RangeError if (typeof Array.isArray === 'undefined') { Array.isArray = function(arg) { // 其余对象返回值 [object Object/Number/String/Boolean] return Object.prototype.toString.call(arg) === '[object Array]'; }; } 常用方法 sort arr.sort(toExchange); var toExchange = function(a, b) { return 1; // a, b 交换位置 return -1; // a, b 不交换位置 }; 堆栈 arr.unshift(value); // 添加数组首元素 arr.push(value); // 添加数组尾元素 arr.shift(); // 删除数组首元素 arr.pop(); // 删除数组尾元素 分割/合并 slice 不改变原数组, splice 改变原数组 [].concat(otherArray); [string].join('连接符'); // 将字符串数组连接成字符串o string(charArray).split('割断点'); // 选择割断符,返回字符串数组 [].slice(start, end); // [start] - [end - 1] [].splice(); // 功能强大的多态方法 替换 [].replace(oldSubStr, newStr); 查询 ''.substr(start, end); [].indexOf(char); // -1 or other 遍历 [] / obj.forEach(function(val) {}); // 遍历数组/对象所有元素(val为单个元素) Deep Clone of Array let nestedArray = [1, [2], 3]; let arrayCopy = JSON.parse(JSON.stringify(nestedArray)); // Make some changes arrayCopy[0] = '1'; // change shallow element arrayCopy[1][0] = '3'; // change nested element console.log(arrayCopy); // [ '1', [ '3' ], 3 ] // Good: Nested array NOT affected console.log(nestedArray); // 1, [ 2 ], 3 ] 其他 [].reverse(); // Tips // 反转字符串 var reverseStr = normalizedStr .split('') .reverse() .join(''); Array Tips 对字符串每个元素进行单独操作 e.g map/filter str .split('') .map(function(subStr) { return decode(subStr.charCodeAt(0)); }) .join(''); str .split('') .someOperator() .join(''); 实现 contains 方法 arr.indexOf(item) === -1; 改变某一处字母 after = after.charAt(0).toUpperCase() + after.slice(1); 删除只能指定元素 arr.splice(index, 1); Remove Duplicate Elements // 1: \"Set\" [...new Set(array)]; // 2: \"Filter\" array.filter((item, index) => array.indexOf(item) === index); // 3: \"Reduce\" array.reduce( (unique, item) => (unique.includes(item) ? unique : [...unique, item]), [] ); 高阶函数 [].map((item) => {}); // map over [].filter((item) => {}); // list comprehension [].reduce((previous, current [, currentIndex, arr]) => {}, initial); // fold function 类型检测 Best Practice function typeOf(o) { var _toString = Object.prototype.toString, _type = { undefined: 'undefined', number: 'number', boolean: 'boolean', string: 'string', '[object Function]': 'function', '[object Array]': 'array', '[object Date]': 'date', '[object RegExp]': 'regexp', '[object Error]': 'error', '[object JSON]': 'json' }; return _type[typeof o] || _type[_toString.call(o)] || (o ? 'object' : 'null'); } Null 检测 不应使用 typeof 检测 null, 应使用 ===/!== /* * ECMAScript 标准的重大 bug */ typeof null; // => object 自定义对象检测 value instanceof constructor(查找原型链) 属性检测 由于属性值可能为 0 值表达式, 不应使用 0 值表达式(0/''/null/undefined) 检测属性值 应使用 for in 进行属性检测 强制类型转化(Type Coercion) 字符串 -> 整数：+string/Number(string)/parseInt(string, arg1) any -> bool：!!any const -> object: (const) parseInt(): 遇到非数字字符立即停止运行，返回当前转化值; 将 0 开头字符串解析为八进制数，0x 开头字符串解析为十六进制数 parseInt(str, base); boolean 在 数值运算环境 中 true => 1, false => 0 数组在 数值运算环境 中 转化为 0(空数组)/num(单一元素数组)/NaN(多元素数组/NaN 数组) 对象在 逻辑运算环境 中 转化为 true , 包括 false 的封装对象 对象在 数值运算环境 中 先利用 valueOf(object), 再利用 toString() 转化为数字, 若转化失败, 则返回 NaN 对象与 数值加号运算: 先数值加, (失败后)再字符串加 // good const totalScore = String(this.reviewScore); // good const val = Number(inputValue); // good const val = parseInt(inputValue, 10); // good const hasAge = Boolean(age); // best const hasAge = !!age; 对象转换 对象转换为布尔值: 直接转换为 true（包装类型也一样），不调用 valueOf 和 toString 对象转换为数字: 如果对象具有 valueOf 方法且返回原始值(string、number、boolean、undefined、null)， 则将该原始值转换为数字(转换失败会返回 NaN)，并返回这个数字 如果对象具有 toString 方法且返回原始值(string、number、boolean、undefined、null)， 则将该原始值转换为数字(转换失败会返回 NaN)，并返回这个数字 转换失败，抛出 TypeError 对象转换为字符串: 如果对象具有 toString 方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 如果对象具有 valueOf 方法且返回原始值(string、number、boolean、undefined、null)，则将该原始值转换为字符串，并返回该字符串 转换失败，抛出 TypeError // 保存原始的valueOf const valueOf = Object.prototype.valueOf; const toString = Object.prototype.toString; // 添加valueOf日志 Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this); }; // 添加toString日志 Object.prototype.toString = function () { console.log('toString'); return toString.call(this); }; const a = {}; const b = new Boolean(false); if (a) { console.log(1); } if (b) { console.log(2); } // output: // 1 // 2 // 未调用valueOf和toString，符合 [对象到布尔值] 的转换规则 // 保存原始的valueOf const valueOf = Object.prototype.valueOf; const toString = Object.prototype.toString; // 添加valueOf日志 Object.prototype.valueOf = function() { console.log('valueOf'); return valueOf.call(this); }; // 添加toString日志 Object.prototype.toString = function() { console.log('toString'); return toString.call(this); }; let a = {}; console.log(++a); // output: // valueOf // toString // NaN // 1. valueOf方法返回的是对象本身，不是原始值，继续执行 // 2. toString方法返回的是”[object Object]”，是原始值(字符串)，将字符串转换为数字NaN // 保存原始的valueOf const valueOf = Object.prototype.valueOf; const toString = Object.prototype.toString; // 添加valueOf日志 Object.prototype.valueOf = function () { console.log('valueOf'); return \"1\"; // 强制返回原始值 }; // 添加toString日志 Object.prototype.toString = function () { console.log('toString'); return toString.call(this); }; let a = {}; console.log(++a); // output: // valueOf // 2 // valueOf 返回原始值(字符串)，直接将该字符串转换为数字，得到 1 // 保存原始的valueOf const valueOf = Object.prototype.valueOf; const toString = Object.prototype.toString; // 添加valueOf日志 Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this); }; // 添加toString日志 Object.prototype.toString = function () { console.log('toString'); return toString.call(this); }; const a = {}; alert(a); // output: // toString // 弹出 \"[object Object]\" // 调用toString方法，返回了字符串”[object Object]”，对象最终转换为该字符串 // 保存原始的valueOf const valueOf = Object.prototype.valueOf; const toString = Object.prototype.toString; // 添加valueOf日志 Object.prototype.valueOf = function () { console.log('valueOf'); return valueOf.call(this); }; // 添加toString日志 Object.prototype.toString = function () { console.log('toString'); return this; }; const a = {}; alert(a); // output: // toString // valueOf // Uncaught TypeError: Cannot convert object to primitive value // 调用toString方法，返回的不是 primitive value，继续执行 // 调用valueOf方法，返回的不是 primitive value，继续执行 // 抛出 TypeError 运算符 == 与 === != 与 !== Loose Comparison JS Loose Comparison: Type(x) === Type(y): return x === y (Strict Equality Comparison) Type(x) !== Type(y): x and y are undefined or null: return true return comparsion between ToNumber(x) and ToPrimitive(y) 条件表达式 养成使用分号结束句子的习惯, 需分行显示的语句必须确保单行不会形成完整语义 var i = a ? 1 : b ? 2 : c ? 3 : 4; Add Operator a + b: 如果有一个是对象，则遵循对象对原始值的转换过程 (Date对象直接调用toString完成转换， 其他对象通过valueOf转化， 如果转换不成功则调用toString) 如果两个都是对象，两个对象都遵循步骤1转换到字符串 两个数字，进行算数运算 两个字符串，直接拼接 一个字符串一个数字，直接拼接为字符串 控制流程 switch/case 用方法查询代替 switch/case 语句 function doAction(action) { var actions = { hack: function() { return 'hack'; }, slash: function() { return 'slash'; }, run: function() { return 'run'; } }; if (typeof actions[action] !== 'function') { throw new Error('Invalid action.'); } //闭包方法集 return actions[action](); } 对象 对象三大特征 原型代理(享元模式): 利用享元模式共享公有属性与通用方法 实例状态(原型克隆): 利用原型克隆拥有各自属性值 封装性(闭包式继承): 利用闭包方法实现属性私有化 即共用方法,单独属性,封装细节 原型链 实例化对象仅有属性__proto__, 没有属性prototype, 函数才具有属性 prototype (指向引擎为其自动创建的原型对象) 所有引用类型 (包括对象/数组/函数/构造函数) 都有属性__proto__(隐式原型) 所有函数/构造函数的 __proto__ 都指向 Function.prototype 除Object.prototype.__proto__指向 null 外, 其余函数/构造函数的原型对象的__proto__ 都指向 Object.prototype 除Object.create()外, 所新建对象的 __proto__ 指向构造该对象的构造函数的原型对象(prototype) 除typeof Function.prototype 为 'function' 外, 其余函数/构造函数的原型对象都为 '对象'(typeof 为 'object') 先有Object.prototype(原型链顶端), Function.prototype 继承Object.prototype而产生, 最后Object/Function/Array/其它构造函数继承Function.prototype而产生 Object ---__proto__--> Function.prototype ---__proto__ --> Object.prototype ---__proto__--> null function Foo(value) { this.val = value; } // auto create FooPrototype // Foo.prototype -> FooPrototype // FooPrototype.constructor -> [function Foo] // // foo.__proto__ -> FooPrototype const foo = new Foo(2); // true because of `Object` is `function Object()` and inherited from `Function.prototype` // Object has its own `prototype` property refer to `Object.prototype` Object.__proto__ === Function.prototype; // true because of `Array` is `function Array()` and inherited from `Function.prototype` // Array has its own `prototype` property refer to `Array.prototype` Array.__proto__ === Function.prototype; // true because of Function is `function Function()` and inherited from `Function.prototype` // Function has its own `prototype` property refer to `Function.prototype` Function.__proto__ === Function.prototype; // true because of Object.protoype is the top of inheritance chains (null is Object.prototype.__proto__) // all `object/function/array instance`.__proto__......__proto__ refer to Object.prototype Function.__proto__.__proto__ === Object.prototype; // => Object instanceof Function; // true Function instanceof Object; // true 构造函数 首字母大写 所有函数(包括构造函数)有 prototype 属性 构造对象的三种形式 对象字面量 对象字面量由 Object 构造函数 隐式构造 var obj = { name: 'sabertazimi' }; console.log(obj.__proto__ === Object.prototype); // true new 构造函数 new 构造函数作用原理如下: 形成原型链: 隐式原型指向构造函数的原型对象 obj.__proto__ = constructor.prototype 构造函数对象(Constructor)与原型对象(Prototype)之间形成闭环: Constructor.prototype = Prototype Prototype.constructor = Constructor function newInstance(constructor){ //var this = Object.create(Person.prototype); // this.__proto__ = F.prototype // F.prototype = Person.prototype // 即 this.__proto__ = Person.prototype; var obj = {}; obj.__proto__ = constructor.prototype; constructor.apply(obj,sliceArguments(arguments,1)); return obj; } => new Constructor(arguments); function Employee(name) { this.name = name; this.getName = function () { return this.name}; } var employee = newInstance(Empolyee,'Jack'); => var employee = new Employee('Jack'); Object.create Object.create = function(o) { if (arguments.length > 1) { throw new Error( 'Object.create implementation' + ' only accepts the first parameter.' ); } function F() {} F.prototype = o; return new F(); }; 返回值 返回 this 或 user-defined literal object 当返回值为基本类型时,仍然可得到 this 指针指向的原有对象 var ObjectMaker = function() { this.name = 'This is it'; //user-defined literal object //直接忽略this.name var that = {}; that.name = \"And that's that\"; return that; }; instanceof 若 在实例对象的原型链(__proto__)中 能找到 构造函数的prototype属性(Prototype 对象), 则返回true, 否则返回false // true only if // 1. Foo.__proto__ === Bar.prototype // 2. Foo.__proto__......__proto__ === Bar.prototype Foo instance of Bar 最佳实践 function Waffle() { //当未使用new关键字时,this指向全局对象 //此时进入if语句 if (!(this instanceof Waffle)) { return new Waffle(); } //正常构造函数 this.tastes = 'yummy'; } 全局对象 //立即函数模式: //此时返回值不是函数本身,而是函数执行后的return语句返回值 var global = (function() { //返回全局对象 return this; })(); 私有属性与特权方法 私有属性 实现方式: 闭包 function Gadget() { // private member var name = 'iPod'; // public function this.getName = function() { return name; }; } 特权方法 getter:返回基本类型值/引用类型深拷贝(POLA 最低授权原则) function Gadget() { // private member var pref = {}; // public function this.getPref = function() { return pref.clone(); }; } Best Practice: 即使函数模式 + 揭示模式 实现私有属性与私有方法 提供私有方法的公共(读/执行 not 写)接口,公共接口发生意外,私有方法仍安全 //匿名即时函数模式 var myobj = (function () { // private member var name = \"tazimi\"; // private method var getName = function getName() { return name; } // 闭包 return { // 公共接口 - 私有方法 getName: getName; }; }()); 静态属性与方法 静态属性 实现方式: 闭包/原型代理 静态方法 直接向构造函数添加方法 Object.isArray = function() {}; 模块化对象 命名空间+依赖模式+私有属性/特权方法+初始化模式+揭示模式(公共接口)+即时函数模式 package+import+private field/methods+constructor+public methods Best Practice: // 命名空间模式 MYAPP.namespace('MYAPP.utilities.array'); //形参: 导入全局变量 MYAPP.utilities.array = (function (app, global) { // start of var declare // 依赖模式 var uobj = MYAPP.utilities.object, ulang = MYAPP.utilities.lang, // 私有属性 arrStr = \"[object Array]\", toStr = Object.prototype.toString; // 私有方法 inArray = function (haystack, needle) { for (var i = 0, max = haystack.length; i 普通属性 编写函数时,一般用[]访问对象属性 普通方法 为 prototype 添加方法,可以通过实现语法糖 method()简化代码(链模式) if (typeof Function.prototype.method !== 'function') { Function.prototype.method = function(name, implementation) { this.prototype[name] = implementation; return this; }; } var Person = function(name) { this.name = name; } .method('getName', function() { return this.name; }) .method('setName', function(name) { this.name = name; return this; }); Class 式继承 代理构造函数(运用中继者) 可用于所有继承模式中,减少内存消耗 Best Practice: var inherit = (function() { // 减少继承过程中父类的实例化,减少资源消耗 // 实例化一个空类所需资源更少 var F = function() {}; return function(C, P) { // c.__proto__ = C.prototype = f // f.__proto__ = F.prototype // F.prototype = P.prototype // c.__proto__.__proto__ = f.__proto__ = P.prototype F.prototype = P.prototype; // f.__proto__ = F.prototype = P.prototype C.prototype = new F(); // C.prototype = f C.prototype.constructor = C; C.super = P.prototype; // 此句可提高代码的重用性 }; })(); Child.prototype.add = function() { return Child.super.add.call(this); }; 类继承(借用构造函数)与原型继承(设置原型) 混合继承模式 child.prototype = new Parent(); Parent.apply(this, arguments); 此模式会使得子类属性继承 2 次 Best Practice: function Parent(name) { this.name = name || 'Adam'; } // adding functionality to the prototype Parent.prototype.say = function() { return this.name; }; // child constructor function Child(name) { Parent.apply(this, arguments); } Child.prototype = new Parent(); // 设置原型链,建立继承关系 Child.prototype.constructor = Child; // 使得 Prototype 对象与 Constructor 对象形成闭环 kclass 语法糖 复制式地继承，将会消耗大量内存单元 Best Practice: var klass = function(Parent, props) { var Child, F, i; // 新的构造函数 Child = function() { if (Child.uber && Child.uber.hasOwnProperty('_construct')) { Child.uber._construct.apply(this, arguments); } if (Child.prototype.hasOwnProperty('_construct')) { Child.prototype._construct.apply(this, arguments); } }; // 类式继承 Parent = Parent || Object; // 代理构造函数F F = function() {}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.uber = Parent.prototype; Child.prototype.constructor = Child; // 添加属性与方法 for (i in props) { if (props.hasOwnProperty(i)) { Child.prototype[i] = props[i]; } } // return the \"class\" return Child; }; var SuperMan = klass(Man, { _construct: function(what) { console.log(\"SuperMan's constructor\"); }, getName: function() { var name = SuperMan.uber.getName.call(this); return 'I am ' + name; } }); 原型链继承 共享 - 原型代理(prototype) 构造函数的原型对象被设置为新实例的原型引用 f.prototype = o; if (!Object.create) { Object.create = function(o) { if (arguments.length > 1) { throw new Error( 'Object.create implementation' + ' only accepts the first parameter.' ); } function F() {} F.prototype = o; return new F(); }; } var switchProto = { isOn: function isOn() { return this.state; }, toggle: function toggle() { this.state = !this.state; return this; }, state: false }; var switchInstance = Object.create(switchProto); 独立 - 原型克隆 此时属性与方法不共享，实例对象各自拥有一份拷贝 浅克隆 _.extend = function(obj) { each(slice.call(arguments, 1), function(source) { for (var prop in source) { obj[prop] = source[prop]; } }); return obj; }; 深克隆 function extendDeep(parent, child) { var i, toStr = Object.prototype.toString, astr = '[object Array]'; child = child || {}; for (i in parent) { if (parent.hasOwnProperty(i)) { // 若属性为对象,则进行深克隆 if (typeof parent[i] === 'object') { child[i] = toStr.call(parent[i]) === astr ? [] : {}; extendDeep(parent[i], child[i]); } else { child[i] = parent[i]; } } } return child; } 属性混入 - 多重继承 function mix() { var arg, prop, child = {}; for (arg = 0; arg var cake = mix( { eggs: 2, large: true }, { butter: 1, salted: true }, { flour: '3 cups' }, { sugar: 'sure!' } ); 封装 - 工厂方法(闭包) function factory() { var highlander = { name: 'MacLeod' }; //利用闭包，返回私有对象，实现工厂方法 return { get: function get() { return highlander; } }; } 包装类对象 基本变量只会临时转变为包装类对象,若需添加额外属性/方法: new Number/String/Boolean(); 改变内置原型 // primitive string var greet = 'Hello there'; // primitive is converted to an object // in order to use the split() method greet.split(' ')[0]; // \"Hello\" // attemting to augment a primitive is not an error greet.smile = true; // but it doesn't actually work typeof greet.smile; // \"undefined\" 不使用 new 关键字,包装类构造函数返回值为基本类型 typeof Number(1); // \"number\" typeof Number('1'); // \"number\" typeof Number(new Number()); // \"number\" typeof String(1); // \"string\" typeof Boolean(1); // \"boolean\" 错误对象 { name: \"XXError\" message: \"something wrong\" extra: \"This was rather embarrassing\" remedy: genericErrorHandler //处理错误的函数名 } catch (e) { console.log(e.message); e.remedy(); // genericErrorHandler } 函数 函数是对象 函数提供局部作用域 Object 是 Function 的实例对象, Function.prototype是 Object 的实例对象 Object.__proto__ === Function.prototype; // true Function.__proto__ === Function.prototype; // true Function.__proto__.__proto__ === Object.prototype; // true Invocation Patterns and This Bindings Implicit Binding Function Invocation 普通调用模式: this 绑定至全局对象/undefined (strict mode) setTimeout 和 setInterval 中传入的 Callbacks 会自动转变为 Function Invocation, this bind to global/undefined object. 同理, React Class Component 中传入的 Event Handlers 会自动转变为 Function Invocation, 需要显式地 this.handleClick = this.handleClick.bind(this); Method Invocation 方法调用模式: this 绑定至此方法所属的对象 add(1, 2); // this -> global const obj = { value: 1, foo: function() { // 若不将 this 赋值给 that, 而在内部函数中直接使用 this.value // 则会发生错误: 内部函数的 this 指向全局对象而不是obj const that = this; function inner() { return that.value; } return inner(); } }; obj.foo(); // 1 class Hero { constructor(heroName) { this.heroName = heroName; } logName() { console.log(this.heroName); } } const batman = new Hero('Batman'); setTimeout(batman.logName, 1000); // after 1 second logs \"undefined\" Explicit Binding Apply/Bind/Call Invocation: 函数引用不可以改变函数定义作用域 (scope)，但可以改变函数执行作用域 (context) this.construct = Foo; this.construct(options); => Foo.call(this, options); Constructor Binding Constructor Invocation: this 绑定至传入的空对象 Arrow Function Binding this defined where arrow function defined (not called) (lexical scope) apply/call/bind can't change this in arrow function const obj = { foo: function() { const inner = () => { return this.value; }; return inner(); } }; const func = obj.foo; obj.foo(); // `this` in `inner` function refer to `obj` func(); // `this` in `inner` function refer to `window` prototype 实例化对象没有 prototype 属性 每个函数都有 prototype 属性 prototype 属性 指向 函数的原型对象 (由 js 引擎自动创建) 每个函数的 __proto__ 都指向 Function.prototype arguments 不是数组,但有 length 属性(实参个数) Array.prototype/[].func.apply(arguments, ...); arguments.callee 引用 arguments 所属 function, 可以利用 callee 实现匿名递归函数 arguments.callee.length: 形参个数 try { if (arguments.length !== arugments.callee.length) { throw new Error('传递的参数个数不匹配'); } } catch (err) { console.log(err); return this; } 作用域链 函数每次运行时，都会新建执行环境内部对象，执行完后销毁此对象 每个执行环境拥有独立的作用域链,例如 独立全局对象、独立活动对象, 可动态改变作用域链的语句: with/try catch(异常对象入列，位于作用域链链首) scope -> (list) [0]活动对象 -> [1]全局对象 全局对象 window 含有 全局对象如 window/document，全局方法，全局 this 指针等 活动对象(Activation Object) 函数表达式 //函数声明 function foo() {} //函数表达式 var foo = function foo() {}; var obj = { say: function say() {} }; //变量提升 var foo; foo = function foo() {}; console.log(foo.name); 函数声明对于函数内部而言无法修改 (const) var b = 10; (function b() { b = 20; console.log(b); })(); // print out function b { ... } 函数入参 无副作用的函数: 注意是否需要拷贝传入对象,使原有对象不受函数影响,并返回新对象 // 除非必要,否则不改变原有对象 var obj = { value: 2 }; function setValue(obj, val) { obj.value = val; return obj; } // 好习惯: 改变新对象,返回新对象 var obj = { value: 2 }; function setValue(obj, val) { var instance = extend({}, obj, { value: val }); return instance; } 回调函数 // check if callback is callable if (typeof callback !== 'function') { callback = false; } // now callback: if (callback) { callback(); } var findNodes = function(callback) { var i = 100000, nodes = [], found; // check if callback is callable if (typeof callback !== 'function') { callback = false; } while (i) { i -= 1; // now callback: if (callback) { callback(found); } nodes.push(found); } return nodes; }; 当回调函数为对象方法时(特别时方法中使用 this 指针),需同时传入对象参数,并利用 apply/call 改变执行环境 var findNodes = function(callbackObj, callback) { if (typeof callback === 'function') { callback.call(callbackObj, found); } }; var findNodes = function(callbackObj, callback) { if (typeof callback === 'string') { callback = callbackObj[callback]; } if (typeof callback === 'function') { callback.call(callbackObj, found); } }; 自定义函数/惰性函数定义 (Self-Defining Function)/(Lazy Function Definition) 第一次执行时,进行初始化并重新定义函数变量 第二次执行时,不再进行初始化(函数被重定义至真正函数) 第一次执行为 promise, 将重复使用的部分进行初始化，之后的调用不再浪费新空间，提高代码效率 //definition var foo = function() { // initialize code; var t = new Date(); foo = function() { return t; }; // 使得第一次调用可以产生预期值,保证每次调用的行为保持一致 return foo(); }; //first run: same behavoir as second run console.log(foo()); // t //second run console.log(foo()); // t var addEvent = function(el, type, handle) { addEvent = el.addEventListener ? function(el, type, handle) { el.addEventListener(type, handle, false); } : function(el, type, handle) { el.attachEvent('on' + type, handle); }; // 保持每次调用对外表现行为一致 addEvent(el, type, handle); }; 即时函数 即时函数自动执行(定义即执行)：匿名包装器 即时函数模式 函数表达式 末尾添加括号(传参),使函数立即执行 将整个函数置于括号内 (function() { console.log('watch out'); })(); 模式作用 使得匿名函数内部的代码能够立即执行 不泄漏只使用一次的局部变量与方法 创建命名空间，防止变量命名冲突 即时函数返回值 var foo = (function () {}()); foo 不被赋予 function 值,而被赋予函数执行后的返回值; 此返回值可设为函数可产生闭包。 var getResult = (function() { var res = 2 + 2; return function() { return res; }; })(); call/apply/bind Function.call(contextObj, arg1, arg2,...) Function.apply(contextArray, [arg1, arg2, ...]/arguments) call 效率高于 apply function.call/apply(); window.function.call/apply(); //js解释器临时将数组/字符串包装成对象原型 [].arrayStaticFunction.call/apply(); Array.prototype.arrayStaticFunction.call/apply(); \"\".stringStaticFunction.call/apply(); String.prototype.stringStaticFunction.call/apply(); 相当于 - context.function(arguments); bind change function runtime context (ignore innovation pattern function/method/new/call/apply) curry function can't change this in arrow function const bindedFunc = func.bind(context, arg1, arg2, ...); 通过 call/apply 实现 bind 函数 function bind(o, m) { return function() { return m.apply(o, [].slice.call(arguments)); }; } var one = { name: 'object', say: function(greet) { return greet + ', ' + this.name; } }, two = { name: 'another object' }, twosay = bind(two, one.say); twosay('yo'); // \"yo, another object\" 多态方法 var greet = function greet(options) { //运用slice方法与arguments隐参,得到参数对象/数组 //运用if/switch方法分情况调用函数,实现多态方法 var args = [].slice.call(arguments, 0); //方法集中含有此方法 if (typeof options === 'string' && typeof methods[options] === 'function') { action = options; //取第2个参数开始为真正的参数 args.shift(); } //调用对应方法,入参为args,返回调用值 return methods[action](args); }; hasOwnProperty: 使用其它对象的hasOwnProperty，并将其上下文设置为foo ({}).hasOwnProperty.call(foo, 'bar'); // true 推荐总是使用hasOwnProperty进行for in循环 eval 不要使用eval()函数 不要使用字符串作参数 new Function();(会调用eval函数) 不要使用字符串作setTimeOut/setInterval的第一个参数(会调用eval函数) // anti-pattern var property = 'name'; alert(eval('obj.' + property)); // preferred var property = 'name'; alert(obj[property]); // anti-pattern setTimeout('myFunc()', 1000); setTimeout('myFunc(1, 2, 3)', 1000); // preferred setTimeout(myFunc, 1000); setTimeout(function() { myFunc(1, 2, 3); }, 1000); 常用函数 Object Object.create(prototype[,descriptors]) var o = Object.create({ say: function() { alert(this.name); }, name: 'Byron' }); Object.defineProperty(O,Prop,descriptor) Object.defineProperties(O,descriptors) // value：值，默认是undefined // writable：是否是只读property，默认是false,有点像C#中的const // enumerable：是否可以被枚举(for in)，默认false // configurable：是否可以被删除，默认false // get:返回property的值得方法，默认是undefined // set：为property设置值的方法，默认是undefined ```js ```js Object.defineProperty(o,'age', { value: 24, writable: true, enumerable: true, configurable: true }); Object.defineProperty(o, 'sex', { value: 'male', writable: false, // 不可赋值 enumerable: false, // 不可遍历/枚举 configurable: false }); Object.defineProperties(o, { age: { value: 24, writable: true, enumerable: true, configurable: true }, sex: { value: 'male', writable: false, enumerable: false, configurable: false } }); Object.getOwnPropertyDescriptor(O,property) Object.getOwnPropertyNames Object.keys() - 仅获取可枚举的属性 var props = Object.getOwnPropertyDescriptor(o, 'age'); console.log(props); // Object {value: 24, writable: true, enumerable: true, configurable: true} console.log(Object.getOwnPropertyNames(o)); // [\"age\", \"sex\"] console.log(Object.keys(o)); // [\"age\"] Object.preventExtensions(O)/Object.isExtensible(O) - 不可新增属性，可删除/修改属性 Object.seal(O)/Object.isSealed(O) - 不可新增/删除属性，可修改属性 Object.freeze(O)/Object.isFrozen(O) - 不可新增/删除/修改属性 类型判断 Boolean(val); // true Array(val); // Array[] 解析函数 parseInt(val, 2 / 8 / 10); 数学函数 Math.floor(Math.random * arr.length); Math.min / Math.max; // 最小值/最大值 时间函数 setInterval Tips: 相当于一重循环 // 选择排序: 具有两重循环 let animation = setInterval(() => { // interval - (外)循环结束条件 if (i >= length) { clearInterval(animation); // 结束动画 setTimeout(() => { for (let n = 0; n { ele_arr[index].className = 'data-list__item'; }, 500); })(n); } }, 200); return; } // 内循环 j = i; temp = data_queue[i]; while (j > 0 && data_queue[j - 1] >= temp) { list_element.replaceChild( _createItemElement(data_queue[j - 1]), ele_arr[j] ); data_queue[j] = data_queue[j - 1]; ele_arr[j].className = 'data-list__item change'; (function(index) { setTimeout(() => { ele_arr[index].className = 'data-list__item'; }, 200); })(j); j--; } list_element.replaceChild(_createItemElement(temp), ele_arr[j]); data_queue[j] = temp; i++; }, 200); 常用模式 API 模式 回调模式 配置对象 var conf = { name: \"tazimi\", e-mail: \"test@gmail.com\" }; addPerson(conf); 返回函数(闭包) 一个函数的返回值设为另一个函数 Curry 化 链模式 return this; 初始化模式 即使函数 即使对象初始化 obj.init(); 初始化分支 浏览器探嗅:执行此功能的 if/else 语句只执行一次 检测浏览器对 H5/CSS3/ES5/ES2016 的支持情况,不足则自行编写函数补充功能. if (typeof target === 'undefined') { } 模块化 命名空间 通过传参匿名函数,创建命名空间,进行模块包裹 var app = {}; (function(exports) { (function(exports) { var api = { moduleExists: function test() { return true; } }; //闭包式继承,扩展exports对象为api对象 $.extend(exports, api); })(typeof exports === 'undefined' ? window : exports); //将api对象绑定至app对象上 })(app); // global object var MYAPP = {}; // constructors MYAPP.Parent = function() {}; MYAPP.Child = function() {}; // a variable MYAPP.some_var = 1; // an object container MYAPP.modules = {}; // nested objects MYAPP.modules.module1 = {}; MYAPP.modules.module1.data = { a: 1, b: 2 }; MYAPP.modules.module2 = {}; 通用命名空间函数 MYAPP.namespace = function(namespaceString) { var parts = namespaceString.split('.'), parent = MYAPP, i; // strip redundant leading global if (parts[0] === 'MYAPP') { // remove leading global parts = parts.slice(1); } for (i = 0; i // assign returned value to a local var var module2 = MYAPP.namespace('MYAPP.modules.module2'); module2 === MYAPP.modules.module2; // true // skip initial `MYAPP` MYAPP.namespace('modules.module51'); // long namespace MYAPP.namespace('once.upon.a.time.there.was.this.long.nested.property'); 沙盒模式 实现沙盒构造函数 私有属性绑定至 this/prototype 特权方法绑定至 modules/prototype function Sandbox() { // turning arguments into an array var args = Array.prototype.slice.call(arguments), // the last argument is the callback callback = args.pop(), // modules can be passed as an array or as individual parameters modules = args[0] && typeof args[0] === 'string' ? args : args[0], i; // make sure the function is called // as a constructor if (!(this instanceof Sandbox)) { return new Sandbox(modules, callback); } // add properties to `this` as needed: this.a = 1; this.b = 2; // now add modules to the core `this` object // no modules or \"*\" both mean \"use all modules\" if (!modules || modules === '*') { modules = []; for (i in Sandbox.modules) { if (Sandbox.modules.hasOwnProperty(i)) { modules.push(i); } } } // initialize the required modules for (i = 0; i // any prototype properties as needed Sandbox.prototype = { name: 'My Application', version: '1.0', getName: function() { return this.name; } }; 静态属性 - 使用添加的方法/模块 Sandbox.modules = {}; Sandbox.modules.dom = function(box) { box.getElement = function() {}; box.getStyle = function() {}; box.foo = 'bar'; }; Sandbox.modules.event = function(box) { // access to the Sandbox prototype if needed: // box.constructor.prototype.m = \"mmm\"; box.attachEvent = function() {}; box.dettachEvent = function() {}; }; Sandbox.modules.ajax = function(box) { box.makeRequest = function() {}; box.getResponse = function() {}; }; 沙盒使用方式 Sandbox(['ajax', 'event'], function(box) { // console.log(box); }); Sandbox('*', function(box) { // console.log(box); }); Sandbox(function(box) { // console.log(box); }); Sandbox('dom', 'event', function(box) { // work with dom and event Sandbox('ajax', function(box) { // another sandboxed \"box\" object // this \"box\" is not the same as // the \"box\" outside this function //... // done with Ajax }); // no trace of Ajax module here }); JavaScript DOM Basic Notes DOM Level 0 DOM Level 1 DOM Core DOM HTML DOM Level 2 DOM2 Core DOM2 HTML DOM2 Events DOM2 Style DOM2 Traversal DOM2 Range DOM2 Views DOM Level 3 DOM3 Core DOM3 Load and Save DOM3 Validation if (document.implementation) { document.implementation.hasFeature('HTML', '1.0'); // => DOM HTML } DOM - O native object: JavaScript Native e.g. Array host object: provided by Browser e.g. HTML5 API user-defined object element node text node attribute node DOM Core document.createElement('nodeName'); document.createTextNode('String'); cloneNode(); node.remove(); parentElement.appendChild(childElement); parentElement.insertBefore(newElement, targetElement); parentElement.removeChild(); parentElement.replaceChild(); parentElement.hasChildNode(); setAttribute(); getAttribute(); document.getElementById(); document.getElementsByTagName(); document.querySelector(); document.querySelectorAll(); const showAlert = (type, message, duration = 3) { const div = document.createElement('div'); div.className = type; div.appendChild(document.createTextNode(message)) container.insertBefore(div, form); setTimeout(() => div.remove(), duration * 1000); }; dynamic creation append var testdiv = document.getElementById('testdiv'); var para = document.createElement('p'); testdiv.appendChild(para); var txt = document.createTextNode('Hello World'); para.appendChild(txt); insert // 4 positions // // // // // foo // // // const p = document.querySelector('p'); p.insertAdjacentHTML('beforebegin', ''); p.insertAdjacentText('afterbegin', 'foo'); // simply be moved element, not copied element p.insertAdjacentElement('beforebegin', link); function insertAfter(newElement, targetElement) { var parent = targetElement.parentNode; if (parent.lastChild == targetElement) { parent.appendChild(newElement); } else { parent.insertBefore(newElement, targetElement.nextSibling); } } node node 除包括元素结点(tag)外，包括许多其它结点(甚至空格符视作一个结点),需借助 nodeType 找出目标结点 node.nodeType; nodeType representation 1 元素结点 2 属性结点 3 文本结点 node.nodeName; node.nodeValue; Traverse DOM Tree node.parentNode; node.childNodes; node.firstChild; node.lastChild; node.nextSibling; node.previousSibling; node.textContent; // returns closest ancestor of current element matching selectors node.closest(selectors); Element-only navigation: Navigation properties listed above refer to all nodes. For instance, in childNodes we can see both text nodes, element nodes, and even comment nodes if there exist. node.parentElement; node.children; node.firstElementChild; node.lastElementChild; node.previousElementSibling; node.nextElementSibling; Frag 减少 DOM 操作次数,减少页面渲染次数 var p, t, frag; frag = document.createDocumentFragment(); p = document.createElement('p'); t = document.createTextNode('first paragraph'); p.appendChild(t); frag.appendChild(p); p = document.createElement('p'); t = document.createTextNode('second paragraph'); p.appendChild(t); frag.appendChild(p); // 只渲染一次HTML页面 document.body.appendChild(frag); var oldnode = document.getElementById('result'), clone = oldnode.cloneNode(true); // work with the clone // when you're done: oldnode.parentNode.replaceChild(clone, oldnode); HTML DOM element.innerHTML; element.textContent; innerHTML: unconcrete,including all types of childNodes div.innerHTML = TesttestTest. TesttestTest. document.body; documents.images; documents.links; documents.forms; documents.forms[0].elements; //第一个表单内的所有字段 element.alt = string; element.classname = value; document.querySelector('cssSelector'); document.querySelectorAll('cssSelector'); CSSOM The CSS Object Model is a set of APIs allowing the manipulation of CSS from JavaScript. It is much like the DOM, but for the CSS rather than the HTML. It allows users to read and modify CSS style dynamically. Inline Styles element.style.*; element.style.fontFamily; element.style.marginTopWidth; Get/Set Styles getPropertyValue setProperty removeProperty item getPropertyPriority: return '' or important let box = document.querySelector('.box'); box.style.setProperty('color', 'orange'); box.style.setProperty('font-family', 'Georgia, serif'); op.innerHTML = box.style.getPropertyValue('color'); op2.innerHTML = `${box.style.item(0)}, ${box.style.item(1)}`; box.style.setProperty('font-size', '1.5em'); box.style.item(0); // \"font-size\" document.body.style.removeProperty('font-size'); document.body.style.item(0); // \"\" Computed Styles shorthand style for full property longhand style for specific property getPropertyValue can get css variables too window.getComputedStyle(document.body).background; // dot notation, same as above window.getComputedStyle(el).backgroundColor; // square bracket notation window.getComputedStyle(el)['background-color']; // using getPropertyValue() // can get css variables property too window.getComputedStyle(el).getPropertyValue('background-color'); CSS Class element.classList.add; element.classList.remove; element.classList.toggle; Tip: bind class function addClass(element, value) { if (!element.className) { element.className = value; } else { newClassName = element.className; newClassName += ' '; newClassName += value; element.className = newClassName; } } CSSStyleSheet Interface CSS Rules Definition type of cssRules: STYLE_RULE (1), IMPORT_RULE (3), MEDIA_RULE (4), KEYFRAMES_RULE (7) selectorText property of rules style property of rules let myRules = document.styleSheets[0].cssRules, p = document.querySelector('p'); for (i of myRules) { if (i.type === 1) { p.innerHTML += `${i.selectorText}`; } if (i.selectorText === 'a:hover') { i.selectorText = 'a:hover, a:active'; } const myStyle = i.style; // Set the bg color on the body myStyle.setProperty('background-color', 'peachpuff'); // Get the font size of the body myStyle.getPropertyValue('font-size'); // Get the 5th item in the body's style rule myStyle.item(5); // Log the current length of the body style rule (8) myStyle.length; // Remove the line height myStyle.removeProperty('line-height'); // log the length again (7) myStyle.length; // Check priority of font-family (empty string) myStyle.getPropertyPriority('font-family'); } Media Rule conditionText property of media rule nested cssRules let myRules = document.styleSheets[0].cssRules, p = document.querySelector('.output'); for (i of myRules) { if (i.type === 4) { p.innerHTML += `${i.conditionText}`; for (j of i.cssRules) { p.innerHTML += `${j.selectorText}`; } } } Keyframe Rule name property of keyframe rule nested cssRules: keyText property of rules let myRules = document.styleSheets[0].cssRules, p = document.querySelector('.output'); for (i of myRules) { if (i.type === 7) { p.innerHTML += `${i.name}`; for (j of i.cssRules) { p.innerHTML += `${j.keyText}`; } } } Add/Remove CSS Rules let myStylesheet = document.styleSheets[0]; console.log(myStylesheet.cssRules.length); // 8 document.styleSheets[0].insertRule( 'article { line-height: 1.5; font-size: 1.5em; }', myStylesheet.cssRules.length ); console.log(document.styleSheets[0].cssRules.length); // 9 let myStylesheet = document.styleSheets[0]; console.log(myStylesheet.cssRules.length); // 8 myStylesheet.deleteRule(3); console.log(myStylesheet.cssRules.length); // 7 DOM Events For click/keydown events: event.prevetDefault() event.stopPropagation() element.dispatchEvent to trigger events. Events Checking node.matches(event.target); // return false or true node.contains(event.target); // return false or true Global DOM Event DOMContentLoaded: 当文档中没有脚本时, 浏览器解析完文档便能触发 DOMContentLoaded 事件 如果文档中包含脚本, 则脚本会阻塞文档的解析, 而脚本需要等 CSSOM 构建完成才能执行 在 DOM、CSSOM 构建完毕, defer 脚本执行完成之后, DOMContentLoaded 事件触发 HTML 文档构建不受 async 脚本影响, 不需要等待 async 脚本执行与样式表加载, HTML 解析完毕后, DOMContentLoaded 立即触发 在任何情况下, DOMContentLoaded 的触发不需要等待图片等其他资源加载完成 当 HTML 文档解析完成就会触发 DOMContentLoaded, 而所有资源加载完成之后, load 事件才会被触发 document.addEventListener('DOMContentLoaded', event => { console.log('DOM fully loaded and parsed.'); }); Tab Visibility Event 切换标签页时改变网页标题/声音/视频 window.addEventListener('visibilitychange', () => { switch (document.visibilityState) { case 'hidden': console.log('Tab隐藏'); break; case 'visible': console.log('Tab被聚焦'); break; } }); const videoElement = document.getElementById('videoElement'); // Autoplay the video if application is visible if (document.visibilityState == 'visible') { videoElement.play(); } // Handle page visibility change events function handleVisibilityChange() { if (document.visibilityState == 'hidden') { videoElement.pause(); } else { videoElement.play(); } } document.addEventListener('visibilitychange', handleVisibilityChange, false); Form Events checkValidity API FromData API // const onSubmit = event => { event.preventDefault(); const form = event.target; const isValid = form.checkValidity(); // returns true or false const formData = new FormData(form); const validationMessages = Array.from(formData.keys()).reduce((acc, key) => { acc[key] = form.elements[key].validationMessage; return acc; }, {}); setErrors(validationMessages); console.log({ validationMessages, data, isValid }); if (isValid) { // here you do what you need to do if is valid const data = Array.from(formData.keys()).reduce((acc, key) => { acc[key] = formData.get(key); return acc; }, {}); } }; Input Events focus/focusin/focusout event input/change event select event const input = document.querySelector('input'); input.addEventListener('select', (event) => { const log = document.getElementById('log'); const selection = event.target.value.substring(event.target.selectionStart, event.target.selectionEnd); log.textContent = `You selected: ${selection}`; }); Mouse Events onclick; ondbclick; onmouse - down / move / enter / out / leave / over; For click event, no need for X/Y to judge internal/outside state. Use DOM API element.contains to check is a better way. window.addEventListener('click', (event) => { if (document.getElementById('main').contains(event.target) { // ... } }); Drag Event: dragstart dragend dragover dragenter dragleave drop Context Menu Event: const noContext = document.getElementById('noContextMenu'); noContext.addEventListener('contextmenu', e => { e.preventDefault(); }); Key Events onkeypress/up/down document.onkeydown = function(event) { var e = event || window.event || arguments.callee.caller.arguments[0]; if (e && e.keyCode == 13) { // enter 键 //coding } }; event.key => keyName 'Alt'; 'CapsLock'; 'Control'; 'Fn'; 'Numlock'; 'Shift'; 'Enter'; 'Tab'; ' '; // space bar 'ArrowDown'; 'ArrowLeft'; 'ArrowRight'; 'ArrowUp'; 'Home'; 'End'; 'PageDOwn'; 'PageUp'; 'Backspace'; 'Delete'; 'Redo'; 'Undo'; Clipboard Event copy cut paste const source = document.querySelector('div.source'); source.addEventListener('copy', (event) => { const selection = document.getSelection(); event.clipboardData.setData('text/plain', selection.toString().concat('copyrihgt information') ); event.preventDefault(); }); Frame Events onresize / load / scroll / error; User-Defined Handler function myHandler(e) { var src, parts; // get event and source element e = e || window.event; src = e.target || e.srcElement; // 事件授权 if (src.nodeName.toLowerCase() !== 'button') { return; } // actual work: update label parts = src.innerHTML.split(': '); parts[1] = parseInt(parts[1], 10) + 1; src.innerHTML = parts[0] + ': ' + parts[1]; // no bubble if (typeof e.stopPropagation === 'function') { e.stopPropagation(); } if (typeof e.cancelBubble !== 'undefined') { e.cancelBubble = true; } // prevent default action if (typeof e.preventDefault === 'function') { e.preventDefault(); } if (typeof e.returnValue !== 'undefined') { e.returnValue = false; } } Document document.write(); document.URI; document.title; Window window.location(string); window.innerWidth(number); window.closed(boolean); Tip: 实现 jQuery 中`$(document).ready(function(){}); //initialize window.onload = readyFunction; function readyFunction() { function() {} } //add more ready function function addLoadEvent(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function() { oldonload(); func(); }; } } location API 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚） host 设置或返回主机名和当前 URL 的端口号 hostname 设置或返回当前 URL 的主机名 href 设置或返回完整的 URL pathname 设置或返回当前 URL 的路径部分 port 设置或返回当前 URL 的端口号 protocol 设置或返回当前 URL 的协议 search 设置或返回从问号 (?) 开始的 URL（查询部分） window.addEventListener( 'hashchange', event => { // event.oldURL // event.nweURL if (location.hash === '#somecoolfeature') { somecoolfeature(); } }, false ); Rect API getBoundingClientRect width/height offsetWidth/offsetHeight = content + padding + border clientWidth/clientHeight = content + padding const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; Window Height outerHeight: 是整个浏览器窗口的大小，包括窗口标题、工具栏、状态栏等 innerHeight: 是 DOM 视口的大小，包括滚动条 offsetHeight: 整个可视区域大小，包括 border 和 scrollbar 在内 clientHeight: 内部可视区域大小 scrollHeight: 元素内容的高度，包括溢出部分 In case of transforms, the offsetWidth and offsetHeight returns the layout width and height (all the same), while getBoundingClientRect() returns the rendering width and height. Scroll Size scrollTop/scrollY/pageYOffset: 元素内容向上滚动了多少像素，如果没有滚动则为 0 scrollLeft/scrollX/PageXOffset: 元素内容向右滚动了多少像素，如果没有滚动则为 0 const supportPageOffset = window.pageXOffset !== undefined; const isCSS1Compat = (document.compatMode || '') === 'CSS1Compat'; const x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft; const y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop; if (window.innerHeight + window.pageYOffset === document.body.scrollHeight) { console.log('Scrolled to Bottom!'); } DOM left/top Property offsetLeft/offsetTop: 表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent 对象）左上角的距离 scrollLeft/scrollTop: 元素滚动条位置, 被隐藏的内容区域左侧/上方的像素大小 const isElementInViewport = el => { const { top, height, left, width } = el.getBoundingClientRect(); const w = window.innerWidth || document.documentElement.clientWidth; const h = window.innerHeight || document.documentElement.clientHeight; return top = 0 && left = 0; }; Mutation Observer API 如果文档中连续插入 1000 个 元素，就会连续触发 1000 个插入事件， 执行每个事件的回调函数，这很可能造成浏览器的卡顿； 而 Mutation Observer 完全不同，只在 1000 个段落都插入结束后才会触发，而且只触发一次. Mutation Observer 有以下特点: 它等待所有脚本任务完成后，才会运行，即采用异步方式 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动 它即可以观察发生在 DOM 节点的所有变动，也可以观察某一类变动 const mutationObserver = new MutationObserver(mutations => { mutations.forEach(mutation => { console.log(mutation); }); }); // 开始侦听页面的根 HTML 元素中的更改。 mutationObserver.observe(document.documentElement, { attributes: true, characterData: true, childList: true, subtree: true, attributeOldValue: true, characterDataOldValue: true }); const target = document.querySelector('#container'); const callback = (mutations, observer) => { mutations.forEach(mutation => { switch (mutation.type) { case 'attributes': // the name of the changed attribute is in // mutation.attributeName // and its old value is in mutation.oldValue // the current value can be retrieved with // target.getAttribute(mutation.attributeName) break; case 'childList': // any added nodes are in mutation.addedNodes // any removed nodes are in mutation.removedNodes break; } }); }; const observer = new MutationObserver(callback); observer.observe(target, { attributes: true, attributeFilter: ['foo'], // only observe attribute 'foo' attributeOldValue: true, childList: true }); Ajax 基本用法 var XHR = (function() { var standard = { createXHR: function() { return new XMLHttpRequest(); } }, newActionXObject = { createXHR: function() { return new ActionXObject('Msxml12.XMLHTTP'); } }, oldActionXObject = { createXHR: function() { return new ActionXObject('Microsoft.XMLHTTP'); } }; // 根据兼容性返回对应的工厂对象 // 此立即函数运行一次即可完成兼容性检查，防止重复检查 if (standard.createXHR()) { return standard; } else { try { newActionXObject.createXHR(); return newActionXObject; } catch (o) { oldActionXObject.createXHR(); return oldActionXObject; } } })(); var request = XHR.createXHR(); // 3rd argument : async mode request.open('GET', 'example.txt', true); request.onreadystatechange = function() { //do something /* switch(request.readyState) { case 0: initalize case 1: loading case 2: loaded case 3: transaction case 4: complete } */ if (request.readyState == 4) { var para = document.createElement('p'); var txt = document.createTextNode(request.responseText); para.appendChild(txt); document.getElementById('new').appendChild(para); } }; request.send(null); 简单封装 ajax({ url: './TestXHR.aspx', //请求地址 type: 'POST', //请求方式 data: { name: 'super', age: 20 }, //请求参数 dataType: 'json', success: function(response, xml) { // 此处放成功后执行的代码 }, fail: function(status) { // 此处放失败后执行的代码 } }); function ajax(options) { options = options || {}; options.type = (options.type || 'GET').toUpperCase(); options.dataType = options.dataType || 'json'; var params = formatParams(options.data); //创建 - 非IE6 - 第一步 if (window.XMLHttpRequest) { var xhr = new XMLHttpRequest(); } else { //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); } //接收 - 第三步 xhr.onreadystatechange = function() { if (xhr.readyState == 4) { var status = xhr.status; if (status >= 200 && status 跨域请求 Response.Headers.Add(\"Access-Control-Allow-Origin\", \"*\"); // JSON { ‘Access-Control-Allow-Origin‘: ‘*‘, } $.ajax({ url:\"http://map.oicqzone.com/gpsApi.php?lat=22.502412986242&lng=113.93832783228\", type:‘GET‘, dataType:‘JSONP‘, // 处理Ajax跨域问题 success: function(data){ $(‘body‘).append( \"Name: \" + data ); } }); JSON var obj = JSON.parse(json); var json = JSON.stringify(obj); jQuery $.getJSON('/json/cats.json', function(json) { $('.message').html(JSON.stringify(json)); }); 正则表达式 var re = /pattern/gim; Flags g 全局匹配 m 多行匹配 i 大小写敏感匹配 元字符 符号 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 空白符(\" \" \\n \\r \\t \\f) \\S 非空白符(alpha number) \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 x 匹配除了 x 以外的任意字符 aeiou 匹配除了 aeiou 这几个字母以外的任意字符 常用限定符 符号 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复 n 次 {n,} 重复 n 次或更多次 {n,m} 重复 n 到 m 次 懒惰限定符 说明 *? 重复任意次，但尽可能少重复 +? 重复 1 次或更多次，但尽可能少重复 ?? 重复 0 次或 1 次，但尽可能少重复 {n,m}? 重复 n 到 m 次，但尽可能少重复 {n,}? 重复 n 次以上，但尽可能少重复 反向引用 位置编号 - 左括号的顺序 var regExp = /((.*\\2))/g; \\1 \\2 \\3: 第 n 个子表达式匹配的结果字符 $1 $2 $3: 第 n 个子表达式匹配的结果字符 RegExp 静态属性 反向引用的值可以从 RegExp() 构造函数中取得 RegExp.$1; RegExp.$_; RegExp.$&; RegExp.$+; RegExp.$*; 长名 短名 说明 input $_ 最后用于匹配的格式字符串 lastMatch $& 最后匹配的结果字符 lastParen $+ 最后匹配的分组/子表达式 leftContext $` 匹配结果字符串前的字符 rightContext $\\' 匹配结果字符串后的字符 multiline $* 指定是否开启多行模式 分组语法 group lookahead (零宽断言) 分类 代码/语法 说明 捕获 (exp) 匹配 exp,并捕获文本到自动命名的组里 (?exp) 匹配 exp,并捕获文本到名称为 name 的组里 (?:exp) 匹配 exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配 exp 前面的位置 (? 匹配 exp 后面的位置 (?!exp) 匹配后面跟的不是 exp 的位置 (? 匹配前面不是 exp 的位置 注释 (?#comment) 用于提供注释让人阅读 Best Practice(提升效率) 不使用 new RegExp(),使用正则表达式字面量 将正则表达式赋值给变量，防止正则表达式重复创建 以简单(唯一性)字元开始，如 ^/$ x \\u363A [a-z] \\b, 避免以分组表达式开始 \\s\\s* 优于 \\s{1,} 减少表达式的重叠匹配 减少分支表达式,并将最常用的分支放在最前面 无需反向引用时，使用非捕获组 (?:...) 优于 (...) RegExp 常用函数 test /Reg/Flags.test(str); // 返回值为 Boolean /[a-z|A-Z|0-9]/gmi.test(str); replace replace(regExp, str / func); replace arguments 第二个参数若为函数式参数,replace 方法会向它传递一系列参数: 第一个参数: 匹配结果字符串 第 n 个参数: 子表达式匹配结果字符串 倒数第二个参数: 匹配文本在源字符串中的下标位置 最后一个参数: 源字符串自身 replace best practice 使用２个子表达式修剪字符串,字符串总长度影响性能 使用循环修剪字符串(分别用 正/负循环 修剪 首/尾空白符),空白字符长度影响性能 if (!String.prototype.trim) { String.prototype.trim = function() { return this.replace(/^\\s+/, '').replace(/\\s+$/, ''); }; } if (!String.prototype.trim) { String.prototype.trim = function() { var str = this.replace(/^\\s+/, ''), end = str.length - 1, ws = /\\s/; while (ws.test(str.charAt(end))) { end--; } return str.slice(0, end + 1); }; } 常用正则表达式 中英文 /^[\\u4e00-\\u9fa5a-zA-Z]+$/i 数字 /^[1-9]*$/i 空字符与空格字符 /[(^\\s+)(\\s+$)]/g 错误处理(Error/Exception) 错误类型 Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 自定义错误 function MyError(message) { Error.call(this, arguments); this.message = message; } MyError.prototype = new Error(); MyError.prototype.constructor = MyError; 异常作用 在可能失败的地方抛出异常，对失败处做标签，易于调试与测试 修复 bug 后，可考虑是否在此处抛出异常 Asynchronous Programming Promise avoid callback hell with: return new Promise return promise.then Promise.all: short-circuits when an input value is rejected Promise.race: short-circuits when an input value is settled Promise.any: short-circuits when an input value is fulfilled Promise.allSettled: does not short-circuits resolve only accept one value return new Promise(resolve => resolve([a, b])); promises on the same chain execute orderly promises on two seperate chains execute in random order const users = [ 'W8lbAokuirfdlTJpnsNC5kryuHtu1G53', 'ZinqxnohbXMQdtF6avtlUkxLLknRxCTh', 'ynQePb3RB2JSx4iziGYMM5eXgkwnufS5', 'EtT2haq2sNoWnNjmeyZnfUmZn9Ihfi8w' ]; const response = []; const getUser = user => () => { return axios.get(`/users/userId=${user}`).then(res => response.push(res)); }; const getUsers = users => { const [getFirstUser, getSecondUser, getThirdUser, getFourthUser] = users.map( getUser ); getFirstUser() .then(getSecondUser) .then(getThirdUser) .then(getFourthUser) .catch(console.log); }; const users = [ 'W8lbAokuirfdlTJpnsNC5kryuHtu1G53', 'ZinqxnohbXMQdtF6avtlUkxLLknRxCTh', 'ynQePb3RB2JSx4iziGYMM5eXgkwnufS5', 'EtT2haq2sNoWnNjmeyZnfUmZn9Ihfi8w' ]; let response = []; function getUsers(users) { const promises = []; promises[0] = axios.get(`/users/userId=${users[0]}`); promises[1] = axios.get(`/users/userId=${users[1]}`); promises[2] = axios.get(`/users/userId=${users[2]}`); promises[3] = axios.get(`/users/userId=${users[3]}`); Promise.all(promises) .then(userDataArr => (response = userDataArr)) .catch(err => console.log(err)); } Promise.all Promise.all([...]) fail-fast. If at least one promise in the promises array rejects, then the promise returned rejects too. Promise.all(urls.map(fetch)).then(responses => Promise.all(responses.map(res => res.text()) ).then(texts => { // }) Promise.all(urls.map(url => fetch(url).then(resp => resp.text()))).then( texts => { // } ); Promise Polyfill class Promise { // `executor` takes 2 parameters, `resolve()` and `reject()`. The executor // function is responsible for calling `resolve()` or `reject()` to say that // the async operation succeeded (resolved) or failed (rejected). constructor(executor) { if (typeof executor !== 'function') { throw new Error('Executor must be a function'); } // Internal state. `$state` is the state of the promise, and `$chained` is // an array of the functions we need to call once this promise is settled. this.$state = 'PENDING'; this.$chained = []; // Implement `resolve()` and `reject()` for the executor function to use const resolve = res => { // A promise is considered \"settled\" when it is no longer // pending, that is, when either `resolve()` or `reject()` // was called once. Calling `resolve()` or `reject()` twice // or calling `reject()` after `resolve()` was already called // are no-ops. if (this.$state !== 'PENDING') { return; } // If `res` is a \"thenable\", lock in this promise to match the // resolved or rejected state of the thenable. const then = res != null ? res.then : null; if (typeof then === 'function') { // In this case, the promise is \"resolved\", but still in the 'PENDING' // state. This is what the ES6 spec means when it says \"A resolved promise // may be pending, fulfilled or rejected\" in // http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects return then(resolve, reject); } this.$state = 'FULFILLED'; this.$internalValue = res; // If somebody called `.then()` while this promise was pending, need // to call their `onFulfilled()` function for (const { onFulfilled } of this.$chained) { onFulfilled(res); } return res; }; const reject = err => { if (this.$state !== 'PENDING') { return; } this.$state = 'REJECTED'; this.$internalValue = err; for (const { onRejected } of this.$chained) { onRejected(err); } }; // Call the executor function with `resolve()` and `reject()` as in the spec. try { // If the executor function throws a sync exception, we consider that // a rejection. Keep in mind that, since `resolve()` or `reject()` can // only be called once, a function that synchronously calls `resolve()` // and then throws will lead to a fulfilled promise and a swallowed error executor(resolve, reject); } catch (err) { reject(err); } } // `onFulfilled` is called if the promise is fulfilled, and `onRejected` // if the promise is rejected. For now, you can think of 'fulfilled' and // 'resolved' as the same thing. then(onFulfilled, onRejected) { return new Promise((resolve, reject) => { // Ensure that errors in `onFulfilled()` and `onRejected()` reject the // returned promise, otherwise they'll crash the process. Also, ensure // that the promise const _onFulfilled = res => { try { // If `onFulfilled()` returns a promise, trust `resolve()` to handle // it correctly. // store new value to new Promise resolve(onFulfilled(res)); } catch (err) { reject(err); } }; const _onRejected = err => { try { // store new value to new Promise reject(onRejected(err)); } catch (_err) { reject(_err); } }; if (this.$state === 'FULFILLED') { _onFulfilled(this.$internalValue); } else if (this.$state === 'REJECTED') { _onRejected(this.$internalValue); } else { this.$chained.push({ onFulfilled: _onFulfilled, onRejected: _onRejected }); } }); } catch(onRejected) { return this.then(null, onRejected); } } await/async avoid wrong parallel logic (too sequential) // wrong const books = await bookModel.fetchAll(); const author = await authorModel.fetch(authorId); // right const bookPromise = bookModel.fetchAll(); const authorPromise = authorModel.fetch(authorId); const book = await bookPromise; const author = await authorPromise; async getAuthors(authorIds) { // WRONG, this will cause sequential calls // const authors = _.map( // authorIds, // id => await authorModel.fetch(id)); // CORRECT const promises = _.map(authorIds, id => authorModel.fetch(id)); const authors = await Promise.all(promises); } Await Arrays If you want to execute await calls in series, use a for-loop (or any loop without a callback). Don't ever use await with forEach (forEach is not promise-aware), use a for-loop (or any loop without a callback) instead. Don't await inside filter and reduce, always await an array of promises with map, then filter or reduce accordingly. Sleep Function function sleep(time) { return new Promise(resolve => setTimeout(resolve, time)); } sleep(2000).then(() => { //do something after 2000 milliseconds console.log('resolved'); }); async function add(n1, n2) { await sleep(2222); console.log(n1 + n2); } add(1, 2); Race Condition keep latest updates recover from failures online and offline sync (PouchDB) tools: redux-saga export default { data() { return { text: '', results: [], nextRequestId: 1, displayedRequestId: 0 }; }, watch: { async text(value) { const requestId = this.nextRequestId++; const results = await search(value); // guarantee display latest search results (when input keep changing) if (requestId Geolocation API if (window.navigator.geolocation) { //getCurrentPosition第三个参数为可选参数 navigator.geolocation.getCurrentPosition(locationSuccess, locationError, { // 指示浏览器获取高精度的位置，默认为false enableHighAccuracy: true, // 指定获取地理位置的超时时间，默认不限时，单位为毫秒 timeout: 5000, // 最长有效期，在重复获取地理位置时，此参数指定多久再次获取位置。 maximumAge: 3000 }); } else { alert('Your browser does not support Geolocation!'); } locationError 为获取位置信息失败的回调函数，可以根据错误类型提示信息： locationError: function(error){ switch(error.code) { case error.TIMEOUT: showError(\"A timeout occured! Please try again!\"); break; case error.POSITION_UNAVAILABLE: showError('We can\\'t detect your location. Sorry!'); break; case error.PERMISSION_DENIED: showError('Please allow geolocation access for this to work.'); break; case error.UNKNOWN_ERROR: showError('An unknown error occured!'); break; } } locationSuccess 为获取位置信息成功的回调函数，返回的数据中包含经纬度等信息，结合 Google Map API 即可在地图中显示当前用户的位置信息，如下： locationSuccess: function(position){ var coords = position.coords; var latlng = new google.maps.LatLng( // 维度 coords.latitude, // 精度 coords.longitude ); var myOptions = { // 地图放大倍数 zoom: 12, // 地图中心设为指定坐标点 center: latlng, // 地图类型 mapTypeId: google.maps.MapTypeId.ROADMAP }; // 创建地图并输出到页面 var myMap = new google.maps.Map( document.getElementById(\"map\"),myOptions ); // 创建标记 var marker = new google.maps.Marker({ // 标注指定的经纬度坐标点 position: latlng, // 指定用于标注的地图 map: myMap }); //创建标注窗口 var infowindow = new google.maps.InfoWindow({ content:\"您在这里纬度：\"+ coords.latitude+ \"经度：\"+coords.longitude }); //打开标注窗口 infowindow.open(myMap,marker); } navigator.geolocation.watchPosition( locationSuccess, locationError, positionOption ); 自动更新地理位置 Web Audio API From Oscillator -3 -1 1 4 6 9 11 -4 -2 0 2 3 5 7 8 10 12 .___________________________________________________________________________. : | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | : : | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | : : | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | : : | | | | | | | | | | | | | | | | | | : : A | B | C | D | E | F | G | A | B | C | D | E | F | G | A | B | C | D | E : :___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___|___: ^ ^ ^ ^ ^ 220 Hz 440 Hz 523.25 Hz 880 Hz 1174.65 Hz (-1 Octave) (middle A) (+1 Octave) const audioContext = new AudioContext(); const baseFrequency = 440; const getNoteFreq = (base, pitch) => base * Math.pow(2, pitch / 12); // oscillator.frequency.value = getNoteFreq(440, 7); const getNoteDetune = pitch => pitch * 100; // oscillator.detune.value = getNoteDetune(7); const play = (type, delay, pitch, duration) => { const oscillator = audioContext.createOscillator(); oscillator.connect(audioContext.destination); oscillator.type = type; oscillator.detune.value = getNoteDetune(pitch); const startTime = audioContext.currentTime + delay; const stopTime = startTime + duration; oscillator.start(startTime); oscillator.stop(stopTime); }; From Music Data const sampleSize = 1024; // number of samples to collect before analyzing data const audioUrl = 'viper.mp3'; let audioData = null; let audioPlaying = false; const audioContext = new AudioContext(); const sourceNode = audioContext.createBufferSource(); const analyserNode = audioContext.createAnalyser(); const javascriptNode = audioContext.createScriptProcessor(sampleSize, 1, 1); // Create the array for the data values const amplitudeArray = new Uint8Array(analyserNode.frequencyBinCount); // Now connect the nodes together sourceNode.connect(audioContext.destination); sourceNode.connect(analyserNode); analyserNode.connect(javascriptNode); javascriptNode.connect(audioContext.destination); // setup the event handler that is triggered // every time enough samples have been collected // trigger the audio analysis and draw the results javascriptNode.onaudioprocess = function() { // get the Time Domain data for this sample analyserNode.getByteTimeDomainData(amplitudeArray); // draw the display if the audio is playing // if (audioPlaying == true) { // requestAnimFrame(drawTimeDomain); // } }; // Load the audio from the URL via Ajax and store it in global variable audioData // Note that the audio load is asynchronous function loadSound(url) { fetch(url) .then(response => { audioContext.decodeAudioData(response, buffer => { audioData = buffer; playSound(audioData); }); }) .catch(error => { console.error(error); }); } // Play the audio and loop until stopped function playSound(buffer) { sourceNode.buffer = buffer; sourceNode.start(0); // Play the sound now sourceNode.loop = true; audioPlaying = true; } function stopSound() { sourceNode.stop(0); audioPlaying = false; } Audio Bar Chart with Canvas AnalyserNode.getByteFrequencyData API Github Demo const WIDTH = this.canvas.clientWidth; const HEIGHT = this.canvas.clientHeight; this.analyserNode.fftSize = 256; let bufferLengthAlt = this.analyserNode.frequencyBinCount; let dataArrayAlt = new Uint8Array(bufferLengthAlt); this.ctx.clearRect(0, 0, WIDTH, HEIGHT); let draw = () => { let drawVisual = requestAnimationFrame(draw); this.analyserNode.getByteFrequencyData(dataArrayAlt); this.ctx.fillStyle = 'rgb(255, 255, 255)'; this.ctx.fillRect(0, 0, WIDTH, HEIGHT); let barWidth = (WIDTH / bufferLengthAlt) * 2.5; let barHeight; let x = 0; for (let i = 0; i Web Storage API 协同 cookies 对于复杂对象的读取与存储, 需要借助 JSON.parse 与 JSON.stringify if (!localStorage.getItem('bgcolor')) { populateStorage(); } else { setStyles(); } function populateStorage() { localStorage.setItem('bgcolor', document.getElementById('bgcolor').value); localStorage.setItem('font', document.getElementById('font').value); localStorage.setItem('image', document.getElementById('image').value); setStyles(); } function setStyles() { var currentColor = localStorage.getItem('bgcolor'); var currentFont = localStorage.getItem('font'); var currentImage = localStorage.getItem('image'); document.getElementById('bgcolor').value = currentColor; document.getElementById('font').value = currentFont; document.getElementById('image').value = currentImage; htmlElem.style.backgroundColor = '#' + currentColor; pElem.style.fontFamily = currentFont; imgElem.setAttribute('src', currentImage); } Web Navigator API navigator.connection.effectiveType // 2G - 5G Web Files API Web Sockets API 通信功能 WebSocket WebSocket( in DOMString url, in optional DOMString protocols ); WebSocket WebSocket( in DOMString url, in optional DOMString[] protocols ); function WebSocketTest() { if ('WebSocket' in window) { alert('WebSocket is supported by your Browser!'); // Let us open a web socket var ws = new WebSocket('ws://localhost:9998/echo'); ws.onopen = function() { // Web Socket is connected, send data using send() ws.send('Message to send'); alert('Message is sent...'); }; ws.onmessage = function(evt) { var received_msg = evt.data; alert('Message is received...'); }; ws.onclose = function() { // websocket is closed. alert('Connection is closed...'); }; } else { // The browser doesn't support WebSocket alert('WebSocket NOT supported by your Browser!'); } } Web RTC API 多媒体通信 Web Workers API 多线程处理 有两种方法可以停止 Worker: 从主页调用 worker.terminate() 或在 worker 内部调用 self.close() 利用 BroadcastChannel API 可以创建 Shared Worker, 即共享 Workers 在同一源 (origin) 下面的各种进程都可以访问它， 包括：iframes、浏览器中的不同 tab 页 (browsing context) Web Workers 无法访问一些非常关键的 JavaScript 特性: DOM(它会造成线程不安全), window 对象, document 对象, parent 对象. Usecase: Graphic App (Ray Tracing), Encryption, Prefetching Data, PWA (Service Worker), Spell Checking Start computation const worker = new Worker('worker.js'); worker.addEventListener( 'message', function(e) { console.log(e.data); }, false ); function startComputation() { worker.postMessage({ cmd: 'average', data: [1, 2, 3, 4] }); } // worker.js self.addEventListener( 'message', function(e) { const data = e.data; switch (data.cmd) { case 'average': const result = calculateAverage(data); self.postMessage(result); break; default: self.postMessage('Unknown command'); } }, false ); Web Animations API KeyframeEffect Animation const rabbitDownKeyframes = new KeyframeEffect( whiteRabbit, // element to animate [ { transform: 'translateY(0%)' }, // keyframe { transform: 'translateY(100%)' } // keyframe ], { duration: 3000, fill: 'forwards' } // keyframe options ); const rabbitDownAnimation = new Animation( rabbitDownKeyFrames, document.timeline ); whiteRabbit.addEventListener('click', downHandler); function downHandler() { rabbitDownAnimation.play(); whiteRabbit.removeEventListener('click', downHandler); } element.animate const animationKeyframes = [ { transform: 'rotate(0)', color: '#000' }, { color: '#431236', offset: 0.3 }, { transform: 'rotate(360deg)', color: '#000' } ]; const animationTiming = { duration: 3000, iterations: Infinity }; const animation = document .querySelector('alice') .animate(animationKeyframes, animationTiming); animation.pause()/play()/reverse()/finish()/cancel() animation.pause(); animation.currentTime = animation.effect.getComputedTiming().duration / 2; Web Canvas API Basic Usage 绘制路径 beginPath() -> draw() -> closePath() Path2D 对象 绘制样式: 颜色、渐变、变换、阴影 绘制图形: fill/stroke/clip const context = canvas.getContext('2d'); // 根据参数画线 function drawLine(fromX, fromY, toX, toY) { context.moveTo(fromX, fromY); context.lineTo(toX, toY); context.stroke(); } // 根据参数画圆 function drawCircle(x, y, radius, color) { context.fillStyle = color; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2, true); context.closePath(); context.fill(); context.stroke(); } // 改变 canvas 中图形颜色 function changeColor(color) { context.fillStyle = color; context.fill(); } Game Loop With Canvas for all objects: constructor: positon{x, y}, speed{x, y}, size{x, y} update(deltatime): change position or speed draw(ctx): use canvas api and object properties (position/size) to render objects let canvas = document.getElementById('gameScreen'); let ctx = canvas.getContext('2d'); const GAME_WIDTH = 800; const GAME_HEIGHT = 600; let game = new Game(GAME_WIDTH, GAME_HEIGHT); let lastTime = 0; function gameLoop(timestamp) { let deltaTime = timestamp - lastTime; lastTime = timestamp; ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); game.update(deltaTime); game.draw(ctx); requestAnimationFrame(gameLoop); } requestAnimationFrame(gameLoop); Canvas Performance canvas buffer frontCanvasContext.drawImage(bufferCanvas, 0, 0); multiple canvas: top layer, background layer, interactive layer disable alpha path const ctx = canvas.getContext('2d', { alpha: false }); Canvas Reference Canvas on MDN Canvas Cheat Sheet Canvas Perf Tips 1 Canvas Perf Tips 2 Canvas Deep Live Gamepad API Gamepad API Tutorials const gamepads = {}; function gamepadHandler(event, connecting) { // gamepad === navigator.getGamepads()[gamepad.index] const { gamepad } = event; if (connecting) { gamepads[gamepad.index] = gamepad; } else { delete gamepads[gamepad.index]; } } window.addEventListener('gamepadconnected', e => { gamepadHandler(e, true); }); window.addEventListener('gamepaddisconnected', e => { gamepadHandler(e, false); }); URL API URLSearchParams Observer API Intersection Observer Mutation Observer Performance Observer Resize Observer Reporting Observer Intersection Observer // document.addEventListener('DOMContentLoaded', () => { const imageObserver = new IntersectionObserver((entries, imgObserver) => { entries.forEach(entry => { if (entry.isIntersecting) { const lazyImage = entry.target; console.log('Lazy loading ', lazyImage); lazyImage.src = lazyImage.dataset.src; // only load image once lazyImage.classList.remove('lzy'); imgObserver.unobserve(lazyImage); } }); }); const lazyImages = document.querySelectorAll('img.lzy_img'); lazyImages.forEach(lazyImage => imageObserver.observe(lazyImage)); }); © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/javascript/typescriptBasicNotes.html":{"url":"programming/web/javascript/typescriptBasicNotes.html","title":"Typescript Basic Notes","keywords":"","body":"TypeScript Basic Notes TypeScript Basic Notes Installation Config Webpack for TypeScript Intergration Modules globals.d.ts lib.d.ts Basic Types Enum Types Number Enum String Enum Enum with Functions Enum as Flags Internal of Enum Function Function Interface Arrow Function Weak Overload Type Assertion Interface Extends Interface Implements Interface Index Signature Select Index Alias Types Literal Types Moving Types Access Modifiers public/proteced/private readonly Generic Types Generic Function Generic Class Specific Instances from Generic Types Advanced Types Union Types Intersection Types Mapped Types Mixins Closure Decorators Class Decorators Class Properties Decorators Method Parameters Decorators Methods Decorators React with TypeScript Props Types React Refs Types Functional Component Class Component Generic Component Redux Reference Installation Config Types Defination npm i -D typescript awesome-typescript-loader source-map-loader npm i -D react react-dom @types/react @types/react-dom { \"compilerOptions\": { /* 基本选项 */ \"target\": \"es5\", // 'ES3', 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"es2015\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [\"es6\", \"dom\"], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"react\", // 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./build/\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似） /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误 /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 }, \"include\": [\"./src/**/*\"], \"exclude\": [\"node_modules\"] } Webpack for TypeScript const path = require('path'); module.exports = { entry: './src/index.tsx', output: { filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') }, devtool: 'source-map', resolve: { extensions: ['.js', '.json', '.ts', '.tsx'] }, module: { rules: [ { test: /\\.(ts|tsx)$/, loader: 'awesome-typescript-loader' }, { enforce: 'pre', test: /\\.js$/, loader: 'source-map-loader' } ] }, externals: { react: 'React', 'react-dom': 'ReactDOM' } }; Intergration TSX-Boilerplate ESLint for TypeScript TSLint Config Airbnb Modules Types Search globals.d.ts declare module '*.css'; // import * as foo from './some/file.css'; npm i -D @types/react @types/react-dom lib.d.ts \"compilerOptions\": { \"target\": \"es5\", \"lib\": [\"es6\", \"dom\"] } tsc --target es5 --lib dom,es6 Basic Types let num: number; let str: string; let bool: boolean; let boolArray: boolean[]; let tuple: [string, number]; let power: any; // 赋值任意类型 power = '123'; power = 123; // 它也兼容任何类型 power = num; num = power; function log(message: string): void { console.log(message); } Enum Types Number Enum enum CardSuit { Clubs = 1, Diamonds, // 2 Hearts, // 3 Spades // 4 } // 简单的使用枚举类型 let Card = CardSuit.Clubs; // 类型安全 Card = 'not a member of card suit'; // Error: string 不能赋值给 `CardSuit` 类型 String Enum export enum EvidenceTypeEnum { UNKNOWN = '', PASSPORT_VISA = 'passport_visa', PASSPORT = 'passport', SIGHTED_STUDENT_CARD = 'sighted_tertiary_edu_id', SIGHTED_KEYPASS_CARD = 'sighted_keypass_card', SIGHTED_PROOF_OF_AGE_CARD = 'sighted_proof_of_age_card' } Enum with Functions enum Weekday { Monday, Tuseday, Wednesday, Thursday, Friday, Saturday, Sunday } namespace Weekday { export function isBusinessDay(day: Weekday) { switch (day) { case Weekday.Saturday: case Weekday.Sunday: return false; default: return true; } } } const mon = Weekday.Monday; const sun = Weekday.Sunday; console.log(Weekday.isBusinessDay(mon)); // true console.log(Weekday.isBusinessDay(sun)); Enum as Flags enum AnimalFlags { None = 0, HasClaws = 1 Internal of Enum enum Tristate { False, True, Unknown }; // compiles to var Tristate; (function(Tristate) { Tristate[(Tristate['False'] = 0)] = 'False'; Tristate[(Tristate['True'] = 1)] = 'True'; Tristate[(Tristate['Unknown'] = 2)] = 'Unknown'; })(Tristate || (Tristate = {})); console.log(Tristate[0]); // 'False' console.log(Tristate['False']); // 0 console.log(Tristate[Tristate.False]); // 'False' because `Tristate.False == 0` Function Function Interface interface ReturnString { (): string; } declare const foo: ReturnString; const bar = foo(); // bar 被推断为一个字符串 interface Complex { (foo: string, bar?: number, ...others: boolean[]): number; } interface Overloaded { (foo: string): string; (foo: number): number; } // 实现接口的一个例子： function stringOrNumber(foo: number): number; function stringOrNumber(foo: string): string; function stringOrNumber(foo: any): any { if (typeof foo === 'number') { return foo * foo; } else if (typeof foo === 'string') { return `hello ${foo}`; } } const overloaded: Overloaded = stringOrNumber; // 使用 const str = overloaded(''); // str 被推断为 'string' const num = overloaded(123); // num 被推断为 'number' Arrow Function 在一个以 number 类型为参数，以 string 类型为返回值的函数中: const simple: (foo: number) => string = foo => foo.toString(); Weak Overload // 重载 function padding(all: number); function padding(topAndBottom: number, leftAndRight: number); function padding(top: number, right: number, bottom: number, left: number); function padding(a: number, b?: number, c?: number, d?: number) { if (b === undefined && c === undefined && d === undefined) { b = c = d = a; } else if (c === undefined && d === undefined) { c = a; d = b; } return { top: a, right: b, bottom: c, left: d }; } padding(1); // Okay: all padding(1, 1); // Okay: topAndBottom, leftAndRight padding(1, 1, 1, 1); // Okay: top, right, bottom, left padding(1, 1, 1); // Error: Not a part of the available overloads Type Assertion as type as is better in .jsx let foo: any; let bar = foo; // 现在 bar 的类型是 'string' function handler(event: Event) { const mouseEvent = event as MouseEvent; } Interface interface Name { first: string; second: string; } let name: Name; name = { first: 'John', second: 'Doe' }; name = { // Error: 'Second is missing' first: 'John' }; name = { // Error: 'Second is the wrong type' first: 'John', second: 1337 }; Extends Interface // Lib a.d.ts interface Point { x: number, y: number } declare const myPoint: Point // Lib b.d.ts interface Point { z: number } // Your code let myPoint.z // Allowed! Implements Interface interface Crazy { new(): { hello: number }; } class CrazyClass implements Crazy { constructor() { return { hello: 123 }; } } // Because const crazy = new CrazyClass(); // crazy would be { hello:123 } Index Signature let x: { foo: number, [x: string]: any }; x = { foo: 1, baz: 2 }; // ok, 'baz' 属性匹配于索引签名 当你声明一个索引签名时，所有明确的成员都必须符合索引签名 // ok interface Foo { [key: string]: number; x: number; y: number; } // Error interface Bar { [key: string]: number; x: number; y: string; // Error: y 属性必须为 number 类型 } 使用交叉类型可以解决上述问题 type FieldState = { value: string }; type FormState = { isValid: boolean } & { [fieldName: string]: FieldState }; Select Index type Index = 'a' | 'b' | 'c'; type FromIndex = { [k in Index]?: number }; const good: FromIndex = { b: 1, c: 2 }; // Error: // `{ b: 1, c: 2, d: 3 }` 不能分配给 'FromIndex' // 对象字面量只能指定已知类型，'d' 不存在 'FromIndex' 类型上 const bad: FromIndex = { b: 1, c: 2, d: 3 }; type FromSomeIndex = { [key in K]: number }; Alias Types type Text = string | { text: string }; type Coordinates = [number, number]; type Callback = (data: string) => void; Literal Types type CardinalDirection = 'North' | 'East' | 'South' | 'West'; function move(distance: number, direction: CardinalDirection) { // ... } move(1, 'North'); // ok move(1, 'Nurth'); // Error type OneToFive = 1 | 2 | 3 | 4 | 5; type Bools = true | false; Moving Types // 捕获字符串的类型与值 const foo = 'Hello World'; // 使用一个捕获的类型 let bar: typeof foo; // bar 仅能被赋值 'Hello World' bar = 'Hello World'; // ok bar = 'anything else'; // Error const colors = { red: 'red', blue: 'blue' }; type Colors = keyof typeof colors; let color: Colors; // color 的类型是 'red' | 'blue' color = 'red'; // ok color = 'blue'; // ok color = 'anythingElse'; // Error Access Modifiers public/proteced/private class Singleton { private static instance: Singleton; private constructor() { // .. } public static getInstance() { if (!Singleton.instance) { Singleton.instance = new Singleton(); } return Singleton.instance; } someMethod() {} } let someThing = new Singleton(); // Error: constructor of 'singleton' is private let instacne = Singleton.getInstance(); // do some thing with the instance readonly readonly type type Foo = { readonly bar: number; readonly bas: number; }; // 初始化 const foo: Foo = { bar: 123, bas: 456 }; // 不能被改变 foo.bar = 456; // Error: foo.bar 为仅读属性 readonly indexable signature interface Foo { readonly [x: number]: number; } // 使用 const foo: Foo = { 0: 123, 2: 345 }; console.log(foo[0]); // ok（读取） foo[0] = 456; // Error: 属性只读 readonly properties of class class Foo { readonly bar = 1; // OK readonly baz: string; constructor() { this.baz = 'hello'; // OK } } Readonly generic type type Foo = { bar: number, bas: number }; type FooReadonly = Readonly; const foo: Foo = { bar: 123, bas: 456 }; const fooReadonly: FooReadonly = { bar: 123, bas: 456 }; foo.bar = 456; // ok fooReadonly.bar = 456; // Error: bar 属性只读 in React class Something extends React.Component { someMethod() { this.props.foo = 123; // Error: props 是不可变的 this.state.baz = 456; // Error: 你应该使用 this.setState() } } Generic Types Generic Function function reverse(items: T[]): T[] { const toreturn = []; for (let i = items.length - 1; i >= 0; i--) { toreturn.push(items[i]); } return toreturn; } Generic Class // 创建一个泛型类 class Queue { private data = []; push = (item: T) => this.data.push(item); pop = (): T => this.data.shift(); } // 简单的使用 const queue = new Queue(); queue.push(0); queue.push('1'); // Error：不能推入一个 `string`，只有 number 类型被允许 export interface Listener { (event: T): any; } export interface Disposable { dispose(): any; } export class TypedEvent { private listeners: Listener[] = []; private listenersOncer: Listener[] = []; public on = (listener: Listener): Disposable => { this.listeners.push(listener); return { dispose: () => this.off(listener) }; }; public once = (listener: Listener): void => { this.listenersOncer.push(listener); }; public off = (listener: Listener) => { const callbackIndex = this.listeners.indexOf(listener); if (callbackIndex > -1) this.listeners.splice(callbackIndex, 1); }; public emit = (event: T) => { this.listeners.forEach(listener => listener(event)); this.listenersOncer.forEach(listener => listener(event)); this.listenersOncer = []; }; public pipe = (te: TypedEvent): Disposable => { return this.on(e => te.emit(e)); }; } Specific Instances from Generic Types class Foo { foo: T; } const FooNumber = Foo as { new (): Foo }; // ref 1 function id(x: T) { return x; } const idNum = id as { (x: number): number }; Advanced Types Advanced Types Union Types 多种类型之一 function formatCommandline(command: string[] | string) { let line = ''; if (typeof command === 'string') { line = command.trim(); } else { line = command.join(' ').trim(); } // Do stuff with line: string } interface Square { kind: 'square'; size: number; } interface Rectangle { kind: 'rectangle'; width: number; height: number; } // 有人仅仅是添加了 `Circle` 类型 // 我们可能希望 TypeScript 能在任何被需要的地方抛出错误 interface Circle { kind: 'circle'; radius: number; } type Shape = Square | Rectangle | Circle; function area(s: Shape) { switch (s.kind) { case 'square': return s.size * s.size; case 'rectangle': return s.width * s.height; case 'circle': return Math.PI * s.radius ** 2; default: const _exhaustiveCheck: never = s; } } Intersection Types extend 是一种非常常见的模式, intersection type 具有所有类型的功能 function extend(first: T, second: U): T & U { const result = {}; for (let id in first) { (result)[id] = first[id]; } for (let id in second) { if (!result.hasOwnProperty(id)) { (result)[id] = second[id]; } } return result; } const x = extend({ a: 'hello' }, { b: 42 }); // 现在 x 拥有了 a 属性与 b 属性 const a = x.a; const b = x.b; connect in React import * as React from 'react' import * as Redux from 'redux' import { MyReduxState } from './my-root-reducer.ts' export interface OwnProps { propFromParent: number } interface StateProps { propFromReduxStore: string } interface DispatchProps { onSomeEvent: () => void } type Props = StateProps & DispatchProps & OwnProps interface State { internalComponentStateField: string } class MyComponent extends React.Component { ... } function mapStateToProps(state: MyReduxState, ownProps: OwnProps): StateProps { ... } function mapDispatchToProps( dispatch: Redux.Dispatch, ownProps: OwnProps ): DispatchProps { ... } export default connect (mapStateToProps, mapDispatchToProps)(MyComponent) Mapped Types type Readonly = { readonly [P in keyof T]: T[P] } type Partial = { [P in keyof T]?: T[P] } type ReadonlyPartial = { readonly [P in keyof T]?: T[P] } type Nullable = { [P in keyof T]: T[P] | null } type Required = { [P in keyof T]-?: T[P] } type Pick = { [P in K]: T[P] } type Extract = { [P in K]: T[P] } type Filter = T extends U ? T : never type Exclude = T extends U ? never : T type Record = { [P in K]: T } type Proxify = { [P in keyof T]: Proxy } type Proxy = { get(): T; set(value: T): void; } Mixins // 所有 mixins 都需要 type Constructor = new (...args: any[]) => T; ///////////// // mixins 例子 //////////// // 添加属性的混合例子 function TimesTamped(Base: TBase) { return class extends Base { timestamp = Date.now(); }; } // 添加属性和方法的混合例子 function Activatable(Base: TBase) { return class extends Base { isActivated = false; activate() { this.isActivated = true; } deactivate() { this.isActivated = false; } }; } /////////// // 组合类 /////////// // 简答的类 class User { name = ''; } // 添加 TimesTamped 的 User const TimestampedUser = TimesTamped(User); // Tina TimesTamped 和 Activatable 的类 const TimestampedActivatableUser = TimesTamped(Activatable(User)); ////////// // 使用组合类 ////////// const timestampedUserExample = new TimestampedUser(); console.log(timestampedUserExample.timestamp); const timestampedActivatableUserExample = new TimestampedActivatableUser(); console.log(timestampedActivatableUserExample.timestamp); console.log(timestampedActivatableUserExample.isActivated); Closure const { called } = new class { count = 0; called = () => { this.count++; console.log(`Called : ${this.count}`); }; }(); called(); // Called : 1 called(); // Called : 2 Decorators Attaching to a class: access to the class prototype and its member properties. Attaching to a class property: access to the name and value of that property, along with its class prototype target. Attaching to a class method parameter: access to that parameter’s index, name and value. Attaching to a class method: access to the method’s parameters, the metadata associated with the method object, along with its class prototype target. // class definitions @decorator class MyComponent extends React.Component { // class properties @decorator private static api_version: string; // class method parameters private handleFormSubmit(@decorator myParam: string) { } // class methods @decorator private handleFormSubmit() { } // accessors @decorator public myAccessor() { return this.privateProperty; } } Class Decorators function classDecorator(options: any[]) { return target => { ... } } @classDecorator class ... function inject(options: { api_version: string }) { // returns the class decorator implementation return target => { // `target` will give us access to the entire class prototype target.apiVersion = options.api_version; }; } function deprecated(target) { console.log(` this class is deprecated and will be removed in a future version of the app `); console.log(`@: ${target}`); } @inject({ api_version: '0.3.4' }) @deprecated class MyComponent extends React.Component { static apiVersion: string; } Class Properties Decorators first parameter target will be class prototype for normal properties and class constructor for static properties. function prop(target, name) { ... } function staticProp(constructor, name) { ... } class MyComponent extends React.Component { @prop public member: string @staticProp public static apiVersion: string; } Method Parameters Decorators @uppercase/@lowercase for string parameters, @rounded for number parameters. function decorator( class, name: string, index: int, ) { ... } class MyComponent extends React.Component { private handleMethod(@decorator param1: string) { ... } } Methods Decorators target parameter will class prototype propertyKey will be a string containing the name of the method. propertyDescriptor will provide with standard metadata associated with the object: configurable, enumerable, value and writable, as well as get and set. function methodDecorator(options: any[]) { return ( target: MyComponent, propertyKey: string, propertyDescriptor: PropertyDescriptor ) => { ... } } class MyComponent extends React.Component { @methodDecorator handleSomething() { ... } } function enumerable(enumerable: boolean) { return ( target: MyComponent, propertyKey: string, propertyDescriptor: PropertyDescriptor ) => { propertyDescriptor.enumerable = enumerable; } } class MyComponent extends React.Component { @enumerable(false) handleSomething() { ... } } React with TypeScript React TypeScript Cheatsheet Props Types export declare interface AppProps { children: React.ReactNode; // best style?: React.CSSProperties; // for style onChange?: (e: React.FormEvent) => void; // form events! props: Props & React.HTMLProps } React Refs Types class CssThemeProvider extends React.PureComponent { private rootRef: React.RefObject = React.createRef(); render() { return {this.props.children}; } } Functional Component type Props = { foo: string }; const myComponent: React.FunctionComponent = props => { return {props.foo}; }; ; import React, { MouseEvent, SFC } from 'react'; type Props = { onClick(e: MouseEvent): void }; const Button: SFC = ({ onClick: handleClick, children }) => ( {children} ); Class Component read only state import React from 'react'; import Button from './Button'; const initialState = { clicksCount: 0 }; type State = Readonly; class ButtonCounter extends React.Component { readonly state: State = initialState; render() { ... } } props and state types with React.Component<> type Props = { foo: string }; class MyComponent extends React.Component { render() { return {this.props.foo}; } } ; class FocusingInput extends React.Component any }, {} > { input: HTMLInputElement | null = null; render() { return ( (this.input = input)} value={this.props.value} onChange={e => { this.props.onChange(e.target.value); }} /> ); } focus() { if (this.input != null) { this.input.focus(); } } } Generic Component // 一个泛型组件 type SelectProps = { items: T[] }; class Select extends React.Component, any> {} // 使用 const Form = () => items={['a', 'b']} />; Redux const initialState = { name: '', points: 0, likesGames: true }; type State = typeof initialState; export function updateName(name: string) { return { type: 'UPDATE_NAME', name }; } export function addPoints(points: number) { return { type: 'ADD_POINTS', points }; } export function setLikesGames(value: boolean) { return { type: 'SET_LIKES_GAMES', value }; } type Action = ReturnType; // => // type Action = { // readonly type: 'UPDATE_NAME'; // readonly name: string; // } | { // readonly type: 'ADD_POINTS'; // readonly points: number; // } | { // readonly type: 'SET_LIKES_GAMES'; // readonly value: boolean; // } const reducer = (state: State, action: Action): State => { switch (action.type) { case 'UPDATE_NAME': return { ...state, name: action.name } case 'ADD_POINTS': return { ...state, points: action.points } case 'SET_LIKES_GAMES': return { ...state, likesGames: action.value } default: return state } }; Reference TypeScript Deep Dive Clean TypeScript Code © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/nodejs/expressBasicNotes.html":{"url":"programming/web/nodejs/expressBasicNotes.html","title":"Express Basic Notes","keywords":"","body":"Express Basic Notes Express Basic Notes Middleware Function Principle Template Use Useful Middleware Http Res res.local Req Middleware Function Principle next()/next(err) OR res.end()/res.send() Template function (req, res, next) { next(); // OR res.send(); } function (err, req, res, next) { next(err); // OR res.send(); } Use app.use(middlewareFunction); Useful Middleware basicAuth bodyParser compiler cookieParser csrf: 跨域请求(依赖 session bodyparser) directory errorHandle favicon limit: 限制请求个数,防止 Dos 攻击 logger methodOverride profiler: 置于所有中间件之前,记录响应时间和内存使用 query responseTime router session static staticCache vhost Http Res res.local res.locals 中的所有属性都会传递到模板的上下文中 在 app.js 中, use 页面控制器之前, 加入: app.use(function(req, res, next) { res.locals.user = req.user; next(); }); 所有的页面模板中便可以使用 Req req.body.: 处理表单 req.params.routeName: /users/:id -> req.params.id req.query: queryString.parse() 处理后的查询字符串对象 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/nodejs/graphqlBasicNotes.html":{"url":"programming/web/nodejs/graphqlBasicNotes.html","title":"Graphql Basic Notes","keywords":"","body":"GraphQL Basic Notes Better REST no overfetching no underfetching (need multiple RESTful request) flexible (clients can specify their exact data requirements) strong Schema and Type System (just like database) GraphiQL ctrl+enter: run query ctrl+space: auto complete in () or {} shift+ctrl+p: prettify Basic Syntax { site { id siteMetadata { author } host port pathPrefix buildTime } } { \"data\": { \"site\": { \"id\": \"Site\", \"siteMetadata\": { \"author\": \"sabertazimi\" }, \"host\": \"localhost\", \"port\": \"8000\", \"pathPrefix\": \"/react-blog\", \"buildTime\": \"2019-03-05T13:40:39.129Z\" } } } query { allFile(filter: {sourceInstanceName: {eq: \"posts\"}}) { edges { node { relativePath prettySize root dir name ext internal { mediaType } publicURL } } } } { \"data\": { \"allFile\": { \"edges\": [ { \"node\": { \"relativePath\": \"gitBasicNotes.md\", \"prettySize\": \"28.1 kB\", \"root\": \"D:/\", \"dir\": \"D:/Work/Source/react-blog/gatsby/_posts\", \"name\": \"gitBasicNotes\", \"ext\": \".md\", \"internal\": { \"mediaType\": \"text/markdown\" }, \"publicURL\": \"/static/gitBasicNotes-f4bad03605183759bb31c2db3ba69e53.md\" } }, { \"node\": { \"relativePath\": \"reactjsBasicNotes.md\", \"prettySize\": \"5.87 kB\", \"root\": \"D:/\", \"dir\": \"D:/Work/Source/react-blog/gatsby/_posts\", \"name\": \"reactjsBasicNotes\", \"ext\": \".md\", \"internal\": { \"mediaType\": \"text/markdown\" }, \"publicURL\": \"/static/reactjsBasicNotes-a1d04d35063f3e13e6e7302aa40ef1ce.md\" } } ] } } } © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/nodejs/nodejsBasicNotes.html":{"url":"programming/web/nodejs/nodejsBasicNotes.html","title":"Nodejs Basic Notes","keywords":"","body":"Nodejs Basic Notes Nodejs Basic Notes Npm Cli Basic Steps Test Steps Publish Steps Semantic Version(Semver) Tab Completion Basic Command Link Command Security Command npx Basic Node Modules Process Module Process Properties Process Events Process Methods Get Info Message Loop/Counter Child Process File Module fs API Buffer Object Path API Self-Defined Modules Basic Modular Pattern Export Modules CallBack Function Http Module Resquest Object 属性 Response Object 类型 事件 方法 Http Get Http Server Sample Net Module Socket Object Socker.IO Basic Methods URL Module Basic Method parse dns Security Module Crypto Hash API Hmac API 公钥加密 Async Modules Cluster Module Test Modules assert Envrionment package.json bin version Main ./index.js, ./server.js, or ./yourentryfile.js in the root Supporting files in ./lib/ Static HTTP files in ./public/ Views or templates in ./views/ Command-line executables in ./bin/ Tests in ./test/ (or ./spec/ if you’re a Jasmine cool-aid drinker) npm scripts in ./scripts/ Config in ./config/ Documentation in ./doc/ Examples in ./examples/ Performance analysis in ./benchmarks/ Native C/C++ source in ./source/ Npm Cli Basic Steps npm adduser mkdir proj/ # 修改 package.json 可再次运行此命令 # scope for everyone npm init --scope= # 修改 package.json 可再次运行此命令(不接模块名为自动更新) npm install -S npm install -D npm prune # 清除无用包 npm rm --save # --save 删除文件的同时更新 package.json 文件 npm ls npm outdated # 去除过期包 Test Steps // in package.json \"scripts\": { \"test\": \"node test.js\" }, npm test Publish Steps latest or alpha npm publish npm publish --tag [] npm dist-tag add @ [] npm dist-tag rm npm dist-tag ls [] Semantic Version(Semver) patch release: bugfix and other minor changes minor release: new features not breaking API(backward compatible) major release: new features breaking API(not backward compatible) npm version patch npm publish npm version minor npm publish npm version major npm publish Tab Completion npm completion >> ~/.bashrc (or ~/.zshrc) source ~/.zshrc Basic Command best practice: npm ci for cache install (speed up installation) // with package-lock.json exists npm ci remove useless package npm prune // uninstall node_modules not in package.json npm outdated Link Command cd path/to/my-project npm link path/to/my-utils # in local B package, build local B binary (npm install -g B) npm link # in local A package, set `B` link in package.json to local B binary npm link B Security Command npm audit fix npm audit fix --force npx run local node_modules npm install eslint -D npx eslint . run global package (not installed) npx create-react-app react-app run specific version npx -p package1@next -p package2@next -c \"command\" run scripts with different node version npx -p node@version -- node index.js run remote repo/gist code npx user/repo#branch npx gistUrl Basic Node Modules exports 和 module.exports 的区别 exports 是 module.exports 的引用, 改变 exports 值无法改变 module.exports 值 Process Module Process Properties process.pid：当前进程的进程号。 process.version：Node的版本，比如v0.10.18。 process.platform：当前系统平台，比如Linux。 process.title：默认值为“node”，可以自定义该值。 process.argv：当前进程的命令行参数数组。 process.env：指向当前shell的环境变量，比如process.env.HOME。 process.execPath：运行当前进程的可执行文件的绝对路径。 process.stdout：指向标准输出。 process.stdin：指向标准输入。 process.stderr：指向标准错误。 process.stdin.resume(); process.stdin.pipe(process.stdout); Process Events uncaughtException SIGINT exit Process Methods Get Info process.on() process.uptime(): 进程运行时长 process.getgid/setgid/getuid/setuid(); process.cwd() process.memoryUsage() Message Loop/Counter process.nextTick() Child Process cp.spawn(): 创建子进程, 拥有独立的 stdin/stdout/stderr 文件描述符 cp.exec(): 创建子进程, 并会在进程结束时调用传入的回调函数 execa var cp = require('child_process'); cp.exec( 'ls -l', { encoding: 'uft-8', timeout: 0, maxBuffer: 200 * 1024, killSignal: 'SIGTERM', setsid: false, cwd: null, env: null }, function(err, stdout, stderr) { if (!err) { console.log(stdout); console.log(stderr); } } ); File Module fs API fs.createReadStream fs.readdir fs.readFile fs.readFileSync fs.exsits var fs = require('fs'); var buf = fs.readFileSync('/path/to/file', [charSet]); fs.readFile('/path/to/file', [charSet], function callback(err, dataBuf) {}); fs.readdir('/path/to/file', function callback(err, fileNameArr) {}); fs.createReadStream(); src .pipe(dst1) .pipe(dst2) .pipe(dst3); // 连接多个 stream Buffer Object var str = buf.toString(); Path API path.resolve: 自动按系统处理路径 path.extname: 返回文件类型 var path = require('path'); console.log(path.extname(\"index.html\")); // .html path.normalize(p) path.join([path1], [path2], [...]) path.resolve([from ...], to) path.relative(from, to) path.dirname(p) path.basename(p, [ext]) path.extname(p) path.sep path.delimiter Self-Defined Modules Basic Modular Pattern 编写具有回调函数参数的模块 定义模块 function foo(x, y, callback) { try { if (param not valid ) { throw new Error（）; } else { callback(null, param); } } catch (error) { callback(error, param); } } 使用模块 foo(a, b, function (err, param) { if(err) { } else { } })； Export Modules module.exports = function(args) { /* ... */ }; CallBack Function 向定义最内层回调,可避免回套嵌套 server.on('request', function(req, res) { var render = function(wsData) { page = pageRender(req, session, userData, wsData); }; var getWsInfo = function(userData) { ws.get(req, render); }; var getDbInfo = function(session) { db.get(session.user, getWsInfo); }; var getMemCached = function(req, res) { memcached.getSession(req, getDbInfo); }; } Http Module Resquest Object 属性 request.method; // POST GET Response Object 类型 typedef Stream response 事件 监听事件 response.on('data', function(data) {}); response.on('error', function(error) {}); response.on('end', function() { // 结束阶段 stream.end(); }); 发出事件 response.end(); // 传输结束 方法 response.setEncoding('utf8'); // 自动将 data 事件中 Buffer 对象转换成 String // content-type: text/plain // application/json response.writeHead(200, { 'Content-Type': '' }); Http Get http.get(url, function callback(response) {}); http.get(url, function(response) { var pipeData = ''; response.setEncoding('utf8'); response.on('data', function(data) { pipeData += data; }); response.on('end', function() { console.log(pipeData.length); console.log(pipeData); }); }); Http Server var server = http.createServer(function(request, response) { // 处理请求的逻辑... }); server.listen(8000); Sample var net = require('net'); var chatServer = net.createServer(), // 用于检测僵尸客户端,用于及时清楚僵尸客户端 clientList = []; chatServer.on('connection', function(client) { client.name = client.remoteAddress + ':' + client.remotePort; client.write('Hi ' + client.name + '!\\n'); clientList.push(client); client.on('data', function(data) { broadcast(data, client); }); client.on('end', function() { clientList.splice(clientList.indexOf(client), 1); }); client.on('error', function(e) { console.log(e); }); }); function broadcast(message, client) { var cleanup = []; for (var i = 0; i Net Module Socket Object socket.write(data); socket.end(data); socket.end(); Socker.IO var http = require('http'), io = require('socket.io'), fs = require('fs'), sockFile = fs.readFileSync('socket.html'); server = http.createServer(); server.on('request', function(req, res) { res.writeHead(200, { 'content-type': 'text/html' }); res.end(sockFile); }); server.listen(8080); var socket = io.listen(server); // 命名空间 socket.of('/upandrunning').on('connection', function(client) { console.log('Client connected to Up and Running namespace.'); client.send(\"Welcome to 'Up and Running'\"); }); socket.of('/weather').on('connection', function(client) { console.log('Client connected to Weather namespace.'); client.send(\"Welcome to 'Weather Updates'\"); }); Basic Methods var serverInstance = net.createServer(function callback(socket) {}); serverInstance.listen(portNumber); // 开始监听特定端口 URL Module Basic Method parse 解析处 URL 各个组成部分: href protocol host auth hostname port pathname search query hash // true 表示调用 queryString 模块查询字符串 url.parse(request.url, true); dns dns.resolve dns.reverse dns.lookup var dns = require('dns'); dns.lookup('google.com', 4, function(e, a) { console.log(a); }); dns.resolve('tazimi.tk', 'A', function(e, r) { if (e) { console.log(e); } console.log(JSON.stringify(r, null, 2)); }); Security Module Crypto hash algorithm hmac algorithm cipher/decipher algorithms signature/validate Hash API var crypto = require('crypto'), md5 = crypto.createHash('md5'); md5.update('foo'); md5.digest('hex'); // 'acbd18db4cc2f85cedef654fccc4a4d8' Hmac API openssl genrsa -out key.pem 1024 var crypto = require('crypto'), fs = require('fs'), pem = fs.readFileSync('key.pem'), key = pem.toString('ascii'), hmac = crypto.createHmac('sha1', key); hmac.update('bar'); hmac.digest('hex'); // '7fdfeniw012lsda9129dfd9123' 公钥加密 Async Modules 对回调进行计数是处理 Node 中异步的基础 - 自定义 Semaphore 变量: 每完成一个异步处理, Semaphore++ Cluster Module var cluster = require('cluster'), http = require('http'), numCPUs = require('os').cpus().length; var rssWarn = 50 * 1024 * 1024, heapWarn = 50 * 1024 * 1024; var workers = {}; if (cluster.isMaster) { for (var i = 0; i rssWarn) { console.log('Worker ' + m.process + ' using too much memory.'); } } }); } Test Modules assert assert.equal(expect, real, assertPrompt); assert.notEqual(expect, real, assertPrompt); assert.strictEqual(expect, real, assertPrompt); assert.notStrictEqual(expect, real, assertPrompt); assert.deepEqual(expect, real, assertPrompt); assert.notDeepEqual(expect, real, assertPrompt); assert.ok(var, assertPrompt): 测试对象真值(truthy/falsy) assert.throws(fn): 测试方法是否抛出异常 assert.doesNotThrow(fn): 测试方法是否抛出异常 var assert = require('assert'); assert.equal(1, true, 'Truthy'); assert.notEqual(1, true, 'Truthy'); assert.ok(0, 'Zero is not truthy'); Envrionment // .env file (added to .gitignore) NODE_ENV=development PORT=8626 # Set your database/API connection information here API_KEY=************************** API_URL=************************** // config.js const dotenv = require('dotenv'); dotenv.config(); module.exports = { endpoint: process.env.API_URL, masterKey: process.env.API_KEY, port: process.env.PORT }; // server.js const { port } = require('./config'); console.log(`Your port is ${port}`); // 8626 package.json bin 当设置了 bin 字段后, 在 package.json script 字段中，可以使用简写编写命令(但是局部安装无法使得 shell 下可使用简写) version npm version major npm version minor npm version patch © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/reactjs/reactjsBasicNotes.html":{"url":"programming/web/reactjs/reactjsBasicNotes.html","title":"Reactjs Basic Notes","keywords":"","body":"React Basic Notes React Basic Notes Diff Algorithm (Reconciliation) React Fiber React Render Stage Elements of Different Types DOM Elements of Same Type Component Elements of Same Type React Fiber Effects React Commit Stage BeforeMutation Stage Mutation Stage Layout Stage useEffect Execution Time Props and State setState componentDidMount() Props Validation Element and Component JSX functional/class component stateful/stateless component stateless component stateful component Component Lifecycle Creation and Mounting Stage Updating Stage Unmounting Stage Refs String Refs Forward Refs Callback Refs HOC (Higher-Order Components) Render Props (Children as Function) Hooks useMemo useCallback useState useReducer useRef Refs Basis Refs Values Refs Update Mechanism useEffect useEffect Lifecycle useEffect Nasty Loop useEffect Deps List Closure in useEffect useEffect State vs Class State Hooks Usage Rules Hooks Internal Custom Hooks LifeCycle Hooks Async Data Hook Reducer Hook Previous Hook Store Hook History Hook Debounce Hook Context Hook Router Hook Script Loading Hook Form Hook Hooks Best Practice ES6 Syntax Comments Binding for This React Style Guide Naming Style Props Style Refs Style Alignment Style Quotes Style Spacing Style Ordering of Class Component Project Structure Best Practice MVC and MVVM Controller Comparison Best Practice Modern React Lazy and Suspense Context API Ref with Context Error Boundary React Fragment Portals React Performance Re-rendering Problem Code Spliting Server Side Rendering Pros of SSR Performance SEO Awesome Library Basic Example Internationalization Simple Intl Testing Shallow Renderer Test Renderer Enzyme Create React App React Scripts React Scripts Initilization React Scripts Commands React Scripts Configuration Other Packages in CRA Repo Custom CRA CRA Templates Deployment Styled Component Basic Usage Shared CSS Styles Extend Styled Component Props for Styled Component Framework Paradigm Third-party Libraries Usage Interviews Diff Algorithm (Reconciliation) React Fiber A Simple React with Fiber Reconciliation React Fiber 的目标是提高其在动画、布局和手势等领域的适用性. 它的主要特性是Incremental Rendering: 将渲染任务拆分为小的任务块并将任务分配到多个帧上的能力. React Render Stage Elements of Different Types rebuild element and children methods: componentDidMount/componentWillUnmount DOM Elements of Same Type only update the changed attributes use key attribute to match children Best Practice: give key to // elements (stable, predictable, unique and not array indexed) Component Elements of Same Type update the props to match the new element methods: getDerivedStateFromProps then render called, diff algorithm recurses on the old result and the new result React Fiber Effects Insert DOM elements: Placement tag. Update DOM elements: Update tag. Delete DOM elements: Deletion tag. Update Ref property: Ref tag. useEffect callback: got Passive tag. useEffect(fn): Mount and Update lifecycle. useEffect(fn, []): Mount lifecycle. useEffect(fn, [deps]): Mount lifecycle and Update lifecycle with deps changed. React create effects when Render stage, then update effects to real DOM when Commit stage. React Commit Stage BeforeMutation Stage Mutation Stage Placement effects: DOM.appendChild called. Layout Stage componentDidMount lifecycle function called synchronously. useLayoutEffect callback called synchronously. useEffect Execution Time useEffect callback called asynchronously after three stages of Commit. Props and State setState setState Synchronous Way: When it comes blocking mode (ReactDOM.createBlockingRoot(rootNode).render()), setState works in synchronous mode. setState Asynchronous Way: At most of the other time, setState works in asynchronous mode, including legacy mode(ReactDOM.render(, rootNode)) and concurrent mode(ReactDOM.createRoot(rootNode).render()). 在异步模式下, 为了防止子组件在处理事件时多次渲染, 将多个 setState (包括父组件) 移到浏览器事件之后执行 (Batched Updates: 此时 React 内部变量 isBatchingUpdates 变成 true), 可以提升 React 性能. 未来会在更多的可以 Batched Updates 的场景下将 setState 设为异步执行, 所以编写代码时最好将 setState 总是当做异步执行函数. Batch Update: 事件处理, Not Bacth Update: Async Work (setTimeout/Promise.then) class Example extends React.Component { constructor() { super(); this.state = { val: 0, }; } componentDidMount() { this.setState({ val: this.state.val + 1 }); console.log(this.state.val); // 第 1 次 log this.setState({ val: this.state.val + 1 }); console.log(this.state.val); // 第 2 次 log setTimeout(() => { this.setState({ val: this.state.val + 1 }); console.log(this.state.val); // 第 3 次 log this.setState({ val: this.state.val + 1 }); console.log(this.state.val); // 第 4 次 log }, 0); } render() { return null; } } // => 0 0 2 3 componentDidMount() don't setState directly in this method can use setInterval/setTimeout/AJAX request/fetch in this method, and call setState as callback inside these functions class MyComponent extends React.Component { constructor(props) { super(props); this.state = { error: null, isLoaded: false, items: [], }; } componentDidMount() { fetch('https://api.example.com/items') .then((res) => res.json()) .then( (result) => { this.setState({ isLoaded: true, items: result.items, }); }, // Note: it's important to handle errors here // instead of a catch() block so that we don't swallow // exceptions from actual bugs in components. (error) => { this.setState({ isLoaded: true, error, }); } ); } render() { const { error, isLoaded, items } = this.state; if (error) { return Error: {error.message}; } else if (!isLoaded) { return Loading...; } else { return ( {items.map((item) => ( {item.name} {item.price} ))} ); } } } Props Validation static PropTypes = { arrayProps: React.PropTypes.array // array/bool/func/number/object/string/symbol/node/element // React.PropTypes.instanceOf/oneOf/oneOfType // React.PropTypes.arrayOf(React.PropsTypes.number) // React.PropTypes.objectOf(React.PropsTypes.number) // React.PropTypes.any.isRequired } Element and Component react element 实际上是纯对象, 可由 React.createElement()/JSX/element factory helper 创建, 并被 react 在必要时渲染成真实的 DOM 结点 ReactDOM.render({ type: Form, props: { isSubmitted: false, buttonText: 'OK!' } }, document.getElementById('root')); // React: You told me this... { type: Form, props: { isSubmitted: false, buttonText: 'OK!' } } // React: ...And Form told me this... { type: Button, props: { children: 'OK!', color: 'blue' } } // React: ...and Button told me this! I guess I'm done. { type: 'button', props: { className: 'button button-blue', children: { type: 'b', props: { children: 'OK!' } } } } JSX 在 JSX 中, 小写标签被认为是 HTML 标签. 但是, 含有 . 的大写和小写标签名却不是. 将被转换为 React.createElement('component') (i.e, HTML 标签) 将被转换为 React.createElement(obj.component) 将被转换为 React.createElement(Component) functional/class component 函数型组件没有实例, 类型组件具有实例, 但实例化的工作由 react 自动完成 class component 具有更多特性: state, lifecycle hook, performance optimizations(shouldComponentUpdate()回调方法) stateful/stateless component stateless component 采用函数型声明, 不使用 setState(), 一般作为表现型组件 stateful component 采用类型声明, 使用 setState(), 一般作为容器型组件(containers) 结合 Redux 中的 connect 方法, 将 store 中的 state 作为此类组件的 props this.setState((prevState, props) => ({ counter: prevState.counter + props.increment, })); Component Lifecycle reconciliation stage: constructor, getDerivedStateFromProps, getDerivedStateFromError, shouldComponentUpdate, render. commit stage: componentDidMount, getSnapshotBeforeUpdate, componentDidUpdate, componentWillUnmount, componentDidCatch. 因为协调阶段可能被中断、恢复，甚至重做, React 协调阶段的生命周期钩子可能会被调用多次, 协调阶段的生命周期钩子不要包含副作用 Creation and Mounting Stage constructor(props, context) -> getDerivedStateFromProps() -> render() -> componentDidMount() Updating Stage update for three reasons: parent/top (re-)render this.setState() called this.forceUpdate() called getDerivedStateFromProps() -> shouldComponentUpdate(nextProps, nextState) -> render() -> getSnapshotBeforeUpdate() -> componentDidUpdate(prevProps, prevState) getSnapshotBeforeUpdate: 在最新的渲染输出提交给 DOM 前将会立即调用, 这对于从 DOM 捕获信息（比如：滚动位置）很有用. Unmounting Stage componentWillUnmount() Refs Refs 用于返回对元素的引用. 但在大多数情况下, 应该避免使用它们. 当需要直接访问 DOM 元素或组件的实例时, 它们可能非常有用: Managing focus, text selection, or media playback. Triggering imperative animations. Integrating with third-party DOM libraries.k Ref 通过将 Fiber 树中的 instance 赋给 ref.current 实现 function commitAttachRef(finishedWork: Fiber) { // finishedWork 为含有 Ref effectTag 的 fiber const ref = finishedWork.ref; // 含有 ref prop, 这里是作为数据结构 if (ref !== null) { // 获取 ref 属性对应的 Component 实例 const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) { case HostComponent: // 对于 HostComponent, 实例为对应 DOM 节点 instanceToUse = getPublicInstance(instance); break; default: // 其他类型实例为 fiber.stateNode instanceToUse = instance; } // 赋值 ref if (typeof ref === 'function') { ref(instanceToUse); } else { ref.current = instanceToUse; } } } String Refs 尽可能不适用 String Refs React 无法获取 this 引用, 需要持续追踪当前render出的组件, 性能变慢 class Foo extends Component { render() { return this.action()} ref=\"input\" />; } action() { console.log(this.refs.input.value); } } class App extends React.Component { renderRow = (index) => { // ref 会绑定到 DataTable 组件实例, 而不是 App 组件实例上 return ; // 如果使用 function 类型 ref, 则不会有这个问题 // return this['input-' + index] = input} />; }; render() { return ; } } Forward Refs 你不能在函数式组件上使用ref属性, 因为它们没有实例, 但可以在函数式组件内部使用ref. Ref forwarding 是一个特性, 它允许一些组件获取接收到 ref 对象并将它进一步传递给子组件. // functional component const ButtonElement = React.forwardRef((props, ref) => ( {props.children} )); // Create ref to the DOM button: // get ref to `` const ref = React.createRef(); {'Forward Ref'}; Callback Refs class UserInput extends Component { setSearchInput = (input) => { this.input = input; } render () { return ( // Access DOM input in handle submit Submit ); } } HOC (Higher-Order Components) Solve: reuse code with using ES6 classes compose multiple HOCs Pros: reusable (abstract same logic) HOC is flexible with input data (pass input data as parameters or derive it from props) Cons: wrapper hell: withA(withB(withC(withD(Comp)))) indirection issues: which HOC providing a certain prop name collision/overlap props: overwrite the same name prop silently HOC is not flexible with output data (to WrappedComponent) // ToggleableMenu.jsx function withToggleable(Clickable) { return class extends React.Component { constructor() { super(); this.toggle = this.toggle.bind(this); this.state = { show: false }; } toggle() { this.setState((prevState) => ({ show: !prevState.show })); } render() { return ( {this.state.show && this.props.children} ); } }; } class NormalMenu extends React.Component { render() { return ( {this.props.title} ); } } export default withToggleable(NormalMenu); class Menu extends React.Component { render() { return ( Some content Another content More content ); } } Render Props (Children as Function) Solve: reuse code with using ES6 classes lowest level of indirection no naming collision e.g Context or ThemesProvider is designed base on Render Props. Pros: separate presentation from logic extendable reusable (abstract same logic) Render Props is flexible with output data (children parameters definition free) Cons: wrapper hell (when many cross-cutting concerns are applied to a component) minor memory issues when defining a closure for every render unable to optimize code with React.memo/React.PureComponent due to render() function always changes. Render Props is not flexible with input data (restricts children components from using the data at outside field) class Toggleable extends React.Component { constructor() { super(); this.toggle = this.toggle.bind(this); this.state = { show: false }; } toggle() { this.setState((prevState) => ({ show: !prevState.show })); } render() { return this.props.children(this.state.show, this.toggle); } } const ToggleableMenu = (props) => ( {(show, onClick) => ( {props.title} {show && props.children} )} ); class Menu extends React.Component { render() { return ( Some content Another content More content ); } } Hooks Reuse stateful logic between components (avoid wrapper hell in render props or HOC) Split one complex component into smaller functions Use more of React features without classes Class components will read this.props too early or too late, because of mutable this in React (however props argument of function components is immutable), that says function components capture the rendered values. more details on Overreacted. // hook 实例 const hook = { // hook保存的数据 memoizedState: null, // 指向下一个hook next: hookForB // 本次更新以 baseState 为基础计算新的state baseState: null, // 本次更新开始时已有的 update 队列 baseQueue: null, // 本次更新需要增加的 update 队列 queue: null, }; useMemo returns a memoized value only recompute the memoized value when one of the dependencies has changed shallow compare diff optimization helps to avoid expensive calculations on every render (avoid re-render problem) const Button = ({ color, children }) => { const textColor = useMemo( () => slowlyCalculateTextColor(color), [color] // ✅ Don’t recalculate until `color` changes ); return ( {children} ); }; useCallback returns a memoized callback 对事件句柄进行缓存, useState 的第二个返回值是 dispatch, 但是每次都是返回新的函数, 使用 useCallback, 可以让它使用上次的函数. 在虚拟 DOM 更新过程中, 如果事件句柄相同, 那么就不用每次都进行 removeEventListner 与 addEventListner. useCallback(fn, deps) is equivalent to useMemo(() => fn, deps) function Parent() { const [query, setQuery] = useState('react'); // ✅ Preserves identity until query changes const fetchData = useCallback(() => { const url = 'https://hn.algolia.com/api/v1/search?query=' + query; // ... Fetch data and return it ... }, [query]); // ✅ Callback deps are OK return ; } function Child({ fetchData }) { let [data, setData] = useState(null); useEffect(() => { fetchData().then(setData); }, [fetchData]); // ✅ Effect deps are OK // ... } useState read rendered props/state return value of useState is ref to hooks[idx]: direct change to return value doesn't change state value return function of useState (setState) is to change value of hooks[idx] 由于 setState 更新状态 (dispatch action) 时基于 hook.BaseState, setState(value + 1) 与 setState(value => value + 1) 存在差异 当在 useEffect 中调用 setState 时, 最好使用 setState(callback) 形式, 这样可以不用再 Deps List 中显式声明 state, 也可以避免一些 BUG setState((prevState) => { // Object.assign would also work return { ...prevState, ...updatedValues }; }); let newState = baseState; let firstUpdate = hook.baseQueue.next; let update = firstUpdate; // setState(value + 1) 与 setState(value => value + 1) 存在差异 // 遍历 baseQueue 中的每一个 update do { if (typeof update.action === 'function') { newState = update.action(newState); } else { newState = action; } } while (update !== firstUpdate); import { useState } from 'react'; function Example() { // Declare a new state variable, which we'll call \"count\" const [count, setCount] = useState(0); return ( You clicked {count} times setCount(count + 1)}>Click me ); } import { useState, useEffect } from 'react'; function FriendStatus(props) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() => { ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } // Mount with { friend: { id: 100 } } props ChatAPI.subscribeToFriendStatus(100, handleStatusChange); // Run first effect // Update with { friend: { id: 200 } } props // Clean up previous effect ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); ChatAPI.subscribeToFriendStatus(200, handleStatusChange); // Run next effect // Update with { friend: { id: 300 } } props // Clean up previous effect ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); ChatAPI.subscribeToFriendStatus(300, handleStatusChange); // Run next effect // Unmount ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect useReducer Use useState whenever manage a JS primitive (e.g. string, boolean, integer). Use useReducer whenever manage an object or array. It’s best to put states together in one state object when they conditionally dependent on each other (useReducer). Using useReducer over useState gives us predictable state transitions. It comes in very powerful when state changes become more complex. Use useState if: manage JavaScript primitives as state have simple state transitions want to have business logic within components have different properties that don’t change in any correlated manner and can be managed by multiple useState hooks state is co-located to your component for a small application Use useReducer if: manage JavaScript objects or arrays as state have complex state transitions want to move business logic into reducers have different properties that are tied together and should be managed in one state object update state deep down in your component tree for a medium size application for easier testing for more predictable and maintainable state architecture const insertToHistory = (state) => { if (state && Array.isArray(state.history)) { // Do not mutate const newHistory = [...state.history]; newHistory.push(state); return newHistory; } console.warn(` WARNING! The state was attempting capture but something went wrong. Please check if the state is controlled correctly. `); return state.history || []; }; const reducer = (state, action) => { switch (action.type) { case 'set-theme': return { ...state, theme: action.theme, history: insertToHistory(state) }; case 'add-friend': return { ...state, friends: [...state.friends, action.friend], history: insertToHistory(state), }; case 'undo': { const isEmpty = !state.history.length; if (isEmpty) return state; return { ...state.history[state.history.length - 1] }; } case 'reset': return { ...initialState, history: insertToHistory(state) }; default: return state; } }; const [state, dispatch] = useReducer(reducer, initialState); useRef Refs Basis ref can bind to HTMLElement. ref can either be a state that does not need to change too often. ref can either be a state that should change as frequently as possible but should not trigger full re-rendering of the component. Refs Values Mutable Value: useRef() is useful for for keeping any mutable value around. Updating reference values inside handlers/useEffect callbacks is good, updating reference values during rendering (outside callbacks) is bad. Lifecycle Persisted Value: useRef() creates a plain JavaScript object, is persisted (stays the same) between component re-renderings. Silent Value: update reference values don't trigger re-renderings. Latest Value: useRef() read rendered props/state from the future. It's good to get latest value of a particular prop or state (the updated reference value is available right away). function Example() { const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() => { // Set the mutable latest value latestCount.current = count; setTimeout(() => { // Read the mutable latest value console.log(`You clicked ${latestCount.current} times`); }, 3000); }); } Refs Update Mechanism Update a ref, no re-renderings happens. Update a state, the deep rendering mechanism works to re-render components. Store values in refs and have them updated, which is more efficient than useState (which can be expensive) when the values are to be updated multiple times within a second. function UserAvatar(props) { return ; } function Username(props) { return {props.name}; } function User() { const user = useRef({ name: 'UserName', avatarURL: 'https://avatar.com/avatar', }); useEffect(() => { setTimeout(() => { user.current = { name: 'NewUserName', avatarURL: 'https://avatar.com/newavatar', }; }, 5000); }); // Only output once console.log('Rendered.'); // Both children won't be re-rendered // due to shallow rendering mechanism return ( ); } useEffect Complete Guide useEffect Lifecycle React renders UI for current props/state to screen. React cleans up the effect for prev props/state. React runs the effect for current props/state. useEffect Nasty Loop The effect hook runs when the component mounts but also when the component updates. Because we are setting the state after every data fetch, the component updates and the effect runs again. It fetches the data again and again. That’s a bug and needs to be avoided. useEffect Deps List 无论是将组件编写为类还是函数, 都必须为 effect 响应所有 props 和 state 的更新. 在传统的 Class Component, 需要编写代码去检测这些 props 和 state 是否变更 (shouldComponentUpdate, componentDidUpdate). 在 Function Component, 借助 useEffect Hook 可以实现自动检测. That’s why provide an empty array as second argument to the effect hook to avoid activating it on component updates but only for the mounting of the component. If one of the variables changes, the hook runs again. For listeners binding, use [] deps list should be better. Functions in useEffect: If only use some functions inside an effect, move them directly into that effect. Hoisting functions that don’t need props or state outside of component, and pull the ones that are used only by an effect inside of that effect. For useCallback function, it should be in deps list useEffect(() => {}, [callback]) // https://www.robinwieruch.de/react-hooks-fetch-data import { useState, useEffect } from 'react'; import axios from 'axios'; const useDataApi = (initialUrl, initialData) => { const [data, setData] = useState(initialData); const [url, setUrl] = useState(initialUrl); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); useEffect(() => { const fetchData = async () => { setIsError(false); setIsLoading(true); try { const result = await axios(url); setData(result.data); } catch (error) { setIsError(true); } setIsLoading(false); }; fetchData(); }, [url]); const doFetch = (url) => { setUrl(url); }; return { data, isLoading, isError, doFetch }; }; Closure in useEffect useEffect Hook 会丢弃上一次渲染结果, 它会清除上一次 effect, 再建立下一个 effect (也会创建新的 Closure), 下一个 effect 锁住新的 props 和 state (整个 Counter 函数在 re-render 时会被重复调用一次). setInterval 不会丢弃上一次结果, 会引用旧状态 Closure 中的变量, 导致其与 useEffect 所预期行为不一致. 可以通过 useRef 解决这一现象. // BUG function Counter() { let [count, setCount] = useState(0); useEffect(() => { let id = setInterval(() => { setCount(count + 1); // always 1 regardless `count` value change }, 1000); return () => clearInterval(id); }, []); return {count}; } function Counter() { const [count, setCount] = useState(0); useInterval(() => { setCount(count + 1); }, 1000); return {count}; } function useInterval(callback, delay) { const savedCallback = useRef(); useEffect(() => { savedCallback.current = callback; }); useEffect(() => { function tick() { savedCallback.current(); } let id = setInterval(tick, delay); return () => clearInterval(id); }, [delay]); } useEffect State vs Class State 如同 Closure in useEffect, 每次调用 useEffect 时, 会捕获那一次 render 时的 props 和 state. Class Component 中的 this.state.xxx 却总是指向最新的 state. function Counter() { const [count, setCount] = useState(0); useEffect(() => { setTimeout(() => { console.log(`You clicked ${count} times`); }, 3000); }); return ( You clicked {count} times setCount(count + 1)}>Click me ); } // Output: // Mounted: You clicked 0 times // Clicked 5 times in 3s // You clicked 1 times // You clicked 2 times // You clicked 3 times // You clicked 4 times // You clicked 5 times componentDidUpdate() { setTimeout(() => { console.log(`You clicked ${this.state.count} times`); }, 3000); } // Output: // Mounted: You clicked 0 times // Clicked 5 times in 3s // You clicked 5 times // You clicked 5 times // You clicked 5 times // You clicked 5 times // You clicked 5 times Hooks Usage Rules only call Hooks at the top level (don't inside loops, conditions or nested functions) only call Hooks from React function components Hooks Internal const MyReact = (function () { let hooks = [], currentHook = 0; // array of hooks, and an iterator! return { render(Component) { const Comp = Component(); // run effects Comp.render(); currentHook = 0; // reset for next render return Comp; }, useEffect(callback, depArray) { const hasNoDeps = !depArray; const deps = hooks[currentHook]; // type: array | undefined const hasChangedDeps = deps ? !depArray.every((el, i) => el === deps[i]) : true; if (hasNoDeps || hasChangedDeps) { callback(); hooks[currentHook] = depArray; } currentHook++; // done with this hook }, useState(initialValue) { hooks[currentHook] = hooks[currentHook] || initialValue; // type: any const setStateHookIndex = currentHook; // for setState's closure! const setState = (newState) => (hooks[setStateHookIndex] = newState); return [hooks[currentHook++], setState]; }, }; })(); function Counter() { const [count, setCount] = MyReact.useState(0); const [text, setText] = MyReact.useState('foo'); // 2nd state hook! MyReact.useEffect(() => { console.log('effect', count, text); }, [count, text]); return { click: () => setCount(count + 1), type: (txt) => setText(txt), noop: () => setCount(count), render: () => console.log('render', { count, text }), }; } let App; App = MyReact.render(Counter); // effect 0 foo // render {count: 0, text: 'foo'} App.click(); App = MyReact.render(Counter); // effect 1 foo // render {count: 1, text: 'foo'} App.type('bar'); App = MyReact.render(Counter); // effect 1 bar // render {count: 1, text: 'bar'} App.noop(); App = MyReact.render(Counter); // // no effect run // render {count: 1, text: 'bar'} App.click(); App = MyReact.render(Counter); // effect 2 bar // render {count: 2, text: 'bar'} function Component() { const [text, setText] = useSplitURL('www.netlify.com'); return { type: (txt) => setText(txt), render: () => console.log({ text }), }; } function useSplitURL(str) { const [text, setText] = MyReact.useState(str); const masked = text.split('.'); return [masked, setText]; } let App; App = MyReact.render(Component); // { text: [ 'www', 'netlify', 'com' ] } App.type('www.reactjs.org'); App = MyReact.render(Component); // { text: [ 'www', 'reactjs', 'org' ] }} Custom Hooks More Custom Hooks LifeCycle Hooks componentDidMount: useLayoutEffect. useEffect got invoked after componentDidMount. const useMount = (fn) => { useEffect(() => void fn(), []); }; componentWillUnmount const useUnmount = (fn) => { useEffect(() => fn, []); }; componentDidUpdate const useUpdate = (fn) => { const mounting = useRef(true); useEffect(() => { if (mounting.current) { // first get called for componentDidMount lifecycle // so skip it mounting.current = false; } else { fn(); } }); }; Force Update const useUpdate = () => useState(0)[1]; // @ts-ignore import { useState } from 'react'; interface VoidFunction { (): void; } interface VoidFunctionCreator { (): VoidFunction; } const max: number = 9007199254740990; // Number.MAX_SAFE_INTEGER - 1; const useForceUpdate: VoidFunctionCreator = (): VoidFunction => { const [, setState] = useState(0); const forceUpdate: VoidFunction = (): void => { setState((state: number) => (state + 1) % max); }; return forceUpdate; }; export default useForceUpdate; isMounted const useIsMounted = () => { const [isMount, setIsMount] = useState(false); useEffect(() => { if (!isMount) { setIsMount(true); } return () => setIsMount(false); }, []); return isMount; }; Async Data Hook useState to store url and data useEffect to trigger async fetch actions import { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() => { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( {props.friend.name} ); } import React, { Fragment, useState, useEffect } from 'react'; import axios from 'axios'; const useDataApi = (initialUrl, initialData) => { const [data, setData] = useState(initialData); const [url, setUrl] = useState(initialUrl); const [isLoading, setIsLoading] = useState(false); const [isError, setIsError] = useState(false); const fetchData = async () => { setIsError(false); setIsLoading(true); try { const result = await axios(url); setData(result.data); } catch (error) { setIsError(true); } setIsLoading(false); }; useEffect(() => { fetchData(); }, [url]); const doGet = (event, url) => { setUrl(url); event.preventDefault(); }; return { data, isLoading, isError, doGet }; }; function App() { const [query, setQuery] = useState('redux'); const { data, isLoading, isError, doGet } = useDataApi( 'http://hn.algolia.com/api/v1/search?query=redux', { hits: [] } ); return ( doGet(event, `http://hn.algolia.com/api/v1/search?query=${query}`) } > setQuery(event.target.value)} /> Search {isError && Something went wrong ...} {isLoading ? ( Loading ... ) : ( {data.hits.map((item) => ( {item.title} ))} )} ); } export default App; Reducer Hook function useReducer(reducer, initialState) { const [state, setState] = useState(initialState); function dispatch(action) { const nextState = reducer(state, action); setState(nextState); } return [state, dispatch]; } function Todos() { const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) { dispatch({ type: 'add', text }); } // ... } Previous Hook function Counter() { const [count, setCount] = useState(0); const prevCount = usePrevious(count); return ( Now: {count}, before: {prevCount} ); } function usePrevious(value) { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; } Store Hook import { useState } from 'react'; export const store = { state: {}, setState(value) { this.state = value; this.setters.forEach((setter) => setter(this.state)); }, setters: [], }; // Bind the setState function to the store object so // we don't lose context when calling it elsewhere store.setState = store.setState.bind(store); // this is the custom hook we'll call on components. export function useStore() { const [state, set] = useState(store.state); if (!store.setters.includes(set)) { store.setters.push(set); } return [state, store.setState]; } History Hook import { useReducer, useCallback } from 'react'; // Initial state that we pass into useReducer const initialState = { // Array of previous state values updated each time we push a new state past: [], // Current state value present: null, // Will contain \"future\" state values if we undo (so we can redo) future: [], }; // Our reducer function to handle state changes based on action const reducer = (state, action) => { const { past, present, future } = state; switch (action.type) { case 'UNDO': const previous = past[past.length - 1]; const newPast = past.slice(0, past.length - 1); return { past: newPast, present: previous, future: [present, ...future], }; case 'REDO': const next = future[0]; const newFuture = future.slice(1); return { past: [...past, present], present: next, future: newFuture, }; case 'SET': const { newPresent } = action; if (newPresent === present) { return state; } return { past: [...past, present], present: newPresent, future: [], }; case 'CLEAR': const { initialPresent } = action; return { ...initialState, present: initialPresent, }; } }; // Hook const useHistory = (initialPresent) => { const [state, dispatch] = useReducer(reducer, { ...initialState, present: initialPresent, }); const canUndo = state.past.length !== 0; const canRedo = state.future.length !== 0; // Setup our callback functions // We memoize with useCallback to prevent unnecessary re-renders const undo = useCallback(() => { if (canUndo) { dispatch({ type: 'UNDO' }); } }, [canUndo, dispatch]); const redo = useCallback(() => { if (canRedo) { dispatch({ type: 'REDO' }); } }, [canRedo, dispatch]); const set = useCallback( (newPresent) => dispatch({ type: 'SET', newPresent }), [dispatch] ); const clear = useCallback( () => dispatch({ type: 'CLEAR', initialPresent }), [dispatch] ); // If needed we could also return past and future state return { state: state.present, set, undo, redo, clear, canUndo, canRedo }; }; Debounce Hook // Hook function useDebounce(value, delay) { // State and setters for debounced value const [debouncedValue, setDebouncedValue] = useState(value); useEffect( () => { // Update debounced value after delay const handler = setTimeout(() => { setDebouncedValue(value); }, delay); // Cancel the timeout if value changes (also on delay change or unmount) // This is how we prevent debounced value // from updating if value is changed ... // .. within the delay period. Timeout gets cleared and restarted. return () => { clearTimeout(handler); }; }, [value, delay] // Only re-call effect if value or delay changes ); return debouncedValue; } // Usage const [searchTerm, setSearchTerm] = useState(''); const debouncedSearchTerm = useDebounce(searchTerm, 500); useEffect(() => { ... }, [debouncedSearchTerm]); Context Hook 一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件, 将子组件作为 props.children 传入, 这样当 Context 变化时 Provider 不会重新渲染它的子组件, 由依赖了 context 的子组件自己进行重渲染, 未依赖的子组件不会重新渲染. 使用 useMemo 使得 value 不会重复创建. import React from 'react'; const CountContext = React.createContext(); function CountProvider(props) { const [count, setCount] = React.useState(0); const value = React.useMemo(() => { return { count, setCount, }; }, [count]); return ; } function useCount() { const context = React.useContext(CountContext); if (!context) { throw new Error('useCount must be used within a CountProvider'); } const { count, setCount } = context; const increment = () => setCount((c) => c + 1); return { count, increment, }; } export { CountProvider, useCount }; Router Hook import { useContext, useEffect } from 'react'; import { __RouterContext } from 'react-router'; import useForceUpdate from 'use-force-update'; const useReactRouter = () => { const forceUpdate = useForceUpdate(); const routerContext = useContext(__RouterContext); useEffect(() => routerContext.history.listen(forceUpdate), [routerContext]); return routerContext; }; Script Loading Hook // Hook let cachedScripts = []; const useScript = (src) => { // Keeping track of script loaded and error state const [state, setState] = useState({ loaded: false, error: false, }); useEffect( () => { // If cachedScripts array already includes src // that means another instance ... // ... of this hook already loaded this script, so no need to load again. if (cachedScripts.includes(src)) { setState({ loaded: true, error: false, }); } else { cachedScripts.push(src); // Create script let script = document.createElement('script'); script.src = src; script.async = true; // Script event listener callbacks for load and error const onScriptLoad = () => { setState({ loaded: true, error: false, }); }; const onScriptError = () => { // Remove from cachedScripts we can try loading again const index = cachedScripts.indexOf(src); if (index >= 0) cachedScripts.splice(index, 1); script.remove(); setState({ loaded: true, error: true, }); }; script.addEventListener('load', onScriptLoad); script.addEventListener('error', onScriptError); // Add script to document body document.body.appendChild(script); // Remove event listeners on cleanup return () => { script.removeEventListener('load', onScriptLoad); script.removeEventListener('error', onScriptError); }; } }, [src] // Only re-run effect if script src changes ); return [state.loaded, state.error]; }; Form Hook import { useState } from 'react'; const useForm = (callback) => { const [values, setValues] = useState({}); const handleSubmit = (event) => { if (event) event.preventDefault(); callback(); }; const handleChange = (event) => { event.persist(); setValues((values) => ({ ...values, [event.target.name]: event.target.value, })); }; return { handleChange, handleSubmit, values, }; }; export default useForm; export const useField = ( name, form, { defaultValue, validations = [], fieldsToValidateOnChange = [name] } = {} ) => { let [value, setValue] = useState(defaultValue); let [errors, setErrors] = useState([]); let [pristine, setPristine] = useState(true); let [validating, setValidating] = useState(false); let validateCounter = useRef(0); const validate = async () => { let validateIteration = ++validateCounter.current; setValidating(true); let formData = form.getFormData(); let errorMessages = await Promise.all( validations.map((validation) => validation(formData, name)) ); errorMessages = errorMessages.filter((errorMsg) => !!errorMsg); if (validateIteration === validateCounter.current) { // this is the most recent invocation setErrors(errorMessages); setValidating(false); } let fieldValid = errorMessages.length === 0; return fieldValid; }; useEffect(() => { if (pristine) return; // Avoid validate on mount form.validateFields(fieldsToValidateOnChange); }, [value]); let field = { name, value, errors, setErrors, pristine, onChange: (e) => { if (pristine) { setPristine(false); } setValue(e.target.value); }, validate, validating, }; form.addField(field); return field; }; export const useForm = ({ onSubmit }) => { let [submitted, setSubmitted] = useState(false); let [submitting, setSubmitting] = useState(false); let fields = []; const validateFields = async (fieldNames) => { let fieldsToValidate; if (fieldNames instanceof Array) { fieldsToValidate = fields.filter((field) => fieldNames.includes(field.name) ); } else { //if fieldNames not provided, validate all fields fieldsToValidate = fields; } let fieldsValid = await Promise.all( fieldsToValidate.map((field) => field.validate()) ); let formValid = fieldsValid.every((isValid) => isValid === true); return formValid; }; const getFormData = () => { return fields.reduce((formData, f) => { formData[f.name] = f.value; return formData; }, {}); }; return { onSubmit: async (e) => { e.preventDefault(); setSubmitting(true); setSubmitted(true); // User has attempted to submit form at least once let formValid = await validateFields(); let returnVal = await onSubmit(getFormData(), formValid); setSubmitting(false); return returnVal; }, isValid: () => fields.every((f) => f.errors.length === 0), addField: (field) => fields.push(field), getFormData, validateFields, submitted, submitting, }; }; const Field = ({ label, name, value, onChange, errors, setErrors, pristine, validating, validate, formSubmitted, ...other }) => { let showErrors = (!pristine || formSubmitted) && !!errors.length; return ( {label} !pristine && validate()} endAdornment={ {validating && } } {...other} /> {showErrors && errors.map((errorMsg) => {errorMsg})} ); }; const App = (props) => { const form = useForm({ onSubmit: async (formData, valid) => { if (!valid) return; await timeout(2000); // Simulate network time if (formData.username.length { await timeout(2000); return formData.username.length formData.password.length formData.password !== formData.confirmPassword && 'Passwords do not match', ], fieldsToValidateOnChange: ['password', 'confirmPassword'], }); let requiredFields = [usernameField, passwordField, confirmPasswordField]; return ( f.pristine) } > {form.submitting ? 'Submitting' : 'Submit'} ); }; Hooks Best Practice 如果将一个函数任意地将其放在 useEffect Deps List 中 可能会导致重复无意义的 useEffect 执行 (因为每次 render 期间的此函数都会重新定义). 有两个解决办法: 对于被多次复用 Utils 函数 (且不依赖组件的任何值), 应该提到组件外面的公共区域去定义. 对于只被特定 Effect Hook 调用的 Utils 函数, 可以放到 useEffect 内部定义. 对于其他需要在组件内(或自定义 Hooks 内)定义的函数, 可使用 useCallback 包裹函数, 并设置正确的 Deps List, 尽可能地减少 render 时重新定义此函数. // ✅ Not affected by the data flow function getFetchUrl(query) { return 'https://hn.algolia.com/api/v1/search?query=' + query; } function SearchResults() { useEffect(() => { const url = getFetchUrl('react'); // ... Fetch data and do something ... }, []); // ✅ Deps are OK useEffect(() => { const url = getFetchUrl('redux'); // ... Fetch data and do something ... }, []); // ✅ Deps are OK // ... } Don't forget to cleanup side effects (return function in useEffect) Set correct deps list for useEffect: avoid object deps (should use object property). enough deps list to avoid infinite loop rendering pitfall. enough deps list to avoid stale closure. setState(state => state + 1) is better (avoid outdated state). Change useState to useRef when values not for rendering. Don't put any if statement before hooks function. ES6 Syntax Comments render() { {/* */} {/* */} } Binding for This constructor() { this.handle = this.handle.bind(this); } handle(e) { this.setState({ ... }); } state = {}; handle = (e) => {}; React Style Guide Naming Style use PascalCase for .jsx and component constructor use camelCase for component instance reference use camelCase for props name // bad import reservationCard from './ReservationCard'; // good import ReservationCard from './ReservationCard'; // bad const ReservationItem = ; // good const reservationItem = ; setting displayname for HOC // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return ; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return ; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component'; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; } Props Style use prop not prop={true} filter out unnecessary props // bad render() { const { irrelevantProp, ...relevantProps } = this.props; return } // good render() { const { irrelevantProp, ...relevantProps } = this.props; return } Refs Style use callback refs // bad // deprecated // good { this.myRef = ref; }} /> Alignment Style // bad // good // if props fit in one line then keep it on the same line // children get indented normally // bad {showButton && } // bad { showButton && } // good {showButton && ( )} // good {showButton && } Quotes Style use \" for JSX attributes, use ' for all other JS // bad // good // bad // good Spacing Style a single space in self-closing tag no pad JSX curly spaces // bad // very bad // bad // good // bad // good Ordering of Class Component optional static methods constructor getChildContext getDerivedStateFromProps componentDidMount getDerivedStateFromProps shouldComponentUpdate getSnapshotBeforeUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() optional render methods like renderNavigation() or renderProfilePicture() render Project Structure Best Practice components: 模块化隔离, 最小依赖, 测试友好. 每个组件文件夹包含大写并与文件同名的组件, 且其中除了注入服务操作外, render return 之前, 无任何代码. use开头并与文件夹同名的服务. use开头, Service结尾, 并与文件夹同名的可注入服务. services: 服务中只存在基础 Hooks, 自定义 Hooks, 第三方 Hooks, 静态数据, 工具函数, 工具类. MVC and MVVM Controller 处理请求的参数 渲染和重定向 选择 Model 和 Service 处理 Session 和 Cookies Comparison 初始渲染: Virtual DOM > 脏检查 >= 依赖收集 小量数据更新: 依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化 大量数据更新: 脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM（无法/无需优化）>> MVVM 无优化 Best Practice 组件细分化 组件 只传入必要的 props 使用 immutablejs 或者 react.addons.update 实现不可变数据结构 结合 React.addons.PureRenderMixin 来减少 reRender 在 shouldComponentUpdate 中优化组件减少 reRender 使用 context 少做 dom 操作，始终让 UI 能够基于 State 还原 在 store 和 action 中不 dom 操作或者访问 window.属性，只与数据打交道 推荐使用 ES6 npm 的 debug 包，log 组件渲染的每个步骤和动作 Singel Modern React Lazy and Suspense import React, { lazy, Suspense } from 'react'; const Product = lazy(() => import('./ProductHandler')); const App = () => ( My Awesome Product Product list is loading...}> Take a look at my product: ); const { lazy, Suspense } = React; const Lazy = lazy( () => new Promise((resolve) => { setTimeout(() => { resolve({ default: () => }); }, 4000); }) ); const Resource = () => ( React Lazy This component loaded after 4 seconds, using React Lazy and Suspense ); const App = () => { return ( Loading...}> ); }; ReactDOM.render(, document.getElementById('root')); Context API function contextWrapper(WrappedComponent, Context) { return class extends React.Component { render() { return ( {(context) => } ); } }; } Ref with Context // Context.js import React, { Component, createContext } from 'react'; // React team — thanks for Context API 👍 const context = createContext(); const { Provider: ContextProvider, Consumer } = context; class Provider extends Component { // refs // usage: this.textareaRef.current textareaRef = React.createRef(); // input handler onInput = (e) => { const { name, value } = e.target; this.setState({ [name]: value, }); }; render() { return ( {this.props.children} ); } } // TextArea.jsx import React from 'react'; import { Consumer } from './Context'; const TextArea = () => ( {(context) => ( )} ); Error Boundary 以下是错误边界不起作用的情况: 在事件处理器内 setTimeout 或 requestAnimationFrame 回调中的异步代码 在服务端渲染期间 错误边界代码本身中引发错误时 class ErrorBoundary extends React.Component { state = { hasError: false, error: null, info: null, }; // key point componentDidCatch(error, info) { this.setState({ hasError: true, error: error, info: info, }); } render() { if (this.state.hasError) { return ( Oops, something went wrong :( The error: {this.state.error.toString()} Where it occured: {this.state.info.componentStack} ); } return this.props.children; } } React Fragment class Items extends React.Component { render() { return ( ) } } class Fruit extends React.Component { render() { return ( <> Apple Orange Blueberry Cherry ) } } class Frameworks extends React.Component { render () { return ( [ JavaScript: React, Vuejs, Angular ] ) } } Portals Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component ReactDOM.createPortal(child, container). const portalRoot = document.getElementById('portal'); class Portal extends React.Component { constructor() { super(); this.el = document.createElement('div'); } componentDidMount = () => { portalRoot.appendChild(this.el); }; componentWillUnmount = () => { portalRoot.removeChild(this.el); }; render() { const { children } = this.props; return ReactDOM.createPortal(children, this.el); } } class Modal extends React.Component { render() { const { children, toggle, on } = this.props; return ( {on ? ( {children} Close ) : null} ); } } class App extends React.Component { state = { showModal: false, }; toggleModal = () => { this.setState({ showModal: !this.state.showModal, }); }; render() { const { showModal } = this.state; return ( Hello, I am the parent! Toggle Modal {showModal ? Hello, I am the portal! : null} ); } } ReactDOM.render(, document.getElementById('root')); React Performance use key correctly shouldComponentUpdate React.PureComponent: shallow compare diff React.memo: shallow compare diff stateless component Immutable.js Isomorphic rendering Webpack bundle analyzer Progressive React Re-rendering Problem The major difference is that React.Component doesn’t implement the shouldComponentUpdate() lifecycle method while React.PureComponent implements it. If component's render() function renders the same result given the same props and state, use React.PureComponent/React.memo for a performance boost in some cases. import React, { PureComponent } from 'react'; const Unstable = (props) => { console.log(' Rendered Unstable component '); return ( {props.value} ); }; class App extends PureComponent { state = { value: 1, }; componentDidMount() { setInterval(() => { this.setState(() => { return { value: 1 }; }); }, 2000); } render() { return ( ); } } export default App; import React, { Component } from 'react'; const Unstable = React.memo((props) => { console.log(' Rendered this component '); return ( {props.value} ); }); class App extends Component { state = { value: 1, }; componentDidMount() { setInterval(() => { this.setState(() => { return { value: 1 }; }); }, 2000); } render() { return ( ); } } export default App; Prevent useless re-rendering: shouldComponentUpdate React.PureComponent: shallow compare diff React.memo: shallow compare diff, to memorize stateless components that props not changed often. memorized values memorized event handlers 在用memo或者useMemo做优化前 (Before You Memo), 可以从不变的部分里分割出变化的部分. 通过将变化部分的state向下移动从而抽象出变化的子组件, 或者将变化内容提升到父组件从而将不变部分独立出来: // BAD import { useState } from 'react'; export default function App() { let [color, setColor] = useState('red'); return ( setColor(e.target.value)} /> Hello, world! ); } function ExpensiveTree() { let now = performance.now(); while (performance.now() - now I am a very slow component tree.; } // GOOD export default function App() { return ( <> ); } function Form() { let [color, setColor] = useState('red'); return ( <> setColor(e.target.value)} /> Hello, world! ); } // GOOD export default function App() { return ( Hello, world! ); } function ColorPicker({ children }) { let [color, setColor] = useState('red'); return ( setColor(e.target.value)} /> {children} ); } // BAD function App(items) { return ; } // GOOD const bigListStyle = { width: '100%' }; function App(items) { return ; } // BAD: Inline function function App(items) { return dispatchEvent()} />; } // GOOD: Reference to a function const clickHandler = () => dispatchEvent(); function App(items) { return ; } Code Spliting import React, { Component } from 'react'; import { Formik } from 'formik'; import * as Yup from 'yup'; const formValidator = Yup.object().shape({ /* ... */ }); export default class Form extends Component { render() { return {/* ... */}; } } import React, { Component } from 'react'; export default class App extends Component { constructor() { super(); this.state = { Form: undefined, }; } render() { const { Form } = this.state; return ( {Form ? : Show form} ); } showForm = async () => { const { default: Form } = await import('./Form'); this.setState({ Form }); }; } Server Side Rendering Application code is written in a way that it can be executed both on the server and on the client. The browser displays the initial HTML (fetch from server), simultaneously downloads the single-page app (SPA) in the background. Once the client-side code is ready, the client takes over and the website becomes a SPA. 前后端分离是一种进步，但彻底的分离，也不尽善尽美， 比如会有首屏加载速度和 SEO 方面的困扰。 前后端分离+服务端首屏渲染看起来是个更优的方案， 它结合了前后端分离和服务端渲染两者的优点， 既做到了前后端分离，又能保证首页渲染速度，还有利于 SEO。 Pros of SSR Performance Smaller first meaningful paint time HTML's strengths: progressive rendering Browsers are incredibly good at rendering partial content SEO Search engine crawlers used to not execute scripts (or initial scripts) Search engine usually stop after a while (roughly 10 seconds) SPAs can't set meaningful HTTP status codes Awesome Library Next.js for Isomorphic rendering Basic Example presentation webpack config module.exports = [ webConfig, nodeConfig, ]; const webConfig = {} ...baseConfig, target: 'web', }; const nodeConfig = { ...baseConfig, target: 'node', output: { ...baseConfig.output, libraryTarget: 'commonjs2', }, externals: [require('webpack-node-externals')()], }; start.server.js import React from 'react'; import ReactDOMServer from \"react-dom/server\"; import App from './App.js'; export deafult () => ReactDOMServer.renderToString(); index.html.js const startApp = require('../dist/server.js').default; module.exports = () => ` ... ${startApp()} start.client.js import React from 'react'; import ReactDOMServer from 'react-dom'; import App from './App.js'; ReactDOM.hydrate(, document.getElementById('app')); async fetch out of const data = await fetchData(); const app = return { html: ReactDOMServer.renderToString(app); state: { data } }; Internationalization react-intl Simple Intl // locale/zh.js export default ({ hello: '你好，{name}' }); // locale/en.js export default ({ hello: 'Hello，{name}' }) ; import IntlMessageFormat from 'intl-messageformat'; import zh from '../locale/zh'; import en from '../locale/en'; const MESSAGES = { en, zh }; const LOCALE = 'en'; // 这里写上决定语言的方法，例如可以从 cookie 判断语言 class Intl { get(key, defaultMessage, options) { let msg = MESSAGES[LOCALE][key]; if (msg == null) { if (defaultMessage != null) { return defaultMessage; } return key; } if (options) { msg = new IntlMessageFormat(msg, LOCALE); return msg.format(options); } return msg; } } export default Intl; Testing Complete Tutorial Jest and Enzyme Snapshots Testing Cypress - Testing Framework Shallow Renderer 浅层渲染 (Shallow Renderer) 对于在 React 中编写单元测试用例很有用. 它允许渲染一个一级深的组件并断言其渲染方法返回的内容, 而不必担心子组件未实例化或渲染. function MyComponent() { return ( {'Title'} {'Description'} ); } import ShallowRenderer from 'react-test-renderer/shallow'; const renderer = new ShallowRenderer(); renderer.render(); const result = renderer.getRenderOutput(); expect(result.type).toBe('div'); expect(result.props.children).toEqual([ {'Title'}, {'Description'}, ]); Test Renderer 测试渲染器 (Test Renderer) 可用于将组件渲染为纯 JavaScript 对象, 而不依赖于 DOM 或原生移动环境. 该包可以轻松获取由 ReactDOM 或 React Native 平台所渲染的视图层次结构 (类似于 DOM 树) 的快照, 而无需使用浏览器或 jsdom. import TestRenderer from 'react-test-renderer'; const Link = ({ page, children }) => {children}; const testRenderer = TestRenderer.create( {'Facebook'} ); console.log(testRenderer.toJSON()); // { // type: 'a', // props: { href: 'https://www.facebook.com/' }, // children: [ 'Facebook' ] // } Enzyme npm install --save-dev enzyme enzyme-adapter-react-16 import React from 'react'; import { configure, shallow } from 'enzyme'; import Adapter from 'enzyme-adapter-react-16'; import { DataTable } from './components'; configure({ adapter: new Adapter() }); describe(() => { it('renders in table rows based on provided columns', () => { const cols = [ { header: 'ID', name: 'id' }, { header: 'Name', name: 'name' }, { header: 'Email', name: 'email' }, ]; const data = [ { id: 5, name: 'John', email: 'john@example.com' }, { id: 6, name: 'Liam', email: 'liam@example.com' }, { id: 7, name: 'Maya', email: 'maya@example.com', someTest: 10 }, { id: 8, name: 'Oliver', email: 'oliver@example.com', hello: 'hello world', }, { id: 25, name: 'Amelia', email: 'amelia@example.com' }, ]; // Shallow render Data Table const container = shallow(); // There should be ONLY 1 table element const table = container.find('table'); expect(table).toHaveLength(1); // The table should have ONLY 1 thead element const thead = table.find('thead'); expect(thead).toHaveLength(1); // The number of th tags should be equal to number of columns const headers = thead.find('th'); expect(headers).toHaveLength(cols.length); // Each th tag text should equal to column header headers.forEach((th, idx) => { expect(th.text()).toEqual(cols[idx].header); }); // The table should have ONLY 1 tbody tag const tbody = table.find('tbody'); expect(tbody).toHaveLength(1); // tbody tag should have the same number of tr tags as data rows const rows = tbody.find('tr'); expect(rows).toHaveLength(data.length); // Loop through each row and check the content rows.forEach((tr, rowIndex) => { const cells = tr.find('td'); expect(cells).toHaveLength(cols.length); expect(cells.at(0).text()).toEqual(data[rowIndex].id); expect(cells.at(1).text()).toEqual(data[rowIndex].name); expect(cells.at(2).text()).toEqual(data[rowIndex].email); }); }); }); Create React App Custom React Scripts npx create-react-app app-name --scripts-version @sabertazimi/react-scripts --use-npm npm init react-app app-name --scripts-version @sabertazimi/react-scripts --use-npm React Scripts React Scripts Initilization Initialization in react-scripts/scripts/init.js: 可以用于改变默认 registry 'use strict'; const registries = { npm: 'https://registry.npmjs.org', yarn: 'https://registry.yarnpkg.com', aliyun: 'https://registry.npm.taobao.org', }; module.exports = registries; 自定义安装默认依赖 (react, react-dom, react-router, redux etc.) 额外安装模板依赖 packages.dependencies in cra-template/template.json Setup package.json: appPackage.homepage, appPackage.dependencies, appPackage.scripts, appPackage.eslintConfig, appPackage.browser. React Scripts Commands Locating in react-scripts/scripts/: start.js for react-scripts start // 增加关机提示信息 ['SIGINT', 'SIGTERM'].forEach(function (sig) { process.on(sig, function () { console.log(chalk.cyan('Gracefully shutting down. Please wait...\\n')); devServer.close(); process.exit(); }); }); build.js for react-scripts build test.js for react-scripts test eject.js for react-scripts eject React Scripts Configuration Config in react-scripts/config/ directory: env.js: static environment variables getHttpsConfig.js: get HTTPS(SSL) config modules.js: locale modules webpack alias with baseUrl paths.js: configurable paths variables (most for Webpack config) webpackDevServer.config.js: Webpack Dev Server configuration webpack.config.js: Webpack configuration (paths, deps/devDeps, plugins, loader rules etc.) // add support for Ant Design UI { test: /\\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: { customize: require.resolve( 'babel-preset-react-app/webpack-overrides' ), plugins: [ [ require.resolve('babel-plugin-import'), { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\", }, ], ], cacheDirectory: true, cacheCompression: isEnvProduction, compact: isEnvProduction, }, } // add Webpack bundle analyzer plugin const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer'); { plugins: [ isEnvDevelopment && new BundleAnalyzerPlugin({ analyzerPort: 5000, }), ]; } Other Packages in CRA Repo babel-preset-react-app: babel preset configuration cra-template/cra-template-typescript: CRA default templates eslint-config-react-app: eslint configuration react-app-polyfill: polyfills for various browsers react-dev-utils: most utility functions for paths, helpers, middleware, and webpack plugins. Custom CRA custom packages/cra-template-*: change HTML/CSS/JS boilerplate. custom packages/react-scripts/config/: change paths, deps/devDeps, plugins, loader rules etc. custom packages/react-scripts/scripts/: change react-scripts CLI behaviors. CRA Templates HTML/CSS/JSX boilerplate in react-scripts/template/ directory, now Templates are always named in the format cra-template-[template-name] in packages/cra-template and packages/cra-template-typescript. npx create-react-app my-app --template [template-name] Deployment Offical Documentation Deploy Subdirectory Styled Component Basic Usage Shared CSS Styles // Import React.js, styled-components and css import React from 'react'; import styled, { css } from 'styled-components'; const container = document.querySelector('.container'); // Define new const with bold style const headingStyle = css` font-weight: bold; `; // Define typography styles const H1 = styled.h1` font-size: 54px; // Using headingStyle const ${headingStyle} `; const H2 = styled.h2` font-size: 36px; // Using headingStyle const ${headingStyle} `; const H3 = styled.h3` font-size: 24px; // Using headingStyle const ${headingStyle} `; const H4 = styled.h4` font-size: 16px; // Using headingStyle const ${headingStyle} `; const H5 = styled.h5` font-size: 14px; // Using headingStyle const ${headingStyle} `; const H6 = styled.h6` font-size: 12px; // Using headingStyle const ${headingStyle} `; const Text = styled.p` font-size: 16px; `; const Small = styled.small` font-size: 80%; `; // Use our styles const WrapperContainer = () => ( Heading h1 Heading h2 Heading h3 Heading h4 Heading h5 Heading h6 Body text Small text ); ReactDOM.render(, container); Extend Styled Component // Import React.js and styled-components import React from 'react'; import styled from 'styled-components'; const container = document.querySelector('.container'); const Button = styled.button` padding: 12px 24px; font-size: 16px; color: #fff; border: 0; border-radius: 35px; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23); cursor: pointer; `; // Using extend to create a red variant of the button const RedButton = Button.extend` background-color: #e74c3c; `; // Using extend to create a green variant of the button const GreenButton = Button.extend` background-color: #2ecc71; `; // Use our styles const WrapperContainer = () => ( Defaul button Red button Green button ); ReactDOM.render(, container); Props for Styled Component // Import React.js, styled-components and css import React from 'react'; import styled, { css } from 'styled-components'; const container = document.querySelector('.container'); const Button = styled.button` padding: 12px 24px; font-size: 16px; border: 0; border-radius: 35px; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23); cursor: pointer; // Using props to create a gray variant of the button ${(props) => props.gray && css` background-color: #95a5a6; `} // Using props to create a green variant of the button ${(props) => props.green && css` background-color: #2ecc71; `} // Using props to create a red variant of the button ${(props) => props.red && css` background-color: #e74c3c; `} // We can also use a ternary operator for \"binary\" changes color: ${(props) => (props.gray ? '#2c3e50' : '#fff')}; `; const WrapperContainer = () => ( Defaul button {/* Button with prop \"red\" */} Red button {/* Button with prop \"green\" */} Green button ); ReactDOM.render(, container); Framework Paradigm full-featured frameworks vs composing micro-libs Evan You on Vue.js: Seeking the Balance in Framework Design | JSConf.Asia 2019 functional vs imperative immutable vs mutable referential equality testing vs change tracking 打破框架的范式之争, 其实是改变思路. 从思考不同范式之间的竞争关系, 转变成思考多个范式之间的协同关系. useRef in React, Composition in Vue Third-party Libraries Usage Look for Libraries that Have Accessibility Built in. Limit the Number of Third-party Libraries Use. Wrap Third-party Dependencies: import { DatePicker as LibraryXDatePicker } from 'LibraryX'; const DatePicker = (props) => { return ; }; export default DatePicker; Interviews React Interview Questions © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/reactjs/reactRouterBasicNotes.html":{"url":"programming/web/reactjs/reactRouterBasicNotes.html","title":"React Router Basic Notes","keywords":"","body":"React Router Basic Notes React Router Basic Notes Router and Route Basic Usage Nested Route Private Route URL Params Component Props Link/URL Props Clean URLs Change Route Deployment Relative Path Webpack Dev Server Express Config Nginx Config A Simple React Router Route Component Link Component Redirect Component Reference Router and Route parent routes are active when child routes are active Basic Usage import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom'; class App extends Component { render() { return ( { return ; }} /> ); } } Nested Route Key Notes: In component of parent route, should render {this.props.children} import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom'; render( , document.getElementById('app') ); In App.js: render() { return (... {this.props.children}); } In Repos.js: render() { return (... {this.props.children}); } Private Route const PrivateRoute = ({ component: Component, toAuth, ...rest }) => { return ( ( auth.isAuthenticated() === true ? : )}/> ); } URL Params // In Repo.js {this.props.params.userName} {this.props.params.repoName} Component Props subroutes id/size etc... } /> Link/URL Props to={ pathname: url, state: { ... } } ... const { ... } = this.props.location.state; Clean URLs replace hashHistory for browserHistory Change Route onEnter = { () => store.dispatch(createRouteAction(params))} return conditionaly and withRouter wrapper (this.props.history.push('nextURL')) class Login = () => { login = () => { // 1. login // 2. setState and pushHistory (500ms delay) auth.login(() => { const { from } = this.props.location.state || { from: { pathname: '/' }}; this.setState({ redirect: true }); this.props.history.push(from); }, 500); } render() { const { redirect } = this.state; const { from } = this.props.location.state || { from: { pathname: '/' }}; if (redirect) { return ( ) } return ( Login ); } } // apply `history` object to props of `Login` component export default withRouter(Login); Deployment Relative Path } /> ; const Header = () => ( Home About ); Webpack Dev Server publicPath: '/' historyApiFallback: true const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './app/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'index_bundle.js', publicPath: '/' }, module: { rules: [ { test: /\\.(js)$/, use: 'babel-loader' }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, devServer: { historyApiFallback: true }, plugins: [ new HtmlWebpackPlugin({ template: 'app/index.html' }) ] }; Express Config app.use(express.static(path.resolve(__dirname, 'build'))); // always serve index.html for any request app.get('*', (req, res) => { res.sendFile(path.resolve(__dirname, 'build', 'index.html'); }); Nginx Config # always serve index.html for any request (react-router for single page application) root /var/www/blog/html/build; index index.html; server_name blog.sabertazimi.cn; location / { try_files $uri /index.html; } A Simple React Router instances listen to popstate event to forceUpdate. When click /, historyPush or historyReplace get called, instances re-match and re-render. const instances = []; const register = comp => instances.push(comp); const unregister = comp => instances.splice(instances.indexOf(comp), 1); const historyPush = path => { history.pushState({}, null, path); instances.forEach(instance => instance.forceUpdate()); }; const historyReplace = path => { history.replaceState({}, null, path); instances.forEach(instance => instance.forceUpdate()); }; Route Component const matchPath = (pathname, options) => { const { exact = false, path } = options; if (!path) { return { path: null, url: pathname, isExact: true }; } const match = new RegExp(`^${path}`).exec(pathname); if (!match) { // There wasn't a match. return null; } const url = match[0]; const isExact = pathname === url; if (exact && !isExact) { // There was a match, but it wasn't // an exact match as specified by // the exact prop. return null; } return { path, url, isExact }; }; class Route extends Component { static propTypes: { path: PropTypes.string, exact: PropTypes.bool, component: PropTypes.func, render: PropTypes.func }; componentWillMount() { addEventListener('popstate', this.handlePop); register(this); } componentWillUnmount() { removeEventListener('popstate', this.handlePop); unregister(this); } handlePop = () => { this.forceUpdate(); }; render() { const { path, exact, component, render } = this.props; const match = matchPath(location.pathname, { path, exact }); if (!match) { return null; } if (component) { return React.createElement(component, { match }); } if (render) { return render({ match }); } return null; } } Link Component Whenever a is clicked and the location changes, each will be aware of that and re-match and re-render with instances. class Link extends Component { static propTypes = { to: PropTypes.string.isRequired, replace: PropTypes.bool }; handleClick = event => { const { replace, to } = this.props; event.preventDefault(); replace ? historyReplace(to) : historyPush(to); }; render() { const { to, children } = this.props; return ( {children} ); } } Redirect Component class Redirect extends Component { static defaultProps = { push: false }; static propTypes = { to: PropTypes.string.isRequired, push: PropTypes.bool.isRequired }; componentDidMount() { const { to, push } = this.props; push ? historyPush(to) : historyReplace(to); } render() { return null; } } Reference React Router Tutorial © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/reactjs/reduxBasicNotes.html":{"url":"programming/web/reactjs/reduxBasicNotes.html","title":"Redux Basic Notes","keywords":"","body":"﻿# Redux Basic Notes Redux Basic Notes Basic Concepts Store and State Store State Persisted State Reducers Map to Props Middleware Middleware Basic Concepts Middleware Simple Implementation Scheduler Middleware redux-thunk Middleware Redux Internal Create Store Action Validation Provider and Connection Redux Best Practice State Management Awesome Tools Libs Data Types Network Middleware Tool State Tool Debugging Basic Concepts 单一数据源: 整个应用程序的状态存储在单个对象树中 (容易跟踪/调试) 状态只读: 通过 dispatch(action) 间接更改状态, 不直接写入状态 纯函数更改状态: reducer(state, action) => newState Store and State Store Redux 中只有一个全局唯一 store 状态树, 且由 reducers 创建 store. export default (appStore = createStore(rootReducers, initState)); State 在 Redux 中 State 并不显式定义: 初态与变化态皆由 Reducers 定义并控制 Actions 中保存着 action.type 外, 还保存着供 Reducers 进行有效状态变化的其他信息(可自定义) 调用 Dispatch 方法自动向 Store 传递一个 Action(因为只有一个全局 Store, 故无需额外指定 Store 参数), Store 遍历调用其中的 Reducers, 根据 switch 语句进行匹配 action 处理 reducer 只保存最基本的 state, 可计算出的 state 放在 mapStateToProps(selector) 中直接计算后绑定至 props 将数据保存在 Redux 存储中, 并在组件内部保持 UI 相关状态 Persisted State // localStorage.getItem('state')/localStorage.setItem('state', serializedState) const persistedState = loadLocalStorageState(); const appStore = createStore(rootReducers, persistedState); const appStore.subscribe(throttle(() => { saveLocalStorageState({ todos: store.getState().todos }); }, 1000)); Reducers Reducing Boilerplate 必须保持无任何副作用: 不修改传入参数, 不调用副作用函数 (api/date.now()/math.random()) function createReducer(initialState, handlers) { return function reducer(state = initialState, action) { if (handlers.hasOwnProperty(action.type)) { return handlers[action.type](state, action) } else { return state } } } const reducer = createReducer(initialState, { reset: () => initialState, increment: state => ({ count: state.count + 1}), decrement: state => ({ count: state.count + 1}), [ActionTypes.ADD_TODO]: (state, action) => { ...; }, }); Map to Props dump components implementation // app.js React.render( {() => }, rootEl ); // dump component import { Component } from 'react'; export default class Counter extends Component { render() { return {this.props.value}; } } import { Component } from 'react'; import { connect } from 'react-redux'; import Counter from '../components/Counter'; import { increment } from '../actionsCreators'; // Which part of the Redux global state does our component want to receive as props? function mapStateToProps(state) { return { value: state.counter }; } // Which action creators does it want to receive by props? function mapDispatchToProps(dispatch) { return { onIncrement: () => dispatch(increment()) }; } export default connect( // Line 20 mapStateToProps, mapDispatchToProps )(Counter); Middleware Middleware Basic Concepts 每一个 Middleware 可以得到: 最初的 store 对象 (dispatch 属性还是原来的)， 因此，可以通过 store.getState 获得最近的状态， 以及通过原本的 dispatch 对象直接发布 action 对象， 跳过其他 Middleware dispatch 方法（next）。 上面 vanillaPromise 演示了这样的用法。 next 方法: 前一个 Middleware 返回的 dispatch 方法。 当前 Middleware 可以根据自己对 action 的判断和处理结果， 决定是否调用 next 方法，以及传入什么样的参数。 Middleware Simple Implementation function applyMiddleware(store, middlewares) { middlewares = middlewares.slice(); middlewares.reverse(); let next = store.dispatch; middlewares.forEach(middleware => (next = middleware(store)(next))); return Object.assign({}, store, { dispatch: next }); } import { createStore, combineReducers, applyMiddleware } from 'redux'; // applyMiddleware takes createStore() and returns // a function with a compatible API. let createStoreWithMiddleware = applyMiddleware(logger, crashReporter)( createStore ); // Use it like you would use createStore()let todoApp = combineReducers(reducers); let store = createStoreWithMiddleware(todoApp); Scheduler Middleware /** * Schedules actions with { meta: { delay: N } } to be delayed by N milliseconds. * Makes `dispatch` return a function to cancel the interval in this case. */ const timeoutScheduler = store => next => action => { if (!action.meta || !action.meta.delay) { return next(action); } let intervalId = setTimeout(() => next(action), action.meta.delay); return function cancel() { clearInterval(intervalId); }; }; redux-thunk Middleware // thunk middleware const thunk = store => next => action => typeof action === 'function' ? action(store.dispatch, store.getState) : next(action); const createStoreWithMiddleware = applyMiddleware( logger， thunk timeoutScheduler )(createStore); const store = createStoreWithMiddleware(combineReducers(reducers)); function addFave(tweetId) { return (dispatch, getState) => { if (getState.tweets[tweetId] && getState.tweets[tweetId].faved) return; dispatch({type: IS_LOADING}); // Yay, that could be sync or async dispatching remote.addFave(tweetId).then( (res) => { dispatch({type: ADD_FAVE_SUCCEED}) }, (err) => { dispatch({type: ADD_FAVE_FAILED, err: err}) }, }; } store.dispatch(addFave()); Redux Internal Create Store use closure to store state and subscribe use middleware to change normal dispatch function const applyMiddleware = (...middlewares) => store => { // should return (next) => (action) => { ... } function if (middlewares.length === 0) { return dispatch => dispatch; } if (middlewares.length === 1) { return middlewares[0]; } // [ (next) => (action) => {...}, ... ] array // next: (action) => { ... } function const boundMiddlewares = middlewares.map(middleware => middleware(store)); return boundMiddlewares.reduce((a, b) => next => a(b(next))); }; const createStore = (reducer, middleware) => { // clousre for storing global state let state = undefined; const subscribers = []; const coreDispatch = action => { validateAction(action); state = reducer(state, action); subscribers.forEach(handler => handler()); }; const getState = () => state; const store = { dispatch: coreDispatch, getState, subscribe: handler => { subscribers.push(handler); // unsubscribe function return () => { const index = subscribers.indexOf(handler); if (index > 0) { subscribers.splice(index, 1); } }; } }; if (middleware) { // store default dispatch const dispatch = action => store.dispatch(action); // middleware = ({ dispatch, getState }) => (next) => (action) => { ... }; // middleware is a higher-order function (return (action) => { ... }); // dispatch, getState and coreDispatch are injected into middleware as arguments store.dispatch = middleware({ dispatch, getState })(coreDispatch); } coreDispatch({ type: INIT_MEDUX }); return store; }; Action Validation const isValidKey = key => { return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1; }; const validateAction = action => { if (!action || typeof action !== 'object' || Array.isArray(action)) { throw new Error('Action must be an object!'); } if (typeof action.type === 'undefined') { throw new Error('Action must have a type!'); } if (!Object.keys(action).every(isValidKey)) { throw new Error( 'Action only have `type`, `payload`, `error` or `meta` field!' ); } }; Provider and Connection use Context to provide store (two methods): inject store into every children recursively use Consumer in Connect higher order component {store => ()} export const Provider = ({ store, children }) => { const StoreContext = React.createContext(store); return ( {store => { const childrenWithStore = React.Children.map(children, child => React.cloneElement(child, { store: store }) ); return {childrenWithStore}; }} ); }; export const connect = ( mapStateToProps = () => ({}), mapDispatchToProps = () => ({}) ) => Component => { class Connected extends React.Component { onStoreOrPropsChange(props) { const { store } = this.props; const state = store.getState(); const stateProps = mapStateToProps(state, props); const dispatchProps = mapDispatchToProps(store.dispatch, props); this.setState({ ...stateProps, ...dispatchProps }); } componentWillMount() { const { store } = this.props; this.onStoreOrPropsChange(this.props); this.unsubscribe = store.subscribe(() => this.onStoreOrPropsChange(this.props) ); } componentWillReceiveProps(nextProps) { this.onStoreOrPropsChange(nextProps); } componentWillUnmount() { this.unsubscribe(); } render() { return ; } } return Connected; }; Redux Best Practice 用 ES6, webpack, react-hot-loader....详细内容参照 MERN v2.0 Build production ready universal apps easily 区分 smart component (know the state) 和 dump component (stateless) component 里不要出现任何 async calls，交给 action creator 来做 reducer 尽量简单，复杂的交给 action creator reducer 里 return 新 state 的时候： Redux Devtools Redux React Styleguide Simple Redux API // add new item to state array // bad and does not work case \"ADD\": return state.push(newItem); // Good case \"ADD\": return [...state, newItem]; // delete new item to state array // bad and does not work case \"DELETE\": return state.splice(index, 1); // Good case \"DELETE\": return state.slice(0, index).concat(state.slice(index + 1)); // update new item to state array // First way case \"EDIT\": return state .slice(0, index) .concat([{ id: 'id', value: 'newValue' }]) .slice(index + 1); // Second way case \"EDIT\": return state.map(item => { if (item.id === 'id') { return { ...item, value: 'newValue' }; } else { return item; } }); action creator 里，用 promise/async/await 以及 redux-thunk 来帮助你完成想要的功能 // bad const loadTodo = (id) => (dispatch, getState) => { // only fetch the todo if it isn't already loaded if (!getState().todos.includes(id)) { const todo = await fetch(`/todos/${id}`); dispatch(addTodo(todo)); } } // good const loadTodo = (id, todos) => (dispatch) => { // only fetch the todo if it isn't already loaded if (!todos.includes(id)) { const todo = await fetch(`/todos/${id}`); dispatch(addTodo(todo)); } } 在 test 里不管你用 tape 还是 mocha，请用 enzyme.js 有些时候有些项目你并不需要 redux const fluxStandardAction = { type: 'ADD_TODO', payload: { text: 'Do something' }, meta: meta }; const fluxStandardAction = { type: 'ADD_TODO', payload: new Error(), error: true }; State Management Redux for global state: 作为全局状态管理. RxJS for redux middleware: RxJS 管理所有输入的 input -> redux action 的调度过程. Mobx and useState for component state: 作为组件局部状态管理器来用. 对于只影响单个组件实例的状态, 应作为 Local State 交由 useState 管理, 而不是将其并入 Global Store. state 变化很复杂时，用 action/state 归一化处理 data-input 很复杂时，用 RxJS/observable 归一化处理 UI 变化很复杂时，用 component 归一化处理 Awesome Tools Libs Data Types immutable.js: decrease useless copy and memory occupation Network node-fetch isomorphic-fetch Middleware Tool redux-thunk redux-sage redux-promise redux-diff-loger State Tool redux-undo reselect: memorize state transformation Debugging Redux Devtools © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/reactjs/webpackBasicNotes.html":{"url":"programming/web/reactjs/webpackBasicNotes.html","title":"Webpack Basic Notes","keywords":"","body":"Webpack Basic Notes Webpack Basic Notes Config Watch Options Resolve Path Options Flag Options Loader Configuration Babel Loader CSS Loader Thread Loader Optimization Common Libraries Common Chunks Code Minimization Code Spliting Tree Shaking Building Caches Perf Profiling Commit Linter Plugins HTML JavaScript CSS Images Building Work Bundles UI DLL Plugins Other Plugins Custom Plugin Migrate to 5 Reference Config Watch Options echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf sudo sysctl -p Resolve Path Options { resolve: { alias: { '#': path.resolve(__dirname, '/'), '~': path.resolve(__dirname, 'src'), '@': path.resolve(__dirname, 'src'), '~@': path.resolve(__dirname, 'src'), 'vendor': path.resolve(__dirname, 'src/vendor'), '~component': path.resolve(__dirname, 'src/components'), '~config': path.resolve(__dirname, 'config'), }, extensions: [ '.js', '.jsx', ], }, } jsconfig.json for vscode resolve path: { 'compilerOptions': { // This must be specified if 'paths' is set 'baseUrl': '.', // Relative to 'baseUrl' 'paths': { '*': ['*', 'src/*'] } } } { 'compilerOptions': { 'target': 'es2017', 'allowSyntheticDefaultImports': false, 'baseUrl': './', 'paths': { 'Config/*': ['src/config/*'], 'Components/*': ['src/components/*'], 'Ducks/*': ['src/ducks/*'], 'Shared/*': ['src/shared/*'], 'App/*': ['src/*'] } }, 'exclude': ['node_modules', 'dist'] } Flag Options --progress --colors -p Loader Configuration Babel Loader { test: /\\.(js|mjs|jsx|ts|tsx)$/, include: path.resolve('src'), use: [ 'thread-loader', { loader: require.resolve('babel-loader'); } ] options: { customize: require.resolve( 'babel-preset-react-app/webpack-overrides' ), plugins: [ [ require.resolve('babel-plugin-named-asset-import'), { loaderMap: { svg: { ReactComponent: '@svgr/webpack?-svgo,+titleProp,+ref![path]', }, }, }, ], ['lodash'], ], cacheDirectory: true, cacheCompression: false, compact: isEnvProduction, }, } CSS Loader const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); module.exports = { module: { rules: [ { test: /.s?css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'], }, ], }, optimization: { minimizer: [ // `...`, new CssMinimizerPlugin(), ], }, }; Thread Loader use: [ { loader: 'thread-loader', // loaders with equal options will share worker pools options: { // the number of spawned workers, defaults to (number of cpus - 1) or // fallback to 1 when require('os').cpus() is undefined workers: 2, // number of jobs a worker processes in parallel // defaults to 20 workerParallelJobs: 50, // additional node.js arguments workerNodeArgs: ['--max-old-space-size=1024'], // Allow to respawn a dead worker pool // respawning slows down the entire compilation // and should be set to false for development poolRespawn: false, // timeout for killing the worker processes when idle // defaults to 500 (ms) // can be set to Infinity for watching builds to keep workers alive poolTimeout: 2000, // number of jobs the poll distributes to the workers // defaults to 200 // decrease of less efficient but more fair distribution poolParallelJobs: 50, // name of the pool // can be used to create different pools with elsewise identical options name: 'my-pool', }, }, // your expensive loader (e.g babel-loader) ]; const threadLoader = require('thread-loader'); threadLoader.warmup( { // pool options, like passed to loader options // must match loader options to boot the correct pool }, [ // modules to load // can be any module, i. e. 'babel-loader', 'babel-preset-es2015', 'sass-loader', ] ); Optimization CDN 服务器端渲染 提取公共库 代码压缩 代码分割: Chunks 代码分割: 按需加载 多核构建 构建缓存 Common Libraries externals: { moment: 'window.moment', antd: 'window.antd', lodash: 'window._', react: 'window.React', 'react-dom': 'window.ReactDOM', } Common Chunks new webpack.optimize.CommonsChunkPlugin({ name: string, // or names: string[], // The chunk name of the commons chunk. // An existing chunk can be selected by passing a name of an existing chunk. // If an array of strings is passed this is equal to // invoking the plugin multiple times for each chunk name. // If omitted and `options.async` or `options.children` // is set all chunks are used, otherwise `options.filename` // is used as chunk name. // When using `options.async` to create common chunks // from other async chunks you must specify an entry-point // chunk name here instead of omitting the `option.name`. filename: string, // The filename template for the commons chunk. // Can contain the same placeholders as `output.filename`. // If omitted the original filename is not modified // (usually `output.filename` or `output.chunkFilename`). // This option is not permitted if you're using `options.async` as well, // see below for more details. minChunks: number|Infinity|function(module, count) => boolean, // The minimum number of chunks which need to contain a module // before it's moved into the commons chunk. // The number must be greater than or equal 2 // and lower than or equal to the number of chunks. // Passing `Infinity` creates the commons chunk, but moves no modules into it. // By providing a `function` you can add custom logic. // (Defaults to the number of chunks) chunks: string[], // Select the source chunks by chunk names. // The chunk must be a child of the commons chunk. // If omitted all entry chunks are selected. children: boolean, // If `true` all children of the commons chunk are selected deepChildren: boolean, // If `true` all descendants of the commons chunk are selected async: boolean|string, // If `true` a new async commons chunk is created // as child of `options.name` and sibling of `options.chunks`. // It is loaded in parallel with `options.chunks`. // Instead of using `option.filename`, // it is possible to change the name of the output file by providing // the desired string here instead of `true`. minSize: number, // Minimum size of all common module before a commons chunk is created. }); Code Minimization const TerserPlugin = require(\"terser-webpack-plugin\"); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); module.exports = { module: { rules: [ { test: /\\.(js|mjs|jsx|ts|tsx)$/, include: path.resolve('src'), use: [ 'thread-loader', { loader: require.resolve('babel-loader'); } }, { test: /.s?css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'], }, ], }, optimization: { minimize: true, minimizer: [ new TerserPlugin({ terserOptions: { parse: { ecma: 8, }, compress: { ecma: 5, warnings: false, drop_console: true, comparisons: false, inline: 2, }, mangle: { safari10: true, }, keep_classnames: isEnvProductionProfile, keep_fnames: isEnvProductionProfile, output: { ecma: 5, comments: false, ascii_only: true, }, }, parallel: true, cache: true, sourceMap: shouldUseSourceMap, }), new CssMinimizerPlugin(), ], }, }; Code Spliting require.ensure([], () => {}); async await import splitChunks: { chunks: 'initial', cacheGroups: { common: { chunks: 'initial', // all、async、initial minChunks: 5, name: 'common', priority: 9, enforce: true }, vendor: { test: /node_modules/, chunks: 'initial', name: 'vendor', priority: 10, enforce: true } } }, Tree Shaking 尽量不写带有副作用的代码: 诸如编写了立即执行函数, 在函数里又使用了外部变量等 如果对 ES6 语义特性要求不是特别严格, 可以开启 babel 的 loose 模式 etc. 是否真的要不可枚举 class 的属性 如果是开发 JavaScript 库, 使用 rollup(ES6 module export + code flow static analysis), 并且提供 ES6 module 的版本, 入口文件地址设置到 package.json 的 module 字段 如果 JavaScript 库开发中, 难以避免的产生各种副作用代码, 可以将功能函数或者组件, 打包成单独的文件或目录, 以便于用户可以通过目录去加载.如有条件，也可为自己的库开发单独的 webpack-loader, 便于用户按需加载 Building Caches new HardSourceWebpackPlugin({ // Either an absolute path or relative to webpack's options.context. cacheDirectory: 'node_modules/.cache/hard-source/[confighash]', // Either a string of object hash function given a webpack config. configHash: function(webpackConfig) { // node-object-hash on npm can be used to build this. return require('node-object-hash')({sort: false}).hash(webpackConfig); }, // Either false, a string, an object, or a project hashing function. environmentHash: { root: process.cwd(), directories: [], files: ['package-lock.json', 'yarn.lock'], }, // An object. info: { // 'none' or 'test'. mode: 'none', // 'debug', 'log', 'info', 'warn', or 'error'. level: 'debug', }, // Clean up large, old caches automatically. cachePrune: { // Caches younger than `maxAge` are not considered for deletion. They must // be at least this (default: 2 days) old in milliseconds. maxAge: 2 * 24 * 60 * 60 * 1000, // All caches together must be larger than `sizeThreshold` before any // caches will be deleted. Together they must be at least this // (default: 50 MB) big in bytes. sizeThreshold: 50 * 1024 * 1024 }, }), Perf Profiling const SpeedMeasurePlugin = require('speed-measure-webpack-plugin'); const smp = new SpeedMeasurePlugin(); const webpackConfig = smp.wrap({ plugins: [new MyPlugin(), new MyOtherPlugin()], }); npx webpack --mode production --profile --json > stats.json Optimize Helper Statics Chart Commit Linter { \"husky\": { \"hooks\": { \"commit-msg\": \"commitlint -e -V\", \"pre-commit\": \"lint-staged\" } }, \"lint-staged\": { \"src/**/*.{js,jsx, ts, tsx}\": [\"eslint --fix\", \"git add\"], \"src/**/*.{css, scss}\": [\"stylelint --fix\", \"git add\"] } } Plugins HTML HTML Plugin JavaScript UglifyJS Terser Plugin CSS Mini CSS Extract Plugin CSS Minimizer Plugin Images ImageMin Plugin Building Work Thread Loader Hard Source Plugin Speed Measure Plugin Bundles UI Bundle Analyzer Monitor Browser UI CLI UI DLL Plugins AutoDLL Plugin DLLReference Plugin Other Plugins Commons Chunk Plugin Preload plugin Prefetch plugin Define Plugin Provide Plugin CleanUp Plugin Custom Plugin const HtmlWebpackPlugin = require('html-webpack-plugin'); const childProcess = require('child_process'); const branch = childProcess .execSync('git rev-parse --abbrev-ref HEAD') .toString() .replace(/\\s+/, ''); const version = branch.split('/')[1]; const scripts = [ 'https://cdn.bootcss.com/react-dom/16.9.0-rc.0/umd/react-dom.production.min.js', 'https://cdn.bootcss.com/react/16.9.0/umd/react.production.min.js', ]; class HotLoad { apply(compiler) { compiler.hooks.beforeRun.tap('UpdateVersion', (compilation) => { compilation.options.output.publicPath = `./${version}/`; }); compiler.hooks.compilation.tap('HotLoadPlugin', (compilation) => { HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync( 'HotLoadPlugin', (data, cb) => { scripts.forEach((src) => [ data.assetTags.scripts.unshift({ tagName: 'script', voidTag: false, attributes: { src }, }), ]); cb(null, data); } ); }); } } module.exports = HotLoad; Migrate to 5 Make sure there's no webpack deprecation warnings. node --trace-deprecation node_modules/webpack/bin/webpack.js Reference Webpakc 4 Tutorial Custom Plugin © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/security/securityBasicNotes.html":{"url":"programming/web/security/securityBasicNotes.html","title":"Security Basic Notes","keywords":"","body":"Security Basic Notes Security Basic Notes Curated List of Vulnerability(漏洞) Object Injection Insecure Object Comparison SQL Injection SQL Injection Protection Click Jacking Click Jacking Protection Session Fixation Protection XSS(Cross-Site-Scripting) Attack XSS Protection CSRF(Cross-Site Request Forgery) - 跨站请求伪造 CSRF Protection File Upload Vulnerabilities File Upload Protection Malicious Redirects Malicious Redirects Protection User Enumeration User Enumeration Protection Login Signup/Reset(not with name, should with email) Inline Document Type Definition in XML XML Protection Information Leakage Information Leakage Protection Secure Treatment of Passwords 目录遍历攻击 Directory Protection 病毒 NPM 包 Package Protection 正则表达式 DoS 攻击 (ReDoS) ReDoS Protection JWT Security Checklist 权限系统 (注册/注册/二次验证/密码重置) 用户数据和权限校验 安卓和 iOS APP 安全头信息和配置 过滤输入 操作 关于人 Curated List of Vulnerability(漏洞) Object Injection __proto__.XX constructor hasOwnProperty Insecure Object Comparison injection: const token = req.cookies.token; // vulnerability: // SESSIONS[constructor] => `true` if (token && SESSIONS[token]) { next(); } solutions: crypto.timiingSafeEqual object.hasOwnProperty(token) SQL Injection user input: ' or 1=1-- SELECT * FROM users WHERE email = 'user@email.com' AND pass = '' or 1=1--' LIMIT 1 SQL Injection Protection parameterized statements // Construct the SQL statement we want to run, specifying the parameter. String sql = \"SELECT * FROM users WHERE email = ?\"; Click Jacking Hover a transparent malicious link upon the true button Click Jacking Protection frame killing snippet /* Hide page by default */ html { display: none; } if (self == top) { // Everything checks out, show the page. document.documentElement.style.display = 'block'; } else { // Break out of the frame. top.location = self.location; } X-Frame-Options // nodejs response.setHeader('X-Frame-Options', 'DENY'); response.setHeader('Content-Security-Policy', \"frame-ancestors 'none'\"); Session Fixation Protection 在 HTTP Cookies 中传输复杂的 Session IDs, 并在成功连接/恶意篡改后重置 Session IDs. where: not passing session IDs in queryStrings/requestBody, instead of passing them in HTTP cookies req.session.regenerate(function(err) { // New session here }); what: generate complex session IDs const generateSessionId = sess => uid(24); how: reset session IDs after set up session successfully how: reset session IDs after it's been changed manually on client(Set-Cookies) XSS(Cross-Site-Scripting) Attack Reflected XSS: url input(search pages) user input: malicious code XSS Protection don't trust user: replace(/|/g, '') trim() using template engine(handlebars, jade, etc...) CSRF(Cross-Site Request Forgery) - 跨站请求伪造 挟制用户在当前已登录的 Web 应用程序上执行非本意的操作, 利用已认证用户(长期 Cookies), 访问攻击者网站, 并被强制执行脚本, 在用户不知情的情况下提交 Get/Post Request with Cookies 给被攻击网站. XSS 利用的是网站对用户(输入)的信任, CSRF 利用的是网站对用户网页浏览器的信任. CSRF Protection GET request 没有副作用 确保 request 正常渠道发起(hidden token check in form) 开启同源策略(Same Origin Policy) Addition Authentication: input password again express/csurf library 进入一个“邪恶”的网站 // old browser 'use strict'; function openUrl(url) { var newTab = window.open(); newTab.opener = null; newTab.location = url; } File Upload Vulnerabilities 当使用 JS 代码限制上传文件类型时, 攻击者 Disable JS in Browser, 并上传 malicious code file. File Upload Protection 对于上传文件: 隔离 + 禁止执行 重命名/Hash 化: 以防攻击者找到此文件 检查文件格式 检查 Content-Type Header 使用 Virus Scanner Malicious Redirects Malicious Redirects Protection Check the Referer when doing redirects function isRelative(url) { return url && url.match(/^\\/[^\\/\\\\]/); } User Enumeration 通过暴力工具得到被攻击网站的用户名单, 并利用社工得到密码 很显然, REST API 无法抵抗此种攻击 E.g GitHub User Profile User Enumeration Protection Login 使攻击者无法枚举用户名, 他无法确定是用户不存在还是密码错误 Login error message: Unkonwn User or Password All login code-paths take the same time on average: time consuming operations All login code-paths take the same context: session IDs, cookies Signup/Reset(not with name, should with email) 使攻击者无法枚举用户名, 他无法确定是用户不存在还是用户已存在 Not Exist: Sending sign-up email Exist: Sending pwd-reset email Inline Document Type Definition in XML Dangerous Macros: XML Bombs XML Externel Entities XML Protection Disable DTD parse in XML parser Information Leakage Server in Response Headers Cookies: JSESSIONID -> java URL: .jsp, .php, .asp Error Message AJAX responses JSON/XML reponses Code Information { Server: Apache/1.3.23 Accept-Ranges: bytes Content-length: 196 Connection: close Content-Type: text/html Cookie: JSESSIONID=XXXXX } { Server: Microsoft-IIS/5.0 Content-Type: text/html Accept-Ranges: bytes ETag: \"b0aac0542e25c31\" Content-Length: 7369 } Information Leakage Protection NODE_ENV=production 处理/混淆/加密原始数据(raw data) 处理/混淆客户端代码 去除工具库的版本信息 Disable the “Server” HTTP Header and Similar Headers Use Clean URLs without extensions Ensure Cookie Parameters are Generic Disable Client-Side Error Reporting Sanitize Data Passed to the Client Obfuscate JavaScript\\ Sanitize Template Files Ensure Correct Configuration of Web Root Directory Secure Treatment of Passwords Hacks Explain 目录遍历攻击 GET /../../../passwd.key HTTP/1.1 Directory Protection 检查请求路径是否安全, 否则不返回响应 病毒 NPM 包 名字与流行包相近, 通过 postinstall 脚本执行病毒脚本，获取系统环境变量信息 e.g crossenv Package Protection No typo in package.json 禁止执行 postinstall 脚本 正则表达式 DoS 攻击 (ReDoS) 正则表达式引擎采用回溯的方式匹配所有可能性，导致性能问题 ReDoS Protection 不使用 NFA 实现的正则表达式引擎, 使用 DFA 实现的正则表达式引擎 不定义性能消耗过大的正则表达式 不动态构造正则表达式 new RegExp() 禁止用户输入影响正则表达式构建/匹配 JWT JSON Web Tokens is small, object-friendly (compared to SAML, Security Assertion Markup Language Tokens) and security for public/private key pair (compared to SWT, Simple Web Tokens) Security Checklist 返回目录 权限系统 (注册/注册/二次验证/密码重置) [ ] 任何地方都使用 HTTPS. [ ] 使用 Bcrypt 存储密码哈希 (没有使用盐的必要 - Bcrypt 干的就是这个事). [ ] 登出之后销毁会话 ID . [ ] 密码重置后销毁所有活跃的会话. [ ] OAuth2 验证必须包含 state 参数. [ ] 登陆成功之后不能直接重定向到开放的路径（需要校验，否则容易存在钓鱼攻击）. [ ] 当解析用户注册/登陆的输入时，过滤 javascript://、 data:// 以及其他 CRLF 字符. [ ] 使用 secure/httpOnly cookies. [ ] 移动端使用 OTP 验证时，当调用 generate OTP 或者 Resend OTP API 时不能把 OTP（One Time Password） 直接返回。（一般是通过发送手机验证短信，邮箱随机 code 等方式，而不是直接 response） [ ] 限制单个用户 Login、Verify OTP、 Resend OTP、generate OTP 等 API 的调用次数，使用 Captcha 等手段防止暴力破解. [ ] 检查邮件或短信里的重置密码的 token，确保随机性（无法猜测） [ ] 给重置密码的 token 设置过期时间. [ ] 重置密码成功后，将重置使用的 token 失效. [ ] Nodejs 等不使用 sudo 运行 用户数据和权限校验 [ ] 诸如我的购物车、我的浏览历史之类的资源访问，必须检查当前登录的用户是否有这些资源的访问权限. [ ] 避免资源 ID 被连续遍历访问，使用 /me/orders 代替 /user/37153/orders 以防你忘了检查权限，导致数据泄露。 [ ] 修改邮箱/手机号码功能必须首先确认用户已经验证过邮箱/手机是他自己的。 [ ] 任何上传功能应该过滤用户上传的文件名，另外，为了普适性的原因（而不是安全问题），上传的东西应该存放到例如 S3 之类的云存储上面(用 lambda 处理)，而不是存储在自己的服务器，防止代码执行。 [ ] 个人头像上传 功能应该过滤所有的 EXIF 标签，即便没有这个需求. [ ] 用户 ID 或者其他的 ID，应该使用 RFC compliant的 `UUID` 而不是整数. 你可以从 github 找到你所用的语言的实现. [ ] JWT（JSON Web Token）很棒.当你需要构建一个 单页应用/API 时使用. 安卓和 iOS APP [ ] 支付网关的 盐（salt） 不应该被硬编码 [ ] 来自第三方的 secret 和 auth token 不应该被硬编码 [ ] 在服务器之间调用的 API 不应该在 app 里面调用 [ ] 在安卓系统下，要小心评估所有申请的 权限 [ ] 在 iOS 系统下，使用系统的钥匙串来存储敏感信息（权限 token、api key、 等等） 不要 把这类信息存储在用户配置里面 [ ] 强烈推荐证书绑定（Certificate pinning） 安全头信息和配置 [ ] 添加 CSP 头信息，减缓 XSS 和数据注入攻击. 这很重要. [ ] 添加 CSRF 头信息防止跨站请求伪造（CSRF）攻击.同时`添加` [SameSite](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) 属性到 cookie 里面. [ ] 添加 HSTS头信息防止 SSL stripping 攻击. [ ] 添加 你的域名到 HSTS 预加载列表 [ ] 添加 X-Frame-Options防止点击劫持. [ ] 添加 X-XSS-Protection缓解 XSS 攻击. [ ] 更新 DNS 记录，增加 SPF记录防止垃圾邮件和钓鱼攻击. [ ] 如果你的 Javascript 托管在第三方的 CDN 上面，需要`添加` [内部资源集成检查](https://en.wikipedia.org/wiki/Subresource_Integrity) 。 为了更加安全，添加[require-sri-for](https://w3c.github.io/webappsec-subresource-integrity/#parse-require-sri-for) CSP-directive 就不会加载到没有 SRI 的资源 [ ] 使用随机的 CSRF token，业务逻辑 API 可以暴露为 POST 请求。不要把 CSRF token 通过 http 接口暴露出来，比如第一次请求更新的时候 [ ] 在 get 请求参数里面，不要使用临界数据和 token。 暴露服务器日志的同时也会暴露用户数据 过滤输入 [ ] 所有暴露给用户的参数输入都应该`过滤` 防止 [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) 攻击. [ ] 使用参数化的查询防止 SQL 注入. [ ] 过滤所有具有功能性的用户输入，比如 CSV导入 [ ] 过滤一些特殊的用户输入，例如将 robots.txt 作为用户名，而你刚好提供了 coolcorp.io/username 之类的 url来提供用户信息访问页面。（此时变成 coolcorp.io/robots.txt，可能无法正常工作） [ ] 不要自己手动拼装 JSON 字符串，不管这个对象有多么小。请使用你所用的语言相应的库或者框架来编写 [ ] 过滤 那些有点像 URL 的输入，[SSRF](https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit#heading=h.t4tsk5ixehdd) [ ] 在输出显示给用户之前，过滤输出信息 操作 [ ] 如果你的业务很小或者你缺乏经验，可以评估一下使用 AWS 或者一个 PaaS 平台来运行代码 [ ] 在云上使用正规的脚本创建虚拟机 [ ] 检查所有机器没有必要开放的端口 [ ] 检查数据库是否没有设置密码或者使用默认密码，特别是 MongoDB 和 Redis [ ] 使用 SSH 登录你的机器，不要使用密码，而是通过 SSH key 验证来登录 [ ] 及时更新系统，防止出现 0day 漏洞，比如 Heartbleed、Shellshock 等 [ ] 修改服务器配置，HTTPS 使用 TLS1.2，禁用其他的模式。(值得这么做) [ ] 不要在线上开启 DEBUG 模式，有些框架，DEBUG 模式会开启很多权限以及后门，或者是暴露一些敏感数据到错误栈信息里面 [ ] 对坏人和 DDOS 攻击要有所准备，使用那些提供 DDOS 清洗的主机服务 [ ] 监控你的系统，同时记录到日志里面 (例如使用 New Relic 或者其他 ). [ ] 如果是 2B 的业务，坚持顺从需求。如果使用 AWS S3,可以考虑使用[数据加密](http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) 功能. 如果使用 AWS EC2，考虑使用磁盘加密功能（现在系统启动盘也能加密了） 关于人 [ ] 开一个邮件组（例如：security@coolcorp.io）和搜集页面，方便安全研究人员提交漏洞 [ ] 取决于你的业务，限制用户数据库的访问 [ ] 对报告 bug、漏洞的人有礼貌 [ ] 把你的代码给那些有安全编码观念的同伴进行 review (More eyes) [ ] 被黑或者数据泄露时，检查数据访问前的日志，通知用户更改密码。你可能需要外部的机构来帮助审计 [ ] 使用 Netflix Scumblr 及时了解你的组织（公司）在社交网络或者搜索引擎上的一些讨论信息，比如黑客攻击、漏洞等等 © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/vuejs/vueBasicNotes.html":{"url":"programming/web/vuejs/vueBasicNotes.html","title":"Vue Basic Notes","keywords":"","body":"Vue Basic Notes Vue Basic Notes Slot Internal of Vue Vue Constructor prototype of Vue Global API of Vue Vue Instance Read-only property Shared Utils Options of Vue Normalize Options Merge Options Reactive Data Pattern Two-Way Binding Virtual DOM Diff and Patch Router Navigation Guards Vue CLI SCSS Config Slot Web Slot name attr fallback content const Tab = san.defineComponent({ template: '' + ' slot fallback content' + ' slot fallback content' + '' }); const MyComponent = san.defineComponent({ components: { 'ui-tab': Tab }, template: '' + '1one' + '2twoslot fail' + '' }); /* MyComponent 渲染结果，a 元素无法被插入 title slot 12 onetwoslot fail */ Internal of Vue vue-design Vue Constructor src/core/instance/index.js // 从五个文件导入五个方法（不包括 warn） import { initMixin } from './init'; import { stateMixin } from './state'; import { renderMixin } from './render'; import { eventsMixin } from './events'; import { lifecycleMixin } from './lifecycle'; import { warn } from '../util/index'; // 定义 Vue 构造函数 function Vue(options) { if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) { warn('Vue is a constructor and should be called with the `new` keyword'); } this._init(options); } // 将 Vue 作为参数传递给导入的五个方法 initMixin(Vue); stateMixin(Vue); eventsMixin(Vue); lifecycleMixin(Vue); renderMixin(Vue); // 导出 Vue export default Vue; prototype of Vue // initMixin(Vue) src/core/instance/init.js ************************************************** Vue.prototype._init = function(options?: Object) {}; // stateMixin(Vue) src/core/instance/state.js ************************************************** Vue.prototype.$data; Vue.prototype.$props; Vue.prototype.$set = set; Vue.prototype.$delete = del; Vue.prototype.$watch = function( expOrFn: string | Function, cb: any, options?: Object ): Function {}; // eventsMixin(Vue) src/core/instance/events.js ************************************************** Vue.prototype.$on = function( event: string | Array, fn: Function ): Component {}; Vue.prototype.$once = function(event: string, fn: Function): Component {}; Vue.prototype.$off = function( event?: string | Array, fn?: Function ): Component {}; Vue.prototype.$emit = function(event: string): Component {}; // lifecycleMixin(Vue) src/core/instance/lifecycle.js ************************************************** Vue.prototype._update = function(vnode: VNode, hydrating?: boolean) {}; Vue.prototype.$forceUpdate = function() {}; Vue.prototype.$destroy = function() {}; // renderMixin(Vue) src/core/instance/render.js ************************************************** // installRenderHelpers 函数中 Vue.prototype._o = markOnce; Vue.prototype._n = toNumber; Vue.prototype._s = toString; Vue.prototype._l = renderList; Vue.prototype._t = renderSlot; Vue.prototype._q = looseEqual; Vue.prototype._i = looseIndexOf; Vue.prototype._m = renderStatic; Vue.prototype._f = resolveFilter; Vue.prototype._k = checkKeyCodes; Vue.prototype._b = bindObjectProps; Vue.prototype._v = createTextVNode; Vue.prototype._e = createEmptyVNode; Vue.prototype._u = resolveScopedSlots; Vue.prototype._g = bindObjectListeners; Vue.prototype.$nextTick = function(fn: Function) {}; Vue.prototype._render = function(): VNode {}; // core/index.js 文件中 Object.defineProperty(Vue.prototype, '$isServer', { get: isServerRendering }); Object.defineProperty(Vue.prototype, '$ssrContext', { get() { /* istanbul ignore next */ return this.$vnode && this.$vnode.ssrContext; } }); // 在 runtime/index.js 文件中 Vue.prototype.__patch__ = inBrowser ? patch : noop; Vue.prototype.$mount = function( el?: string | Element, hydrating?: boolean ): Component { el = el && inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating); }; // 在入口文件 entry-runtime-with-compiler.js 中重写了 Vue.prototype.$mount 方法 Vue.prototype.$mount = function( el?: string | Element, hydrating?: boolean ): Component { // ... 函数体 }; Global API of Vue // initGlobalAPI Vue.config; Vue.util = { warn, extend, mergeOptions, defineReactive }; Vue.set = set; Vue.delete = del; Vue.nextTick = nextTick; Vue.options = { components: { KeepAlive // Transition 和 TransitionGroup 组件在 runtime/index.js 文件中被添加 // Transition, // TransitionGroup }, directives: Object.create(null), // 在 runtime/index.js 文件中，为 directives 添加了两个平台化的指令 model 和 show // directives:{ // model, // show // }, filters: Object.create(null), _base: Vue }; // initUse ***************** global-api/use.js Vue.use = function(plugin: Function | Object) {}; // initMixin ***************** global-api/mixin.js Vue.mixin = function(mixin: Object) {}; // initExtend ***************** global-api/extend.js Vue.cid = 0; Vue.extend = function(extendOptions: Object): Function {}; // initAssetRegisters ***************** global-api/assets.js Vue.component = Vue.directive = Vue.filter = function( id: string, definition: Function | Object ): Function | Object | void {}; // expose FunctionalRenderContext for ssr runtime helper installation Object.defineProperty(Vue, 'FunctionalRenderContext', { value: FunctionalRenderContext }); Vue.version = '__VERSION__'; // entry-runtime-with-compiler.js Vue.compile = compileToFunctions; Vue Instance // Vue.prototype._init vm._uid = uid++; // 每个Vue实例都拥有一个唯一的 id vm._isVue = true; // 这个表示用于避免Vue实例对象被观测(observed) vm.$options; // 当前 Vue 实例的初始化选项，注意：这是经过 mergeOptions() 后的 vm._renderProxy = vm; // 渲染函数作用域代理 vm._self = vm; // 实例本身 // initLifecycle(vm) src/core/instance/lifecycle.js ************************************************** vm.$parent = parent; vm.$root = parent ? parent.$root : vm; vm.$children = []; vm.$refs = {}; vm._watcher = null; vm._inactive = null; vm._directInactive = false; vm._isMounted = false; vm._isDestroyed = false; vm._isBeingDestroyed = false; // initEvents(vm) src/core/instance/events.js ************************************************** vm._events = Object.create(null); vm._hasHookEvent = false; // initRender(vm) src/core/instance/render.js ************************************************** vm._vnode = null; // the root of the child tree vm._staticTrees = null; // v-once cached trees vm.$vnode; vm.$slots; vm.$scopedSlots; vm._c; vm.$createElement; vm.$attrs; vm.$listeners; // initState(vm) src/core/instance/state.js ************************************************** vm._watchers = []; vm._data; // mountComponent() src/core/instance/lifecycle.js vm.$el; // initComputed() src/core/instance/state.js vm._computedWatchers = Object.create(null); // initProps() src/core/instance/state.js vm._props = {}; // initProvide() src/core/instance/inject.js vm._provided; Read-only property const dataDef = {}; dataDef.get = function() { return this._data; }; const propsDef = {}; propsDef.get = function() { return this._props; }; if (process.env.NODE_ENV !== 'production') { dataDef.set = function(newData: Object) { warn( 'Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this ); }; propsDef.set = function() { warn(`$props is readonly.`, this); }; } Object.defineProperty(Vue.prototype, '$data', dataDef); Object.defineProperty(Vue.prototype, '$props', propsDef); Shared Utils /* @flow */ export const emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their // explicitness and function inlining. export function isUndef(v: any): boolean %checks { return v === undefined || v === null; } export function isDef(v: any): boolean %checks { return v !== undefined && v !== null; } export function isTrue(v: any): boolean %checks { return v === true; } export function isFalse(v: any): boolean %checks { return v === false; } /** * Check if value is primitive. */ export function isPrimitive(value: any): boolean %checks { return ( typeof value === 'string' || typeof value === 'number' || // $flow-disable-line typeof value === 'symbol' || typeof value === 'boolean' ); } /** * Quick object check - this is primarily used to tell * Objects from primitive values when we know the value * is a JSON-compliant type. */ export function isObject(obj: mixed): boolean %checks { return obj !== null && typeof obj === 'object'; } /** * Get the raw type string of a value, e.g., [object Object]. */ const _toString = Object.prototype.toString; export function toRawType(value: any): string { return _toString.call(value).slice(8, -1); } /** * Strict object type check. Only returns true * for plain JavaScript objects. */ export function isPlainObject(obj: any): boolean { return _toString.call(obj) === '[object Object]'; } export function isRegExp(v: any): boolean { return _toString.call(v) === '[object RegExp]'; } /** * Check if val is a valid array index. */ export function isValidArrayIndex(val: any): boolean { const n = parseFloat(String(val)); return n >= 0 && Math.floor(n) === n && isFinite(val); } /** * Convert a value to a string that is actually rendered. */ export function toString(val: any): string { return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val); } /** * Convert an input value to a number for persistence. * If the conversion fails, return original string. */ export function toNumber(val: string): number | string { const n = parseFloat(val); return isNaN(n) ? val : n; } /** * Make a map and return a function for checking if a key * is in that map. */ export function makeMap( str: string, expectsLowerCase?: boolean ): (key: string) => true | void { const map = Object.create(null); const list: Array = str.split(','); for (let i = 0; i map[val.toLowerCase()] : val => map[val]; } /** * Check if a tag is a built-in tag. */ export const isBuiltInTag = makeMap('slot,component', true); /** * Check if an attribute is a reserved attribute. */ export const isReservedAttribute = makeMap('key,ref,slot,slot-scope,is'); /** * Remove an item from an array. */ export function remove(arr: Array, item: any): Array | void { if (arr.length) { const index = arr.indexOf(item); if (index > -1) { return arr.splice(index, 1); } } } /** * Check whether an object has the property. */ const hasOwnProperty = Object.prototype.hasOwnProperty; export function hasOwn(obj: Object | Array, key: string): boolean { return hasOwnProperty.call(obj, key); } /** * Create a cached version of a pure function. */ export function cached(fn: F): F { const cache = Object.create(null); return (function cachedFn(str: string) { const hit = cache[str]; return hit || (cache[str] = fn(str)); }: any); } /** * Camelize a hyphen-delimited string. */ const camelizeRE = /-(\\w)/g; export const camelize = cached( (str: string): string => { return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : '')); } ); /** * Capitalize a string. */ export const capitalize = cached( (str: string): string => { return str.charAt(0).toUpperCase() + str.slice(1); } ); /** * Hyphenate a camelCase string. */ const hyphenateRE = /\\B([A-Z])/g; export const hyphenate = cached( (str: string): string => { return str.replace(hyphenateRE, '-$1').toLowerCase(); } ); /** * Simple bind polyfill for environments that do not support it, * e.g., PhantomJS 1.x. Technically, we don't need this anymore * since native bind is now performant enough in most browsers. * But removing it would mean breaking code that was able to run in * PhantomJS 1.x, so this must be kept for backward compatibility. */ /* istanbul ignore next */ function polyfillBind(fn: Function, ctx: Object): Function { function boundFn(a) { const l = arguments.length; return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx); } boundFn._length = fn.length; return boundFn; } function nativeBind(fn: Function, ctx: Object): Function { return fn.bind(ctx); } export const bind = Function.prototype.bind ? nativeBind : polyfillBind; /** * Convert an Array-like object to a real Array. */ export function toArray(list: any, start?: number): Array { start = start || 0; let i = list.length - start; const ret: Array = new Array(i); while (i--) { ret[i] = list[i + start]; } return ret; } /** * Mix properties into target object. */ export function extend(to: Object, _from: ?Object): Object { for (const key in _from) { to[key] = _from[key]; } return to; } /** * Merge an Array of Objects into a single Object. */ export function toObject(arr: Array): Object { const res = {}; for (let i = 0; i false; /* eslint-enable no-unused-vars */ /** * Return the same value. */ export const identity = (_: any) => _; /** * Generate a string containing static keys from compiler modules. */ export function genStaticKeys(modules: Array): string { return modules .reduce((keys, m) => { return keys.concat(m.staticKeys || []); }, []) .join(','); } /** * Check if two values are loosely equal - that is, * if they are plain objects, do they have the same shape? */ export function looseEqual(a: any, b: any): boolean { if (a === b) return true; const isObjectA = isObject(a); const isObjectB = isObject(b); if (isObjectA && isObjectB) { try { const isArrayA = Array.isArray(a); const isArrayB = Array.isArray(b); if (isArrayA && isArrayB) { return ( a.length === b.length && a.every((e, i) => { return looseEqual(e, b[i]); }) ); } else if (a instanceof Date && b instanceof Date) { return a.getTime() === b.getTime(); } else if (!isArrayA && !isArrayB) { const keysA = Object.keys(a); const keysB = Object.keys(b); return ( keysA.length === keysB.length && keysA.every(key => { return looseEqual(a[key], b[key]); }) ); } else { /* istanbul ignore next */ return false; } } catch (e) { /* istanbul ignore next */ return false; } } else if (!isObjectA && !isObjectB) { return String(a) === String(b); } else { return false; } } /** * Return the first index at which a loosely equal value can be * found in the array (if value is a plain object, the array must * contain an object of the same shape), or -1 if it is not present. */ export function looseIndexOf(arr: Array, val: mixed): number { for (let i = 0; i Options of Vue vm.$options = mergeOptions( // resolveConstructorOptions(vm.constructor) { components: { KeepAlive Transition, TransitionGroup }, directives:{ model, show }, filters: Object.create(null), _base: Vue }, // options || {} { el: '#app', data: { test: 1 } }, vm ) Normalize Options props props: { someData1: { type: Number }, someData2: { type: String, default: '' } } injects inject: { 'data1': { from: 'data1' }, 'd2': { from: 'data2' }, 'data3': { from: 'data3', someProperty: 'someValue' } } directives for (const key in dirs) { const def = dirs[key]; if (typeof def === 'function') { dirs[key] = { bind: def, update: def }; } } Merge Options 对于 el、propsData 选项使用默认的合并策略 defaultStrat 对于 data 选项，使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象 对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行 对于 directives、filters 以及 components 等资源选项， 父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等 对于 watch 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行 对于 props、methods、inject、computed 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段 对于 provide 选项，其合并策略使用与 data 选项相同的 mergeDataOrFn 函数 最后，以上没有提及到的选项都将使默认选项 defaultStrat 最最后，默认合并策略函数 defaultStrat 的策略是：只要子选项不是 undefined 就使用子选项，否则使用父选项 Reactive Data Pattern data getter/setter -- notify -> watcher -- trigger --> render data.a; // getHook() get called data.a = 2; // setHook() get called Two-Way Binding View-Model 主要做了两件微小的事情： 从 M 到 V 的映射 (Data Binding), 这样可以大量节省人肉来 update View 的代码: 通过 Proxy 代理 Model, 每当调用 Model[property].set 时同时调用 render 从 V 到 M 的事件监听 (DOM Listeners), 这样 Model 会随着 View 触发事件而改变 const _data = { name: 'mark' }; // new Proxy(target, handler); let changeName = new Proxy(_data, { set(obj, name, value) { obj[name] = value; render(); } }); Array.from(el.getElementsByTagName('input')) .filter(ele => { return ele.getAttribute('v-model'); }) .forEach(input => { let name = input.getAttribute('v-model'); input.value = changeName[name]; // DOM Event Listener (listen to the changes of view) input.oninput = function() { changeName[name] = this.value; }; }); Virtual DOM Diff and Patch Router Navigation Guards Offical Documentation of Router Guards Vue CLI SCSS Config Build with Bulma Every element and every style for this scoped styled component will have a data-v-2929 on them at runtime. If import a Sass file into component that has actual styles in it, Vue (via webpack) will pull in those styles and \"namespace\" them with that dynamic data- attribute. The result is that is include Bulma in your many times with a bunch of data-v weirdness in front of it. /* bulma-custom.scss */ @import './variables.scss'; /* UTILTIES */ @import 'bulma/sass/utilities/animations.sass'; @import 'bulma/sass/utilities/controls.sass'; @import 'bulma/sass/utilities/mixins.sass'; /* etc... */ /* site.scss */ @import url('https://use.fontawesome.com/releases/v5.6.3/css/all.css'); @import './bulma-custom.scss'; html, body { height: 100%; background-color: #f9fafc; } /* etc... */ // main.js import Vue from 'vue'; import App from './App.vue'; import router from './router'; // import styles import '@/styles/site.scss'; // webpack.config.js module.exports = { css: { loaderOptions: { sass: { data: `@import \"@/styles/variables.scss\";` } } } }; © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "},"programming/web/libraryBasicNotes.html":{"url":"programming/web/libraryBasicNotes.html","title":"Library Basic Notes","keywords":"","body":"Library Basic Notes Library Basic Notes Indexing Tools Boilerplate UI Framework Framework and Solution Frontend Solution Micro Frontends Solution Backend Solution Full Stack Solution Desktop Solution State Data Management Redux Hooks Other Browser Utils JavaScript Utils String Utils Functional Programming Utils TypeScript Utils CSS Utils Color Utils Gradients Utils Box Shadows Utils Background Utils Components Layout Navigation Landing Page Button Card Chat Widgets Comments System Message Page Indicator Prompt Alert Focus Tooltip Form Input Select Validator List List Virtualized Windowing Table Charts Slides iFrame Viewport Utils Scroll Utils Mouse Utils Animation Typing Effect Animation Loading Effect Animation Progress Bar Skeleton Spinner Hover Effect Animation Time Date Calendar i18n Social Sharing Fonts Images Image Color Icons Emoji SVG Image Size Slide Images Image Gallery Image Filter Canvas Particles Blocks 3D Engine Media Audio Video Clipboard Keyboard Editor Rich Text Editor Code Editor SMS Phone Email File File Uploader File Downloader File Utils PDF Persistent Storage Search CLI CLI Compiler CLI Library Terminal Daemon Network Network Protocols Web Socket P2P Pre-Fetch Lazy Loading Network Benchmark Network Debugging Server Serverless Encryption Debug Testing Unit Testing Feature Testing End to End Testing Headless Web Tools Code Analysis Tools Code Coverage Tools Code Quality Tools Inspect Tools Monitoring Tools Performance Tools Log Tools Mock Tools Security Tools UML Tools DevOps Project Tools CI Tools Documentation Indexing Tools Open Base Best of JS Micro.js NPM Package Trends NPM Package Cost Boilerplate HTML5 Boilerplate Create React App React Component Boilerplate Neutrino.js Customizable Boilerplate Hygen Component Generator React Chrome Extension Vue CLI Vite UI Framework React Ant Design React Mantine with Hooks React Material UI React Semantic UI React BluePrint IceWorks Vue Admin UI Tailwind Bootstrap Paper.css NES.css Framework and Solution Frontend Solution React Storybook Gatsby.js UMI Micro Frontends Solution Bit UMI QianKun IceStark Single SPA Backend Solution Egg.js Feathers.js: RESTful API Full Stack Solution Next.js Desktop Solution Electron Tauri State Data Management Redux Redux Helper Tools Reselect Hooks React Hooks Gallery Ali Hooks Other RxJS Middleware React Resolver Baobab Browser Utils Browser Platform Detection Browser Feature Detection JavaScript Utils Cash: jQuery Lite String Utils String Manipulation Fuzzy String Matching Functional Programming Utils Immer TypeScript Utils TypeBox: JSON Schema Type Builder CSS Utils CSS Normalize Styled System CSS Classnames Awesome Design Tools Color Utils Color Palettes from Online Website Culori Color Difference Library Gradients Utils Web Gradients Box Shadows Utils Box Shadows Background Utils Clippy: Clip-Path Maker Components Layout Full Page Layout One Page Layout React Panel Group Bricks Layout Brick Layer Tether: Element Location SplitJS Navigation Okay nav Animated Nav Burgers Menu Icon Click Animation Pagemap Landing Page Video Landing Page Button React Awesome 3D Button Tiny Fab Card GitHub Information Card Bootcards Chat Widgets React Chat Widget Matrix JsSIP: Chat Library Comments System Utterances: GitHub Issue Based Comments Widget Disqus Message Awesome Prompt Messenger TheaterJS: Typing Effect Guide Tour Intro.js Page Indicator React Snakke Prompt GalGame ChatView Popper.js Humane.js Desktop Notification Nodejs Notification Alert Sweet Alert 2 Sweet Alert Focus driver.js Tooltip tippy.js Balloon Hovering Tooltips Hint.css Tooltips React Tooltip Form React Formik Form Boilerplate Input IMask.js: Input Mask Super Placeholder AutoComplete.js Select React Select Select.css Awesome Chosen Validator Promise Validator Async Validator Input Format joi yup jQuery Form Validator List Sortable List Virtualized Windowing React Virtualized- Original Component React Virtualized Auto Sizer React Window: Brand New React Virtualized React Virtuoso Vue Virtual Scroller Table React Table(with Hooks API) React Datasheet Bootstrap Table Charts React Chartjs Sigma.js: Graph Drawing HTML5 Chart Plotly.js Slides MDX Deck React Spectacle Reveal.js HTML Presentation Glider.js CLI Animation Presentation Awesome Prezi-Like Presentation Awesome Slide Gallery One Page Vertical Slide iFrame Postmate Viewport Utils Viewport Events Robot.js: Node.js Desktop Automation Scroll Utils Scroll Reveal AOS Scroll Animation Lax Scroll Animation Scroll Bar Detection Mouse Utils React Draft.js React Beautiful DnD React DnD: Drag and Drop Moveable P5.js Nipple.js Interact.js: Drag, Drop and Resizing Multi Touch Drag and Drop Grid Layout Moveable Animation React Spring Framer Motion React Transition Group React Animation GreenSock Airbnb AE Solution Effeckt.css animate.css Anime Velocity Animation Ramjet Barba.js Motto Animated Words Popmotion Typing Effect Animation Typed.js TypeIt Loading Effect Animation Progress Bar NProgress.js Skeleton Vue Skeleton Spinner Epic Spinners Loading IO Hover Effect Animation Image Hover Hovering Button Effects Time Date Day.js Date Lodash Moment.js Time Table Calendar Big Calendar React Calendar GitHub Style Calendar i18n React i18n Next React Intl Numbers and Currencies Social Sharing One-Key Share Sharing Social Share URLs Fonts Fontmin Chinese WebFont Zip Fonts.css Poppins Raleway Operator Images ICO Images API JavaScript Load Image Sharp Image Color Color Difference Library Icons Remix Icons Icon Font Icons8 Ikonate CSS Icons Emoji OwO Keyboard Emoji Twitter Emoji Emoji Panel SVG React SVG Components SVG.js SVG Optimizer SVG Gallery SVG Logos SVG Icons DVI2SVG Image Size Variant Size Pictures Slide Images placeholder.js Pictures Viewer Gallery Image Gallery Light Gallery Photo Swipe Image Filter Pictures Color Style Filter Rainy Day Effect Image Difference Library Canvas HTML2Canvas Rough.js Canvas Manipulation Particles HTML5 Particles React Particle Animation React Particle Button Blocks Obelisk.js 3D Engine CSS 3D Engine Three.js Krpano Media Audio Howler.js Music Helper Utils Elementary Audio Tools MIDI.js Video React Player Video.js Plyr FLV.js Clipboard Clipboard Keyboard Hot Key Editor Rich Text Editor React Markdown Block Editor CKEditor Wang Editor Markdown Editor Code Editor React Draft.js Editor React ACE ACE Editor Code Mirror Block Editor SMS Phone Twilio Email Node Emailer Email Parser Email Generator MJML Markup Language IMAP MailSpring File zTree v3 FileAPI File Uploader React Filepond Vue Filepond Uppy Uploader File Downloader You Get Motrix File Utils Human Readable File Size Globby File Type PDF PDFMake PDFKit Persistent Storage PouchDB ImmortalDB lowdb brownies store.js localForage Search React Search Bar SearchKit Full Text Search Engine CLI CLI Compiler PKG NCC CLI Library Oclif: Open CLI Framework INK: React CLI App Nexe: Node EXE Wrapper ZX: Ndoe Bash Wrapper Commander Inquirer Chalk ORA Spinner Progress Babun: Windows Zsh Terminal React Terminal React Console Emulator Jay: Supercharged JavaScript REPL Daemon PM2 Nodemon Network Network Protocols TelNet IMAP Web Socket Socket.IO P2P FireFox Send Pre-Fetch Google QuickLink Lazy Loading System.js Lazyload.js LAB.js: Await/Async Lazy Loading Network Benchmark HTTP/HTTPS Troubleshooting and Profiling HTTP/HTTPS Benchmarking Tool Network Debugging Whistle Server Parse Server Serverless Serverless Framework Encryption MD5 Base64 Debug Testing NDB React Testing Utilities React Component Hierarchy React a11y Retoggle: Component Inspector Unit Testing Jest Jest UI Enzyme React Testing Library Jasmine Mocha Assert Testem Feature Testing Karma Webkit API(Chrome) Gecko API(Firefox) Selenium Interactor.js End to End Testing Cypress NightWatch: End to End Testing Framework LightHouse WebPageTest WebHint Headless Web Tools Cheerio: jQuery Server Tools Puppeteer: Headless Chrome Tools Code Analysis Tools Babel.js AST Explorer Codecrumbs Code Coverage Tools Istanbul Coverage Karma Coverage Code Quality Tools HTML Head Checklist ESLint Node Security CSS Stats Tools CSS Stats CLI Inspect Tools NDB Reactotron Monitoring Tools NetData Source Buster Uptime Status Performance Tools React Re-Rendering Alert Node Clinic Perf Tools FlameGraph Log Tools Log4.js Stacktrace.js Stacktrace Visualization Log Analyzer HTTP Loger Mock Tools Public APIs Mockery Function [Mock Service Worker][https://github.com/mswjs/msw] Nock Server JSON Server Images Mock Images Placeholder Pokemon API Security Tools Sqlmap Zaproxy Arachni Naughty Input Strings) FatRat Spoof UML Tools Draw.io PlantUML DevOps Project Tools Node Maintenance Tools CI Tools ProBot Documentation Docusaurus Vuepress TypeDoc Docz DUmi Documentation.js Wiki.js © sabertazimi · 遵循 知识共享 署名-非商业性使用 4.0 国际 许可协议 all right reserved，powered by Gitbook最近更新： 2021-07-15 21:57 "}}